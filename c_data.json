{
    "10Kaiser10/n-body-simulation-openMP/src/simulation/2": {
        "code": "for (int i = 0; i < (numIters / 100); i++)\n{\n  for (int j = 0; j < 1000; j++)\n  {\n    fprintf(trajec, \"%-8.2f\", outLog[i][j].x);\n  }\n\n  fprintf(trajec, \"\\n\");\n  for (int j = 0; j < 1000; j++)\n  {\n    fprintf(trajec, \"%-8.2f\", outLog[i][j].y);\n  }\n\n  fprintf(trajec, \"\\n\");\n  for (int j = 0; j < 1000; j++)\n  {\n    fprintf(trajec, \"%-8.2f\", outLog[i][j].z);\n  }\n\n  fprintf(trajec, \"\\n\\n\");\n}\n",
        "pragma": ""
    },
    "97amarnathk/steadyStateHeat/src/steadyStateHeat/9": {
        "code": "for (j = 1; j < (m - 1); j++)\n{\n  for (i = 1; i < (n - 1); i++)\n  {\n    newVal = 0.25 * (((grid[j - 1][i] + grid[j + 1][i]) + grid[j][i - 1]) + grid[j][i + 1]);\n    error = max(error, fabs(newVal - grid[j][i]));\n    grid[j][i] = newVal;\n  }\n\n}\n",
        "pragma": ""
    },
    "A-Nikhil/OpenMP-Programming/Lab_1/dotProduct/2": {
        "code": "for (i = 0; i < 10; i++)\n{\n  printf(\" u[%d]= %.1f\\t v[%d]= %.1f\\n\", i, u[i], i, v[i]);\n}\n",
        "pragma": ""
    },
    "AMDComputeLibraries/OpenMPApps/hpgmg-mp4/finite-volume/source/operators/problem.p4/0": {
        "code": "for (k = 0; k <= dim_k; k++)\n{\n  for (j = 0; j <= dim_j; j++)\n  {\n    for (i = 0; i <= dim_i; i++)\n    {\n      int ijk = ((i + ghosts) + ((j + ghosts) * jStride)) + ((k + ghosts) * kStride);\n      double x = hLevel * (((double) (i + level->my_boxes[box].low.i)) + 0.5);\n      double y = hLevel * (((double) (j + level->my_boxes[box].low.j)) + 0.5);\n      double z = hLevel * (((double) (k + level->my_boxes[box].low.k)) + 0.5);\n      double A;\n      double B;\n      double Bx;\n      double By;\n      double Bz;\n      double Bi;\n      double Bj;\n      double Bk;\n      double U;\n      double Ux;\n      double Uy;\n      double Uz;\n      double Uxx;\n      double Uyy;\n      double Uzz;\n      A = 1.0;\n      B = 1.0;\n      Bx = 0.0;\n      By = 0.0;\n      Bz = 0.0;\n      Bi = 1.0;\n      Bj = 1.0;\n      Bk = 1.0;\n      evaluateU(x, y, z, &U, &Ux, &Uy, &Uz, &Uxx, &Uyy, &Uzz, level->boundary_condition.type == BC_PERIODIC);\n      double F = ((a * A) * U) - (b * ((((Bx * Ux) + (By * Uy)) + (Bz * Uz)) + (B * ((Uxx + Uyy) + Uzz))));\n      level->my_boxes[box].vectors[VECTOR_BETA_I][ijk] = Bi;\n      level->my_boxes[box].vectors[VECTOR_BETA_J][ijk] = Bj;\n      level->my_boxes[box].vectors[VECTOR_BETA_K][ijk] = Bk;\n      level->my_boxes[box].vectors[VECTOR_ALPHA][ijk] = A;\n      level->my_boxes[box].vectors[VECTOR_F][ijk] = F;\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for private(k,j,i) collapse(3)"
    },
    "ASGdev/mn-openmp/blas1/axpy/6": {
        "code": "for (i = 0, j = 0; j < N; i += 2, j += 2)\n{\n  x1 = _mm_load_pd(X + i);\n  y1 = _mm_load_pd(Y + i);\n  x2 = _mm_mul_pd(x1, alpha1);\n  y2 = _mm_add_pd(y1, x2);\n  _mm_store_pd(Y + i, y2);\n}\n",
        "pragma": ""
    },
    "ASGdev/mn-openmp/blas1/gemv/6": {
        "code": "for (i = 0; i < (M * 2); i += incX + 1)\n{\n  r.REEL = 0;\n  r.IMAG = 0;\n  indice = i * M;\n  for (j = 0; j < (M * 2); j += incY + 1)\n  {\n    float4 o1;\n    float4 o2;\n    float4 rf;\n    o1[0] = (o1[1] = *((AP + indice) + j));\n    o1[2] = (o1[3] = *(((AP + indice) + j) + 1));\n    o2[0] = *(XP + i);\n    o2[3] = *(XP + i);\n    o2[2] = (o2[1] = *((XP + i) + 1));\n    int m1 = _mm_load_ps(o1);\n    int m2 = _mm_load_ps(o2);\n    int rmat = _mm_mul_ps(m1, m2);\n    int rm = _mm_addsub_ps(rmat, _mm_shuffle_ps(rmat, rmat, _MM_SHUFFLE(0, 0, 3, 2)));\n    _mm_store_ps(rf, rm);\n    r.IMAG += rf[1];\n    r.REEL += rf[0];\n  }\n\n  vcomplexe temp;\n  temp.REEL = *(YP + i);\n  temp.IMAG = *((YP + i) + 1);\n  int o1;\n  int o2;\n  int o3;\n  int o4;\n  int m1;\n  int m2;\n  int reel;\n  int imag;\n  float4 o1f;\n  float4 o2f;\n  float4 o3f;\n  float4 o4f;\n  float4 reel4;\n  float4 imag4;\n  o1f[0] = *(YP + i);\n  o1f[1] = *((YP + i) + 1);\n  o1f[2] = av->REEL;\n  o1f[3] = av->IMAG;\n  o2f[0] = bv->IMAG;\n  o2f[1] = bv->REEL;\n  o2f[2] = r.IMAG;\n  o2f[3] = r.REEL;\n  printvec(o1f, 4);\n  printvec(o2f, 4);\n  o3f[0] = o1f[0];\n  o3f[1] = o1f[1];\n  o3f[2] = av->REEL;\n  o3f[3] = av->IMAG;\n  o4f[0] = bv->REEL;\n  o4f[1] = bv->IMAG;\n  o4f[2] = r.REEL;\n  o4f[3] = r.IMAG;\n  printvec(o3f, 4);\n  printvec(o4f, 4);\n  o1 = _mm_load_ps(o1f);\n  o2 = _mm_load_ps(o2f);\n  o3 = _mm_load_ps(o3f);\n  o4 = _mm_load_ps(o4f);\n  m1 = _mm_mul_ps(o3, o4);\n  m2 = _mm_sub_ps(m1, _mm_shuffle_ps(m1, m1, _MM_SHUFFLE(0, 3, 0, 1)));\n  _mm_store_ps(reel4, m2);\n  *(YP + i) = reel4[0] + reel4[2];\n  imag = _mm_dp_ps(o1, o2, 0xFF);\n  _mm_store_ps(imag4, imag);\n  *((YP + i) + 1) = imag4[0];\n}\n",
        "pragma": ""
    },
    "Abhiramkns/openmpi-Implementions/matmul/cmm/4": {
        "code": "for (int i = 0; i < s; i++)\n{\n  int a = matA[r][0];\n  for (int j = 1; j < 2; j++)\n  {\n    matA[r][j - 1] = matA[r][j];\n  }\n\n  matA[r][2 - 1] = a;\n}\n",
        "pragma": "#pragma omp for"
    },
    "Adahn/Project_Parallelism/version2/MPI/main/2": {
        "code": "for (int depth = 1;; depth++)\n{\n  T->depth = depth;\n  T->height = 0;\n  T->alpha_start = (T->alpha = (-MAX_SCORE) - 1);\n  T->beta = MAX_SCORE + 1;\n  printf(\"=====================================\\n\");\n  evaluate(T, result);\n  printf(\"depth: %d / score: %.2f / best_move : \", T->depth, 0.01 * result->score);\n  print_pv(T, result);\n  if (DEFINITIVE(result->score))\n    break;\n\n}\n",
        "pragma": ""
    },
    "Aerron/sudoku_openmp_c_2017/sudoku/9": {
        "code": "for (int myrow = 0; myrow < MINIGRIDSIZE; myrow++)\n  for (int mycol = 0; mycol < MINIGRIDSIZE; mycol++)\n  if ((myrow != row) && (mycol != uniquecol))\n{\n  possiblevalues[myrow + boxStartRow][mycol + boxStartCol][num] = 0;\n}\n\n\n",
        "pragma": "#pragma omp parallel for"
    },
    "AhmedeZ2001/K-means-Clustering/2/2": {
        "code": "for (i = 0; i < clustar_num; i++)\n{\n  printf(\"points in cluster %d\", i);\n  for (j = 0; j < n; j++)\n  {\n    if (objects[j].clusterid == i)\n      printf(\"  (%d , %d)   \", objects[j].x, objects[j].y);\n\n  }\n\n  printf(\"\\n\");\n}\n",
        "pragma": "#pragma omp for schedule(static)"
    },
    "Aiden-Frost/Linear-Algebra-openMP/2.LU_Decomposition/LU_openMP_Improvised_Version/1": {
        "code": "for (int i = 0; i < (n - 1); i++)\n{\n  if (b[i][i] == 0)\n  {\n    for (int m = i + 1; m < n; m++)\n    {\n      if (b[m][i] != 0)\n      {\n        for (int x = 0; x < (n + 1); x++)\n        {\n          float temp = b[i][x];\n          b[i][x] = b[m][x];\n          b[m][x] = temp;\n        }\n\n        break;\n      }\n\n    }\n\n    if (b[i][i] == 0)\n      x = 0;\n\n  }\n\n  for (int k = 1; k < (n - i); k++)\n  {\n    float l = b[i + k][i] / b[i][i];\n    L[i + k][i] = l;\n    for (int j = 0; j < (n + 1); j++)\n    {\n      b[i + k][j] -= l * b[i][j];\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for private(x)"
    },
    "Andrzej97/OpenMP/alg3/10": {
        "code": "for (i = 0; i < 100; i++)\n{\n  free(bigBuckets[i].elems);\n}\n",
        "pragma": ""
    },
    "AnisB/ParallelTP/TP2/inf8601-lab2-2.1.3/encode/algo/2": {
        "code": "for (i = 0; i < width; i++)\n{\n  for (j = 0; j < height; j++)\n  {\n    int index = i + (j * width);\n    data[index] = data[index] + key;\n    checksum += data[index];\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for private(i,j) reduction(+:checksum)"
    },
    "Annirudh2810/GA-implementation-using-C/Rosenbrock parallel/8": {
        "code": "for (i = 0; i < 250; i++)\n{\n  for (j = 0; j < 150; j++)\n  {\n    fprintf(fp, \"%lf  \", a1[i][j]);\n  }\n\n  fprintf(fp, \"\\n\");\n}\n",
        "pragma": ""
    },
    "AnouarWalziki/Galaxeirb/1024_particles_OpenMP/src/main/4": {
        "code": "for (i = 204; i < 407; i++)\n{\n  glColor3f(0.5625f, 0.92f, 0.5625f);\n  glVertex3f(Shuffled_galaxysParticles[i].position_x, Shuffled_galaxysParticles[i].position_y, Shuffled_galaxysParticles[i].position_z);\n}\n",
        "pragma": ""
    },
    "ArthurZucker/HighPerformanceComputing/Projet/MPI+OMP+Vect/cg/8": {
        "code": "for (int i = 0; i < 31; i++)\n{\n  a = (a >> 8) | (a << (64 - 8)), a += b, a ^= i, b = (b << 3) | (b >> (64 - 3)), b ^= a;\n  x = (x >> 8) | (x << (64 - 8)), x += y, x ^= b, y = (y << 3) | (y >> (64 - 3)), y ^= x;\n}\n",
        "pragma": ""
    },
    "Astrokiwi/openmp_gpu/test/0": {
        "code": "for (ix = 0; ix < L; ix++)\n{\n  for (iy = 0; iy < L; iy++)\n  {\n    x = (ix - (L / 2.)) / L;\n    y = (iy - (L / 2.)) / L;\n    r[(ix * L) + iy] = 1. / ((square(x) + square(y)) + 1.);\n  }\n\n}\n",
        "pragma": "#pragma omp target teams distribute parallel for collapse(2)"
    },
    "Bhuvaneswar005/OpenMP/Assignment 2/Code/qs3/0": {
        "code": "for (i = 0; i < 5; i++)\n{\n  int tid = omp_get_thread_num();\n  c[i] = a[i] + b[i];\n  printf(\"Computation at Thread [%d]=%d\\n\", tid, c[i]);\n}\n",
        "pragma": "#pragma omp for"
    },
    "Bilv/openMP_project/projet_dijkstra/0": {
        "code": "for (int step = 1; step < num_nodes; step++)\n{\n  shortest_dist = 1 << 30;\n  nearest_node = -1;\n  for (int i = 0; i < num_nodes; i++)\n  {\n    if ((!tree[i]) && (min_distance[i] < shortest_dist))\n    {\n      shortest_dist = min_distance[i];\n      nearest_node = i;\n    }\n\n  }\n\n  if (nearest_node == (-1))\n  {\n    fprintf(stderr, \"Warning: Search ended early, the graph might not be connected.\\n\");\n    break;\n  }\n\n  tree[nearest_node] = 1;\n  for (int i = 0; i < num_nodes; i++)\n    if (!tree[i])\n  {\n    int d = get_distance(nearest_node, i);\n    if (d < (1 << 30))\n      if ((min_distance[nearest_node] + d) < min_distance[i])\n      min_distance[i] = min_distance[nearest_node] + d;\n\n\n  }\n\n\n}\n",
        "pragma": ""
    },
    "Blarc/image-compression-k-means/src/compression_omp/1": {
        "code": "for (pixel = 0; pixel < n_pixels; pixel++)\n{\n  min_cluster = labels[pixel];\n  for (channel = 0; channel < n_channels; channel++)\n  {\n    centers[(min_cluster * n_channels) + channel] += data[(pixel * n_channels) + channel];\n  }\n\n  counts[min_cluster] += 1;\n}\n",
        "pragma": "#pragma omp parallel for private(pixel, min_cluster, channel) reduction(+:centers[:n_clusters * n_channels], counts[:n_clusters])"
    },
    "Borroot/heat/src/openmp/major/relax_split/1": {
        "code": "for (int i = 0; i < n; i++)\n{\n  if (fabs(out[i] - in[i]) > eps)\n  {\n    return 0;\n  }\n\n}\n",
        "pragma": ""
    },
    "Botxan/Parallel-K-means-Clustering/parallel/gengroups_p/7": {
        "code": "for (i = 0; i < NGROUPS; i++)\n  for (j = 0; j < (NFEAT / 2); j++)\n{\n  cent[i][j] = (rand() % 10000) / 100.0;\n  cent[i][j + (NFEAT / 2)] = cent[i][j];\n}\n\n",
        "pragma": ""
    },
    "CGHoussem/OpenMP-Sorting/src/utility/10": {
        "code": "for (size_t i = 0; i < nk_size; i++)\n{\n  int n = nk[i][0];\n  int k = nk[i][1];\n  printf(\"\\n%5s | %5s | %8s | %7s | %13s | %13s | %13s\\n\", \"N\", \"K\", \"NxK\", \"Threads\", \"1st Sort\", \"2nd Sort\", \"Total\");\n  for (size_t j = 0; j < nb_threads_size; j++)\n  {\n    int nb_th = nb_threads[j];\n    printf(\"%5d | %5d | %8d | %7d | %13s | %13s | %13s\", n, k, n * k, nb_th, \"CALCULATING..\", \"CALCULATING..\", \"CALCULATING..\");\n    fflush(stdout);\n    performance_measures pm = get_performance_measures(n, k, nb_th);\n    printf(\"\\33[2K\\r%5d | %5d | %8d | %7d | %13f | %13f | %13f\\n\", n, k, n * k, nb_th, pm.first_sort, pm.second_sort, pm.sorting_span);\n    fprintf(fp, \"%d,%d,%d,%d,%f,%f,%f\\n\", n, k, n * k, nb_th, pm.first_sort, pm.second_sort, pm.sorting_span);\n    fflush(fp);\n  }\n\n  printf(\"\\n\");\n}\n",
        "pragma": ""
    },
    "CSalih/Parallel-Programming/Assignment10/real/real/1": {
        "code": "for (int i3 = 1; i3 < (n3 - 1); i3++)\n{\n  for (int i2 = 1; i2 < (n2 - 1); i2++)\n  {\n    double u1[M];\n    double u2[M];\n    for (int i1 = 0; i1 < n1; i1++)\n    {\n      u1[i1] = ((u[i3][i2 - 1][i1] + u[i3][i2 + 1][i1]) + u[i3 - 1][i2][i1]) + u[i3 + 1][i2][i1];\n      u2[i1] = ((u[i3 - 1][i2 - 1][i1] + u[i3 - 1][i2 + 1][i1]) + u[i3 + 1][i2 - 1][i1]) + u[i3 + 1][i2 + 1][i1];\n    }\n\n    for (int i1 = 1; i1 < (n1 - 1); i1++)\n    {\n      r[i3][i2][i1] = ((v[i3][i2][i1] - (a[0] * u[i3][i2][i1])) - (a[2] * ((u2[i1] + u1[i1 - 1]) + u1[i1 + 1]))) - (a[3] * (u2[i1 - 1] + u2[i1 + 1]));\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for collapse(2) num_threads(threads)"
    },
    "CatGlasses77/RACIPE_multithreaded/RACIPELIB/59": {
        "code": "for (i = 0; i < simu_opts->numDE; i++)\n{\n  sprintf(DEIDname, \"%d\", simu_opts->DEID[i]);\n  strcat(fsname[cnt - 1], \"_\");\n  strcat(fsname[cnt - 1], DEIDname);\n}\n",
        "pragma": ""
    },
    "CatGlasses77/RACIPE_multithreaded/RACIPELIB/9": {
        "code": "for (i = 0; i < simu_opts->numDE; i++)\n{\n  sprintf(DEIDname, \"%d\", simu_opts->DEID[i]);\n  strcat(configname, \"_\");\n  strcat(configname, DEIDname);\n}\n",
        "pragma": ""
    },
    "Cathy272272272/Dijkstra/OpenMP/4": {
        "code": "for (i = 0; i < g->nvertices; i++)\n  free(mH->array[i]);\n",
        "pragma": ""
    },
    "CodLiver/Parallel-Programming-v2/gauss2d_2/1": {
        "code": "for (int i = 1; i <= m; i++)\n{\n  t[i][0] = 10.0;\n  t[i][n + 1] = 140.0;\n}\n",
        "pragma": "#pragma omp for schedule(static)"
    },
    "DHjerpe/hybrid-Nbody/Hybrid/main/1": {
        "code": "for (int i = 0; i < (N / 5); i++)\n{\n  assert(particles[i].x_pos == particles_ref[i].x_pos);\n  assert(particles[i].y_pos == particles_ref[i].y_pos);\n  assert(particles[i].mass == particles_ref[i].mass);\n  assert(particles[i].x_vel == particles_ref[i].x_vel);\n  assert(particles[i].y_vel == particles_ref[i].y_vel);\n}\n",
        "pragma": ""
    },
    "Danark/miniomp_github/test/real_codes/hated_plate_local/8": {
        "code": "for (i = 1; i < (700 - 1); i++)\n{\n  for (j = 1; j < (700 - 1); j++)\n  {\n    w[i][j] = (((u[i - 1][j] + u[i + 1][j]) + u[i][j - 1]) + u[i][j + 1]) / 4.0;\n  }\n\n}\n",
        "pragma": "#pragma omp for schedule(runtime)"
    },
    "DaveK2301/C-neural-nets_MLP/NN_functions_OMP/5": {
        "code": "for (int layer = 1; layer < np->num_layers; layer++)\n{\n  old_deltas = np->layer_weight_deltas[layer];\n  double **weights = np->layer_weight_matrices[layer];\n  int ncols = np->num_units_in_layer[layer - 1] + 1;\n  for (int neuron = 0; neuron < np->num_units_in_layer[layer]; neuron++)\n  {\n    double neuron_err = errorMatrix[layer][neuron];\n    double delta0 = np->Eta * neuron_err;\n    weights[neuron][0] += delta0 + (np->alpha * old_deltas[neuron][0]);\n    old_deltas[neuron][0] = delta0;\n    for (int w = 1; w < ncols; w++)\n    {\n      double delta = (np->Eta * neuron_err) * NN[layer - 1][w - 1];\n      weights[neuron][w] += delta + (np->alpha * old_deltas[neuron][w]);\n      old_deltas[neuron][w] = delta;\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp for schedule(static)"
    },
    "Defcon27/Parallel-Computing-in-C-using-OpenMP/cosine_x_estimation/0": {
        "code": "for (i = 1; i <= 15; i++)\n{\n  intm_value = pow(rads, j) / fact(j);\n  sign = 1;\n  if ((i % 2) != 0)\n  {\n    sign = -1;\n  }\n\n  sum += sign * intm_value;\n  j = j + 2;\n}\n",
        "pragma": "#pragma omp parallel for shared(sum)"
    },
    "DiWu9/UnionCS-CSC333-Parallel/csc333-final-project/OMP_Nbody/7": {
        "code": "for (i = 0; i < n_steps; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    for (k = 0; k < 2; k++)\n    {\n      printf(\"%10.6f \", pos[i][j][k]);\n    }\n\n    printf(\"\\n\");\n  }\n\n  printf(\"\\n\");\n}\n",
        "pragma": ""
    },
    "Diwakar98/COL380-A2-Crout-Decomposition-Using-OpenMP-And-MPI/kode/7": {
        "code": "for (j = 0; j < n; j++)\n{\n  for (i = j; i < n; i++)\n  {\n    sum = 0;\n    for (k = 0; k < j; k++)\n    {\n      sum = sum + (L[i][k] * U[k][j]);\n    }\n\n    L[i][j] = A[i][j] - sum;\n  }\n\n  for (i = j; i < n; i++)\n  {\n    sum = 0;\n    for (k = 0; k < j; k++)\n    {\n      sum = sum + (L[j][k] * U[k][i]);\n    }\n\n    if (L[j][j] == 0)\n    {\n      exit(0);\n    }\n\n    U[j][i] = (A[j][i] - sum) / L[j][j];\n  }\n\n}\n",
        "pragma": ""
    },
    "DramaCow/d2q9-bgk/mpi/d2q9-bgk/28": {
        "code": "for (int ii = 1; ii < (params.ny - 1); ++ii)\n{\n  cells[(ii * params.nx) + line].speeds[6] = recvbuf[(ii - 1) * 3];\n  cells[(ii * params.nx) + line].speeds[3] = recvbuf[((ii - 1) * 3) + 1];\n  cells[(ii * params.nx) + line].speeds[7] = recvbuf[((ii - 1) * 3) + 2];\n}\n",
        "pragma": ""
    },
    "DylanHIJ/ParallelProgramming-NTU/workshop/OpenMP/01Knapsack/main/2": {
        "code": "for (int i = 0; i < N; i++)\n  scanf(\"%d%d\", &weights[i], &values[i]);\n",
        "pragma": ""
    },
    "EPCCed/adept-kernel-openmp/cg/11": {
        "code": "for (i = 0; i < s; i++)\n{\n  x[i] = rand() / 32768.0;\n  xf[i] = (float) x[i];\n}\n",
        "pragma": "#pragma omp parallel for schedule(static)"
    },
    "Eduardodsb/Prog_Paralela_e_Distribuida/C\u00f3digos Listas/Lista 3/L3Q7/4": {
        "code": "for (j = 0; j < 50; j++)\n  printf(\"%d - \", d[j]);\n",
        "pragma": ""
    },
    "EhsanAmiryousefi/MasterThesis/Codes/Test/sourcefile2/1": {
        "code": "for (int i = 1; i < 1000; i++)\n{\n  x += i;\n  int num = getNumber();\n}\n",
        "pragma": "#pragma omp parallel for reduction(+:x)"
    },
    "FelipeNishino/openmp-tests/main/1": {
        "code": "for (i = 0; i < n; i++)\n{\n  m |= a[i];\n}\n",
        "pragma": "#pragma omp for"
    },
    "Fishayyy/OpenMP/Tutorial/for_pi/0": {
        "code": "for (int i = 0; i < num_steps; i++)\n{\n  double x = (i + 0.5) * step;\n  sum += 4.0 / (1.0 + (x * x));\n}\n",
        "pragma": "#pragma omp parallel for reduction(+:sum)"
    },
    "Foundations-of-HPC/Foundations_of_HPC_2021/OpenMP/parallel_loops/03_falsesharing_fixed/1": {
        "code": "for (int ii = 1; ii < nthreads; ii++)\n  S[0][0] += S[ii][0];\n",
        "pragma": ""
    },
    "GeoSko/Neural-Network-K-means-and-Ant-Colony-Optimization-implemetations-with-C-and-OpenMP/Neural Network/ex4/ex4/8": {
        "code": "for (int i = 0; i < 100; i++)\n{\n  for (int j = 0; j < (784 + 1); j++)\n  {\n    WL1[i][j] += ((-0.0001) * D1[i]) * inputVector[j];\n  }\n\n}\n",
        "pragma": ""
    },
    "GeorgeMitrakis/raw_image_blur/project_hybrid/5": {
        "code": "for (int i = 0; i < height; i++)\n{\n  array_of_displacements[i] = (i * width) * elem_type_size;\n}\n",
        "pragma": ""
    },
    "GiackAloZ/OPoly/benchmarks/src/omp-gauss-seidel-3d/2": {
        "code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < m; j++)\n  {\n    for (int k = 0; k < l; k++)\n    {\n      scanf(\"%lf\", &phi[i][j][k]);\n    }\n\n  }\n\n}\n",
        "pragma": ""
    },
    "GiannisKalopisis/Parallel-image-filter-convolution/src/Project_Parallhla/1": {
        "code": "for (int i = 0; i < 9; i++)\n{\n  startH[i] = H[i / 3][i % 3];\n}\n",
        "pragma": ""
    },
    "GiosueOrefice/Parallel_computing/prodottoMatxVet/0": {
        "code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < M; j++)\n    y[i] += A[i][j] * x[i];\n\n}\n",
        "pragma": "#pragma omp parallel for collapse(2) private(i,j) reduction(+:y)"
    },
    "Gnafpas/Image_Convolution_mpi_openmp/Test_mpi/main/9": {
        "code": "for (i = 0; i < 8; ++i)\n  if (neighbor[i] != (-1))\n{\n  MPI_Request_free(&request[2 * i]);\n  MPI_Request_free(&request[(2 * i) + 1]);\n  MPI_Request_free(&request[(2 * i) + 16]);\n  MPI_Request_free(&request[(2 * i) + 17]);\n}\n\n",
        "pragma": ""
    },
    "Gregory-Matthews/Parallel-Computer-Programming/OpenMP-PThreads-Cholesky-Decomposition/chol/11": {
        "code": "for (unsigned int i = 0; i < size; i++)\n{\n  if (init == 0)\n    M.elements[i] = 0;\n  else\n    M.elements[i] = ((float) rand()) / ((float) 32767);\n\n}\n",
        "pragma": ""
    },
    "HPCA4SE-UAB/Building-a-dataset-for-classifying-OpenMP-parallelpatterns-via-Machine-Learning/polybench/linear-algebra/kernels/atax/atax/0": {
        "code": "for (i = 0; i < _PB_N; i++)\n  y[i] = 0;\n",
        "pragma": "#pragma omp parallel for private(i)"
    },
    "HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/find_ellipse/32": {
        "code": "for (i = 0; i < Cy->n; i++)\n  m_set_val(Cy, 0, i, m_get_val(Cy, 1, i) - (dt * v_get_val(dCy, i)));\n",
        "pragma": ""
    },
    "HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_particlefilter/ex_particle_OPENMP_seq/20": {
        "code": "for (x = 0; x < diameter; x++)\n{\n  for (y = 0; y < diameter; y++)\n  {\n    if (disk[(x * diameter) + y] == 1)\n      countOnes++;\n\n  }\n\n}\n",
        "pragma": ""
    },
    "HaoLIU94/Parallel-computing/OpenMP/OpenMP&Mthread-dotproduct/2": {
        "code": "for (int i = 0; i < (len * threads); i++)\n{\n  a[i] = 1.0;\n  b[i] = a[i];\n}\n",
        "pragma": ""
    },
    "HardProxy/OpenMP/prog_in/0": {
        "code": "for (j = 1; j < (div - 1); j++)\n{\n  aux[i][j] = (((-ant[i][j]) + ((2.0 * (1.0 - (2.0 * dxts))) * m[i][j])) + (dxts * (((m[i + 1][j] + m[i - 1][j]) + m[i][j + 1]) + m[i][j - 1]))) - (dts * sin((((m[i + 1][j] + m[i - 1][j]) + m[i][j + 1]) + m[i][j - 1]) / 4.0));\n}\n",
        "pragma": "#pragma omp for"
    },
    "Harshs27/openmp/assign2/0": {
        "code": "for (i = 0; i < 10000; i++)\n{\n  if (t == 0)\n  {\n    ptr_x[i].m = get_rand(0, 1);\n    ptr_x[i].n = get_rand(0, 1);\n    ptr_x[i].p = get_rand(0, 1);\n    ptr_ini[i].m = ptr_x[i].m;\n    ptr_ini[i].n = ptr_x[i].n;\n    ptr_ini[i].p = ptr_x[i].p;\n  }\n  else\n  {\n    ptr_x[i].m = ptr_x[i].m + (const1 * get_rand(-1, 1));\n    ptr_x[i].n = ptr_x[i].n + (const1 * get_rand(-1, 1));\n    ptr_x[i].p = ptr_x[i].p + (const1 * get_rand(-1, 1));\n    distance_moved = distance_moved + dist(ptr_x[i], ptr_ini[i]);\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for reduction(+:distance_moved) schedule(runtime) num_threads(NUM_THREADS)"
    },
    "Hibari-K/ParallelProg/laplace/3": {
        "code": "for (i = 0; i < 512; i++)\n{\n  u[i] = uptr + (i * 512);\n  uu[i] = uuptr + (i * 512);\n}\n",
        "pragma": ""
    },
    "HridayK97/parallel-backpropagation/openmp/1": {
        "code": "for (int i = 0; i < 500; i++)\n{\n  forpassl2[i] = 0;\n  int multifir = 0;\n  for (int j = 0; j < 500; j++)\n  {\n    multifir = multifir + (node2weights[i][j] * forpassl1[j]);\n  }\n\n  forpassl2[i] = 1 / (1 + exp(-multifir));\n}\n",
        "pragma": "#pragma omp for schedule(dynamic,5)"
    },
    "Hubble83/hybrid-distance-transform/src/dt/5": {
        "code": "for (i = 0; i < P; i++)\n{\n  for (j = i * blockSize; j < ((i + 1) * blockSize); j++)\n    if (a[j] > max[i])\n    max[i] = a[j];\n\n\n  compress(b + (i * blockSize), a + (i * blockSize), count + i, dictSize + i, blockSize, max[i]);\n  disp[i] = blockSize * i;\n  dataSend[i * 3] = dictSize[i];\n  dataSend[(i * 3) + 1] = count[i];\n  dataSend[(i * 3) + 2] = max[i];\n}\n",
        "pragma": "#pragma omp parallel for private(j) schedule(dynamic)"
    },
    "IT-Dept-Labs/Parallel-Computing/Lab2/assign/1": {
        "code": "for (int i = 0; i < n; i++)\n{\n  scanf(\"%d\", arr + i);\n}\n",
        "pragma": ""
    },
    "IsaacLehman/Game-of-Life/GameOfLife/4": {
        "code": "for (c = 0; c < COLUMNS; c++)\n{\n  setVal(cells, 0, c, 0);\n  setVal(tempCells, 0, c, 0);\n  setVal(cells, ROWS - 1, c, 0);\n  setVal(tempCells, ROWS - 1, c, 0);\n}\n",
        "pragma": ""
    },
    "J-Aguirre/openmp/ch6/omp_nbody_basic/5": {
        "code": "for (part = 0; part < n; part++)\n{\n  printf(\"%3d %10.3e \", part, curr[part].s[0]);\n  printf(\"  %10.3e \", curr[part].s[1]);\n  printf(\"  %10.3e \", curr[part].v[0]);\n  printf(\"  %10.3e\\n\", curr[part].v[1]);\n}\n",
        "pragma": ""
    },
    "J-Magiera/P-M-D/openMP/matrix/1": {
        "code": "for (int row = 0; row < n; row++)\n{\n  for (int col = 0; col < n; col++)\n  {\n    if ((row != p) && (col != q))\n    {\n      temp[i][j++] = mat[row][col];\n      if (j == (n - 1))\n      {\n        j = 0;\n        i++;\n      }\n\n    }\n\n  }\n\n}\n",
        "pragma": ""
    },
    "JacksianYun/openmp_tutorial/011_nowait_data_race_condition/1": {
        "code": "for (i = 1; i < n; i++)\n{\n  z[i] = b[i] * b[i - 1];\n}\n",
        "pragma": "#pragma omp for nowait"
    },
    "JacobMills/Parallel-Pattern-Matching/project_OMP/4": {
        "code": "for (i = 0; i < 20; i++)\n{\n  FILE *f;\n  char fileName[1000];\n  sprintf(fileName, \"%s\\\\text%d.txt\", \"inputs\", i);\n  f = fopen(fileName, \"r\");\n  if (f == 0)\n    return i;\n\n  readFromFile(f, &textData[i], &textLength[i]);\n  fclose(f);\n}\n",
        "pragma": ""
    },
    "JaiJaveria/Parallel_Crout_Decomposition/crout/1": {
        "code": "for (i = j + 1; i < n; i++)\n{\n  sum = 0;\n  for (k = 0; k < j; k++)\n  {\n    sum = sum + (L[i][k] * U[k][j]);\n  }\n\n  L[i][j] = A[i][j] - sum;\n}\n",
        "pragma": "#pragma omp parallel for schedule(static) private(i,k,sum)"
    },
    "JeanOlivier/autocorrelation/autocorrelation/17": {
        "code": "for (int i = 0; i < (k - 1); i++)\n{\n  printf(\"%0.15f, \", f[i]);\n}\n",
        "pragma": ""
    },
    "JerryMouseZ/parallel-matrix-multiplication/omp_matrix/0": {
        "code": "for (int i = 0; i < 4096; ++i)\n{\n  for (int j = 0; j < 4096; ++j)\n  {\n    for (int k = 0; k < 4096; ++k)\n    {\n      c[i][k] += a[i][j] * b[j][k];\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "JimmyWorks/Parallel_Sorting_with_Regular_Sampling_MPI_OpenMP/src/psrs/4": {
        "code": "for (i = 0; i < sample_count; i++)\n{\n  printf(\"%d \", samples[i]);\n}\n",
        "pragma": ""
    },
    "JingruGao09/OpenMP_Performance/histogram_locks/histo_locks/1": {
        "code": "for (j = 0; j < image->col; j++)\n{\n  long idx = image->content[i][j];\n  omp_set_lock(&lck[idx]);\n  histo[idx]++;\n  omp_unset_lock(&lck[idx]);\n}\n",
        "pragma": "#pragma omp parallel for default(shared) private(j)"
    },
    "JoaoCosta94/Ecosystem_Sim_OpenMP/source/functions/4": {
        "code": "for (i = 0; i < R; i++)\n{\n  for (j = 0; j < C; j++)\n  {\n    current_idx = (i * C) + j;\n    if (current_eco[current_idx].type == FOX)\n    {\n      POSITION pos = new_position(gen, current_eco, i, j, R, C, RABBIT);\n      if ((pos.x == i) && (pos.y == j))\n      {\n        pos = new_position(gen, current_eco, i, j, R, C, EMPTY);\n      }\n\n      new_idx = (pos.x * C) + pos.y;\n      if (current_idx != new_idx)\n      {\n        if (current_eco[current_idx].gen_proc >= GEN_PROC_FOXES)\n        {\n          if ((current_eco[current_idx].gen_food + 1) < GEN_FOOD_FOXES)\n          {\n            omp_set_lock(&lock_matrix[current_idx]);\n            new_eco[current_idx].type = FOX;\n            new_eco[current_idx].gen_proc = -1;\n            new_eco[current_idx].gen_food = -1;\n            current_eco[current_idx].gen_proc = -1;\n            omp_unset_lock(&lock_matrix[current_idx]);\n          }\n          else\n          {\n            omp_set_lock(&lock_matrix[new_idx]);\n            if (new_eco[new_idx].temp_type == RABBIT)\n            {\n              omp_set_lock(&lock_matrix[current_idx]);\n              new_eco[current_idx].type = FOX;\n              new_eco[current_idx].gen_proc = -1;\n              new_eco[current_idx].gen_food = -1;\n              current_eco[current_idx].gen_proc = -1;\n              omp_unset_lock(&lock_matrix[current_idx]);\n            }\n\n            omp_unset_lock(&lock_matrix[new_idx]);\n          }\n\n        }\n\n        omp_set_lock(&lock_matrix[new_idx]);\n        if (new_eco[new_idx].type == RABBIT)\n        {\n          new_eco[new_idx] = current_eco[current_idx];\n          new_eco[new_idx].gen_food = -1;\n          new_eco[new_idx].temp_type = RABBIT;\n        }\n        else\n          if ((new_eco[new_idx].type == EMPTY) && ((current_eco[current_idx].gen_food + 1) < GEN_FOOD_FOXES))\n        {\n          new_eco[new_idx] = current_eco[current_idx];\n        }\n        else\n          if (((new_eco[new_idx].type == FOX) && ((current_eco[current_idx].gen_food + 1) < GEN_FOOD_FOXES)) && ((current_eco[current_idx].gen_proc > new_eco[new_idx].gen_proc) || ((current_eco[current_idx].gen_proc == new_eco[new_idx].gen_proc) && (current_eco[current_idx].gen_food < new_eco[new_idx].gen_food))))\n        {\n          new_eco[new_idx] = current_eco[current_idx];\n        }\n\n\n\n        omp_unset_lock(&lock_matrix[new_idx]);\n      }\n      else\n        if ((current_eco[current_idx].gen_food + 1) < GEN_FOOD_FOXES)\n      {\n        omp_set_lock(&lock_matrix[current_idx]);\n        new_eco[current_idx] = current_eco[current_idx];\n        omp_unset_lock(&lock_matrix[current_idx]);\n      }\n\n\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp for private(j) schedule(guided)"
    },
    "JoaquinVillagra/Laboratorio_2_HPC/wave/3": {
        "code": "for (i = 0; i < N; i++)\n{\n  matriz[i] = (float *) malloc((sizeof(float)) * N);\n  for (j = 0; j < N; j++)\n  {\n    matriz[i][j] = 0;\n  }\n\n}\n",
        "pragma": ""
    },
    "JoseCVieira/ParallelSudoku/omp/sudoku-omp/6": {
        "code": "for (i = 0; i < v_size; i++)\n{\n  if (cp_sudoku[i] != (-1))\n  {\n    rm_num_masks(cp_sudoku[i], i / m_size, i % m_size, rows_mask, cols_mask, boxes_mask);\n    cp_sudoku[i] = 0;\n  }\n\n}\n",
        "pragma": ""
    },
    "JoseFilipeFerreira/dotprod/src/main/6": {
        "code": "for (size_t bk = 0; bk < size; bk += c_block_size)\n{\n  for (size_t bj = 0; bj < size; bj += c_block_size)\n  {\n    for (size_t i = 0; i < size; i++)\n    {\n      for (size_t j = bj; j < (bj + c_block_size); j++)\n      {\n        for (size_t k = bk; k < (bk + c_block_size); k++)\n        {\n          c[i][j] += a[i][k] * b[j][k];\n        }\n\n      }\n\n    }\n\n  }\n\n}\n",
        "pragma": ""
    },
    "KaliszAd/OpenACC_OpenMP/newbit_acc/0": {
        "code": "for (int threadid = 0; threadid < cnt; ++threadid)\n{\n  {\n    int index = threadid ^ j;\n    if (index > threadid)\n    {\n      if ((threadid & k) == 0)\n      {\n        if (genArray[threadid] > genArray[index])\n        {\n          int t;\n          t = genArray[threadid];\n          genArray[threadid] = genArray[index];\n          genArray[index] = t;\n        }\n\n      }\n      else\n      {\n        if (genArray[threadid] < genArray[index])\n        {\n          int t;\n          t = genArray[threadid];\n          genArray[threadid] = genArray[index];\n          genArray[index] = t;\n        }\n\n      }\n\n    }\n\n  }\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "KarypisLab/K-Truss/src/kt/22": {
        "code": "for (vi = nvtxs; vi > 0; vi--)\n  xaii[vi].start = xaii[vi - 1].start;\n",
        "pragma": ""
    },
    "KarypisLab/TriangleCounting/ptc/2": {
        "code": "for (vi = nvtxs - 1; vi >= 0; vi--)\n{\n  for (ei = xadj[vi + 1] - 1; adjncy[ei] > vi; ei--)\n    ;\n\n  uxadj[vi] = ei;\n  maxhmsize = gk_max(maxhmsize, (int32_t) (xadj[vi + 1] - uxadj[vi]));\n  startv = (uxadj[vi] != xadj[vi]) ? (vi) : (startv);\n  for (ej = xadj[vi + 1] - 1; ei < ej; ei++, ej--)\n  {\n    vj = adjncy[ei];\n    adjncy[ei] = adjncy[ej];\n    adjncy[ej] = vj;\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for schedule(dynamic,1024) default(none) shared(nvtxs, xadj, adjncy, uxadj) private(vj, ei, ej) reduction(max: maxhmsize) reduction(min: startv)"
    },
    "KasunEdward/OpenMP_Project/OV_Parallel/6": {
        "code": "for (i = 0; i < n; i++)\n{\n  matB[i] = malloc((sizeof(*matB[i])) * n);\n}\n",
        "pragma": ""
    },
    "Kingtous/Bots_Task_Result/fft/src/fft_ompi/2": {
        "code": "for (i = a; i < b; ++i)\n{\n  jp = out + i;\n  for (j = 0; j < r4; j += 4)\n  {\n    jp[0] = ip[0];\n    jp[m] = ip[1];\n    jp[2 * m] = ip[2];\n    jp[3 * m] = ip[3];\n    jp += 4 * m;\n    ip += 4;\n  }\n\n  for (; j < r; ++j)\n  {\n    *jp = *ip;\n    ip++;\n    jp += m;\n  }\n\n}\n",
        "pragma": ""
    },
    "Kingtous/Bots_Task_Result/strassen/src/strassen_ompi/3": {
        "code": "for (Row = 0; Row < QuadrantSize; Row++)\n{\n  for (Column = 0; Column < QuadrantSize; Column++)\n  {\n    *((double *) (((unsigned long) S4) + TempMatrixOffset)) = (*((double *) (((unsigned long) A12) + MatrixOffsetA))) - (*((double *) (((unsigned long) S2) + TempMatrixOffset)) = (*((double *) (((unsigned long) S1) + TempMatrixOffset)) = (*((double *) (((unsigned long) A21) + MatrixOffsetA))) + (*((double *) (((unsigned long) A22) + MatrixOffsetA)))) - (*((double *) (((unsigned long) A) + MatrixOffsetA))));\n    *((double *) (((unsigned long) S8) + TempMatrixOffset)) = (*((double *) (((unsigned long) S6) + TempMatrixOffset)) = (*((double *) (((unsigned long) B22) + MatrixOffsetB))) - (*((double *) (((unsigned long) S5) + TempMatrixOffset)) = (*((double *) (((unsigned long) B12) + MatrixOffsetB))) - (*((double *) (((unsigned long) B) + MatrixOffsetB))))) - (*((double *) (((unsigned long) B21) + MatrixOffsetB)));\n    *((double *) (((unsigned long) S3) + TempMatrixOffset)) = (*((double *) (((unsigned long) A) + MatrixOffsetA))) - (*((double *) (((unsigned long) A21) + MatrixOffsetA)));\n    *((double *) (((unsigned long) S7) + TempMatrixOffset)) = (*((double *) (((unsigned long) B22) + MatrixOffsetB))) - (*((double *) (((unsigned long) B12) + MatrixOffsetB)));\n    TempMatrixOffset += sizeof(double);\n    MatrixOffsetA += sizeof(double);\n    MatrixOffsetB += sizeof(double);\n  }\n\n  MatrixOffsetA += RowIncrementA;\n  MatrixOffsetB += RowIncrementB;\n}\n",
        "pragma": ""
    },
    "KinseyMcG/Parallel-Matrix/matrix/9": {
        "code": "for (int i = 0; i < size; i++)\n{\n  printf(\"| \");\n  for (int j = 0; j < size; j++)\n  {\n    printf(\"%0.2f \", arr[(size * i) + j]);\n  }\n\n  printf(\"|\\n\");\n}\n",
        "pragma": ""
    },
    "KlausDornsbach/OpenMP/atividade_7/exercicio_1/main/0": {
        "code": "for (int i = 0; i < size; i += n_threads)\n{\n  c[i] = (sqrt(i * 32) + sqrt((i * 16) + (i * 8))) + sqrt(((i * 4) + (i * 2)) + i);\n  c[i] -= sqrt((((((i * 32) * i) * 16) + (i * 4)) + (i * 2)) + i);\n  c[i] += pow(i * 32, 8) + pow(i * 16, 12);\n}\n",
        "pragma": "#pragma omp for"
    },
    "LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/CG/cg/16": {
        "code": "for (j = 1; j <= n; j += 1)\n{\n  rowstr[j] = 0;\n  mark[j] = 0;\n}\n",
        "pragma": "#pragma omp parallel for private (j)"
    },
    "LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/FT/ft/29": {
        "code": "for (i = 1; i <= nt; i += 1)\n{\n  err = (sums[i].real - vdata_real_s[i]) / vdata_real_s[i];\n  if (fabs(err) > epsilon)\n  {\n    *verified = 0;\n    break;\n  }\n\n  err = (sums[i].imag - vdata_imag_s[i]) / vdata_imag_s[i];\n  if (fabs(err) > epsilon)\n  {\n    *verified = 0;\n    break;\n  }\n\n}\n",
        "pragma": ""
    },
    "LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/150": {
        "code": "for (j = 1; j <= (grid_points[1] - 2); j += 1)\n{\n  rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * ((u[m][i][j][k - 2] - (4.0 * u[m][i][j][k - 1])) + (5.0 * u[m][i][j][k])));\n}\n",
        "pragma": "#pragma omp parallel for private (j) firstprivate (dssp,k)"
    },
    "LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/50": {
        "code": "for (i = 1; i <= (grid_points[0] - 2); i += 1)\n{\n  lhs[0][i][j][k] = 0.0;\n  lhs[1][i][j][k] = ((-dttx2) * cv[i - 1]) - (dttx1 * rhon[i - 1]);\n  lhs[2][i][j][k] = 1.0 + (c2dttx1 * rhon[i]);\n  lhs[3][i][j][k] = (dttx2 * cv[i + 1]) - (dttx1 * rhon[i + 1]);\n  lhs[4][i][j][k] = 0.0;\n}\n",
        "pragma": "#pragma omp parallel for private (i) firstprivate (dttx1,dttx2,c2dttx1)"
    },
    "LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB003-antidep2-orig-yes/1": {
        "code": "for (j = 0; j < len; j++)\n{\n  a[i][j] = 0.5;\n}\n",
        "pragma": "#pragma omp parallel for private(j)"
    },
    "LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB060-matrixmultiply-orig-no/4": {
        "code": "for (j = 0; j < 100; j++)\n{\n  c[i][j] = c[i][j] + (a[i][k] * b[k][j]);\n}\n",
        "pragma": "#pragma omp parallel for private(j)"
    },
    "LLNL/AutoParBench/benchmarks/ICC_Cost/NPB3.0-omp-c/SP/sp/23": {
        "code": "for (m = 3; m < 5; m++)\n{\n  n = ((m - 3) + 1) * 5;\n  for (i = 0; i <= (grid_points[0] - 3); i++)\n  {\n    i1 = i + 1;\n    i2 = i + 2;\n    for (j = 1; j <= (grid_points[1] - 2); j++)\n    {\n      for (k = 1; k <= (grid_points[2] - 2); k++)\n      {\n        fac1 = 1. / lhs[n + 2][i][j][k];\n        lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n        lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n        rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n        lhs[n + 2][i1][j][k] = lhs[n + 2][i1][j][k] - (lhs[n + 1][i1][j][k] * lhs[n + 3][i][j][k]);\n        lhs[n + 3][i1][j][k] = lhs[n + 3][i1][j][k] - (lhs[n + 1][i1][j][k] * lhs[n + 4][i][j][k]);\n        rhs[m][i1][j][k] = rhs[m][i1][j][k] - (lhs[n + 1][i1][j][k] * rhs[m][i][j][k]);\n        lhs[n + 1][i2][j][k] = lhs[n + 1][i2][j][k] - (lhs[n + 0][i2][j][k] * lhs[n + 3][i][j][k]);\n        lhs[n + 2][i2][j][k] = lhs[n + 2][i2][j][k] - (lhs[n + 0][i2][j][k] * lhs[n + 4][i][j][k]);\n        rhs[m][i2][j][k] = rhs[m][i2][j][k] - (lhs[n + 0][i2][j][k] * rhs[m][i][j][k]);\n      }\n\n    }\n\n  }\n\n  i = grid_points[0] - 2;\n  i1 = grid_points[0] - 1;\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      fac1 = 1. / lhs[n + 2][i][j][k];\n      lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n      lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n      rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n      lhs[n + 2][i1][j][k] = lhs[n + 2][i1][j][k] - (lhs[n + 1][i1][j][k] * lhs[n + 3][i][j][k]);\n      lhs[n + 3][i1][j][k] = lhs[n + 3][i1][j][k] - (lhs[n + 1][i1][j][k] * lhs[n + 4][i][j][k]);\n      rhs[m][i1][j][k] = rhs[m][i1][j][k] - (lhs[n + 1][i1][j][k] * rhs[m][i][j][k]);\n      fac2 = 1. / lhs[n + 2][i1][j][k];\n      rhs[m][i1][j][k] = fac2 * rhs[m][i1][j][k];\n    }\n\n  }\n\n}\n",
        "pragma": ""
    },
    "LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/34": {
        "code": "for (k = 1 * 3; k <= ((grid_points[2] - (3 * 1)) - 1); k++)\n{\n  forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * ((((ue[k - 2][m] - (4.0 * ue[k - 1][m])) + (6.0 * ue[k][m])) - (4.0 * ue[k + 1][m])) + ue[k + 2][m]));\n}\n",
        "pragma": "#pragma omp parallel for firstprivate(k ,dssp ,m ,j ,i )"
    },
    "LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/194": {
        "code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 0; k <= (grid_points[2] - 3); k++)\n  {\n    k1 = k + 1;\n    k2 = k + 2;\n    fac1 = 1. / lhs[n + 2][i][j][k];\n    lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n    lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n    rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n    lhs[n + 2][i][j][k1] = lhs[n + 2][i][j][k1] - (lhs[n + 1][i][j][k1] * lhs[n + 3][i][j][k]);\n    lhs[n + 3][i][j][k1] = lhs[n + 3][i][j][k1] - (lhs[n + 1][i][j][k1] * lhs[n + 4][i][j][k]);\n    rhs[m][i][j][k1] = rhs[m][i][j][k1] - (lhs[n + 1][i][j][k1] * rhs[m][i][j][k]);\n    lhs[n + 1][i][j][k2] = lhs[n + 1][i][j][k2] - (lhs[n + 0][i][j][k2] * lhs[n + 3][i][j][k]);\n    lhs[n + 2][i][j][k2] = lhs[n + 2][i][j][k2] - (lhs[n + 0][i][j][k2] * lhs[n + 4][i][j][k]);\n    rhs[m][i][j][k2] = rhs[m][i][j][k2] - (lhs[n + 0][i][j][k2] * rhs[m][i][j][k]);\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for firstprivate(i ,j ,k ,fac1 ,k1 ,m ,n )"
    },
    "LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/44": {
        "code": "for (m = 0; m < 5; m++)\n{\n  u[m][i][j][k] = temp[m];\n}\n",
        "pragma": "#pragma omp parallel for firstprivate(m ,k ,j )"
    },
    "LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/15": {
        "code": "for (c2 = (((nj > nk) ? (nj) : (nk)) > nm) ? ((nj > nk) ? (nj) : (nk)) : (nm); c2 <= (nl + (-1)); c2++)\n{\n  D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n}\n",
        "pragma": "#pragma omp parallel for private(c2 )"
    },
    "LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/65": {
        "code": "for (c2 = (nl > nm) ? (nl) : (nm); c2 <= (nj + (-1)); c2++)\n{\n  B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n}\n",
        "pragma": "#pragma omp parallel for private(c2 )"
    },
    "LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB044-adi-tile-no/6": {
        "code": "for (c15 = 16 * c2; c15 <= ((((16 * c2) + 15) < (n + (-1))) ? ((16 * c2) + 15) : (n + (-1))); c15++)\n{\n  X[c15][n - 1] = X[c15][n - 1] / B[c15][n - 1];\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB070-simd1-orig-no/0": {
        "code": "for (i = 0; i < 100; i++)\n  a[i] = b[i] * c[i];\n",
        "pragma": "#pragma omp parallel for private(i )"
    },
    "LLNL/PF3DK/util/3": {
        "code": "for (kk = 0; kk < numz; kk++)\n{\n  rampval = tmp_ramp[kk];\n  for (jj = 0; jj < numy; jj++)\n  {\n    for (ii = 0; ii < numx; ii++)\n    {\n      ndx = (ii + (numx * jj)) + ((numx * numy) * kk);\n      var[ndx] = (1.0 + (ampl * (1.0 - (2.0 * le_random(0))))) * rampval;\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp for private(ii)"
    },
    "LLNL/dataracebench/micro-benchmarks/DRB159-nobarrier-orig-gpu-no/2": {
        "code": "for (int i = 0; i < 8; i++)\n{\n  b[i] = 0;\n  c[i] = 2;\n  temp[i] = 0;\n}\n",
        "pragma": ""
    },
    "LefterisKarampas/Image_Convolution/src/main/13": {
        "code": "for (int k = 0; k < num_elements; k++)\n{\n  Final[rows_per_block - 1][(cols_per_block - 1) * num_elements] = ((unsigned char) ceil(((((((((h[0][0] * Table[rows_per_block - 2][((cols_per_block - 2) * num_elements) + k]) + (h[0][1] * Table[rows_per_block - 2][((cols_per_block - 1) * num_elements) + k])) + (h[0][2] * halo_p->East[k - num_elements])) + (Table[rows_per_block - 1][((cols_per_block - 2) * num_elements) + k] * h[1][0])) + (h[1][1] * Table[rows_per_block - 1][((cols_per_block - 1) * num_elements) + k])) + (h[1][2] * halo_p->East[((cols_per_block - 1) * num_elements) + k])) + (h[2][0] * Table[1][((cols_per_block - 2) * num_elements) + k])) + (h[2][1] * Table[1][((cols_per_block - 1) * num_elements) + k])) + (h[2][2] * halo_p->South_East[k]))) % 256;\n  if (!(Final[0][0] == Table[0][0]))\n    changes++;\n\n}\n",
        "pragma": ""
    },
    "Leonardo-Cortez/OpenMP/BusquedaCRCW/0": {
        "code": "for (i = 1; i <= n; i++)\n{\n  win[i] = 0;\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "LexaHoods/OPENMP/ex6/3": {
        "code": "for (k = 1; k < taille; k++)\n{\n  result -= tab[k];\n}\n",
        "pragma": "#pragma omp parallel for reduction(-:result)"
    },
    "Lut99/NeuralNetwork/src/lib/NeuralNetwork/NeuralNetwork_OMP_CPU7/5": {
        "code": "for (size_t l = 0; l < n_weights; l++)\n{\n  delta_biases[l] = malloc((sizeof(double)) * nodes_per_layer[l + 1]);\n  delta_weights[l] = malloc(((sizeof(double)) * nodes_per_layer[l]) * nodes_per_layer[l + 1]);\n  for (size_t n = 0; n < nodes_per_layer[l + 1]; n++)\n  {\n    delta_biases[l][n] = 0;\n    for (size_t prev_n = 0; prev_n < nodes_per_layer[l]; prev_n++)\n    {\n      delta_weights[l][(prev_n * nodes_per_layer[l + 1]) + n] = 0;\n    }\n\n  }\n\n}\n",
        "pragma": ""
    },
    "MAInformatico/Arquitectura-de-Computadores/practica2/private-clause/0": {
        "code": "for (i = 0; i < n; i++)\n{\n  suma = suma + a[i];\n  printf(\"thread %d suma a[%d]/ \", omp_get_thread_num(), i);\n}\n",
        "pragma": "#pragma omp for"
    },
    "MCAPro2015/OpenMP_MCA_Project/libopenmp-OpenUH/mca_benchmarks/fft/fourierf/2": {
        "code": "for (i = 0; i < NumSamples; i++)\n{\n  RealOut[i] /= denom;\n  ImagOut[i] /= denom;\n}\n",
        "pragma": ""
    },
    "MahmoudAshraf97/OpenMP-KMeans-Clustering/Q1/2": {
        "code": "for (int c = 0; c < 1000; c++)\n  if (result[c] < result[location])\n  location = c;\n\n",
        "pragma": ""
    },
    "ManuelBerrueta/cpts411_PageRankEstimator/pagerankestimator/1": {
        "code": "for (i = 0; i < (nSize + 1); i++)\n{\n  myGraph[i].pagerank = 0;\n  for (j = 0; j < 3600; j++)\n  {\n    myGraph[i].hyperlinks[j] = -1;\n  }\n\n}\n",
        "pragma": ""
    },
    "ManuelCMS/HW-2.1/parallel_color_to_gray/0": {
        "code": "for (int i = 0; i < 262145; i++)\n{\n  b = fgetc(image);\n  g = fgetc(image);\n  r = fgetc(image);\n  unsigned char pixel = ((0.21 * r) + (0.72 * g)) + (0.07 * b);\n  fputc(pixel, outputImage);\n  fputc(pixel, outputImage);\n  fputc(pixel, outputImage);\n}\n",
        "pragma": "#pragma omp for schedule(guided)"
    },
    "MarceloMilbradt/Analizador-genoma-paralelo/dna/3": {
        "code": "for (i = 0; i < 24; i++)\n{\n  quant[i] = 0;\n  qnt[i] = 0;\n}\n",
        "pragma": ""
    },
    "MarthaCarrillo/OpenMP/openmp/parallelfor_00/0": {
        "code": "for (i = 0; i < n; i++)\n  result = result + (a[i] * b[i]);\n",
        "pragma": "#pragma omp parallel for default(shared) private(i) schedule(static, chunk) reduction(+:result)"
    },
    "MarwanaMostafa/Parallel-Processing_K-means-Clustering_OpenMp/K-means Clustering/1": {
        "code": "for (i = 0; i < numOfClusters; i++)\n{\n  arrayOfClustersCentroid[i].x /= NumOfElements[i];\n  arrayOfClustersCentroid[i].y /= NumOfElements[i];\n}\n",
        "pragma": "#pragma omp for schedule(static)"
    },
    "Masa-731/OpenMP-vs-OpenACC/vectoradd/openmp-cpu/0": {
        "code": "for (int idx = 0; idx < N; idx++)\n{\n  C[idx] = A[idx] + B[idx];\n}\n",
        "pragma": "#pragma omp parallel for simd"
    },
    "Mayraju/openmp/loopd/0": {
        "code": "for (n = 0; n <= N; ++n)\n{\n  dependency_opt[n] = Sn;\n  Sn *= up;\n}\n",
        "pragma": "#pragma omp parallel for private(n)"
    },
    "MehdiHALA/Mpi-x-project/src/stencil_omp/4": {
        "code": "for (y = y0; y <= y1; y++)\n{\n  for (x = x0; x <= x1; x++)\n  {\n    printf(\"%8.5g \", values[b][x][y]);\n  }\n\n  printf(\"\\n\");\n}\n",
        "pragma": ""
    },
    "MerendaFrancoN/OpenMP-Learning/Ejercicio-5/ejercicio5/1": {
        "code": "for (int i = 0; i < 11; i++)\n  printf(\"%d \", RESULT[i]);\n",
        "pragma": ""
    },
    "Minyoung-Kim1110/OpenMP/Excercise/atomic/0": {
        "code": "for (int i = 0; i < 1000; i++)\n  sum += i;\n",
        "pragma": "#pragma omp parallel for"
    },
    "Mithradatha/parallel-pagerank/dense_omp/4": {
        "code": "for (arrx = 0; arrx < size; arrx++)\n{\n  if (arr[arrx] > max)\n  {\n    maxx = arrx;\n    max = arr[maxx];\n  }\n\n}\n",
        "pragma": ""
    },
    "Mohamed-Adel2/Parallel-processing-Histogram-MPI-OpenMP/main/5": {
        "code": "for (i = number_of_data; i < (Data_per_process * p); i++)\n  Data[i] = -214748364;\n",
        "pragma": ""
    },
    "NJU-TJL/OpenMP-MPI_Labs/Lab01/OpenMP/MatrixMtp_OpenMP/3": {
        "code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    sum += C[i][j];\n  }\n\n}\n",
        "pragma": ""
    },
    "NYU-HPC19/lecture4/03-omp-nbody/1": {
        "code": "for (long i = 0; i < N; i++)\n{\n  x[i] = drand48();\n  y[i] = drand48();\n  z[i] = drand48();\n  f[i] = drand48();\n  u[i] = 0;\n}\n",
        "pragma": ""
    },
    "Nelorth/nbody/src/nbody/parallel/0": {
        "code": "for (int p = 0; p < np; p++)\n{\n  portionize(nBodies, np, p, &counts[p], &displs[p]);\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "NelsonNew/SPP-Project-OpenMP/Aufgabe 6/matrix-mult/5": {
        "code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    result[i][j] = 0;\n    for (k = 0; k < p; k++)\n    {\n      result[i][j] += first[i][k] * second[k][j];\n    }\n\n  }\n\n}\n",
        "pragma": ""
    },
    "Nersle/parallelProgramingProject/gauss/gaussOpenMP/2": {
        "code": "for (i = 1; i <= n; i++)\n{\n  fscanf(finput, \"%f \", &bi);\n  bb[i] = (double) bi;\n}\n",
        "pragma": ""
    },
    "NickLekkas01/img-convolution/src/imgconv/2": {
        "code": "for (int i = 1; i <= rows_per_proc; i++)\n{\n  MPI_File_seek(fh, ((bytes * ((start_row + i) - 1)) * width) + (bytes * start_col), MPI_SEEK_SET);\n  MPI_File_write(fh, &t1[((bytes * (cols_per_proc + 2)) * i) + bytes], bytes * cols_per_proc, (MPI_Datatype) 0x4c00010d, &status);\n}\n",
        "pragma": ""
    },
    "OlegShatin/openmp-homework/7/main/1": {
        "code": "for (int i = 0; i < length; i++)\n{\n  c[i] = a[i] + b[i];\n  printf(\"working %d of %d threads\\n\", omp_get_thread_num(), omp_get_num_threads());\n}\n",
        "pragma": "#pragma omp parallel for schedule(dynamic, 2) num_threads(4)"
    },
    "PDX-Math-HSAP/openmp_intro/example codes/impls/4": {
        "code": "for (int run = 0; run < nruns; ++run)\n{\n  for (int i = 0; i < N; ++i)\n    a[i] = cos(((i + (2.0 * run)) * 1.0) / 200);\n\n  for (int i = 0; i < N; ++i)\n    b[i] = cos(((i + (3.0 * run)) * 1.0) / 200);\n\n  sec = implementation8(a, b, N);\n  delta = sec - average_time;\n  average_time += delta / (run + 1);\n  standard_deviation += delta * (sec - average_time);\n}\n",
        "pragma": ""
    },
    "ParRes/Kernels/OPENMP/PIC/pic/5": {
        "code": "for (*n_placed = 0, x = 0; x < L; x++)\n{\n  for (y = 0; y < L; y++)\n  {\n    *n_placed += random_draw((((2.0 * cos(x * step)) * cos(x * step)) * n_input) / (L * L), parm);\n  }\n\n}\n",
        "pragma": ""
    },
    "ParallelProgTeam/Aula-3-OpenMP/OMP_Exercises/solutions/pi_mc_par_array/0": {
        "code": "for (i = 0; i < num_trials; i++)\n{\n  double x;\n  double y;\n  double test;\n  x = random();\n  y = random();\n  test = (x * x) + (y * y);\n  if (test <= (r * r))\n    Ncirc++;\n\n}\n",
        "pragma": "#pragma omp parallel for reduction(+:Ncirc)"
    },
    "Paritosh97/openmp-demo/sorting_algorithms/mergesort/11": {
        "code": "for (exp = 0; exp < NBEXPERIMENTS; exp++)\n{\n  init_array_sequence(X, N);\n  start = _rdtsc();\n  sequential_merge_sort(X, N);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n  if (!is_sorted(X, N))\n  {\n    fprintf(stderr, \"ERROR: the sequential sorting of the array failed\\n\");\n    print_array(X, N);\n    exit(-1);\n  }\n\n}\n",
        "pragma": ""
    },
    "Pastorsin/sistemas-paralelos/entregas/e3/entrega-3/mpi-hibrido/2": {
        "code": "for (i = 0; i < stripSize; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    D[(i * N) + j] *= d;\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for private(i,j)"
    },
    "PawseySC/sc20-gpu-offloading/4_data/openmp/laplace_mp/4": {
        "code": "for (j = 0; j <= (2048 + 1); j++)\n{\n  T[0][j] = 0.0;\n  T[2048 + 1][j] = (128.0 / 2048) * j;\n}\n",
        "pragma": ""
    },
    "PelaezLink/OpenMP_MPI/prac1/imagenesv3/0": {
        "code": "for (k = (0 > (i - radio)) ? (0) : (i - radio); k <= (((n - 1) < (i + radio)) ? (n - 1) : (i + radio)); k++)\n{\n  for (l = (0 > (j - radio)) ? (0) : (j - radio); l <= (((m - 1) < (j + radio)) ? (m - 1) : (j + radio)); l++)\n  {\n    v = ppdBloque[(k - i) + radio][(l - j) + radio];\n    r += ppsImagenOrg[k][l].r * v;\n    g += ppsImagenOrg[k][l].g * v;\n    b += ppsImagenOrg[k][l].b * v;\n    tot += v;\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for private(v, l) reduction(+:r, g, b, tot)"
    },
    "Perl-OpenMP/p5-OpenMP-Environment/benchmarks/NPB3.4.1/NPB3.4-OMP/IS/is/22": {
        "code": "for (i = 0; i < 5; i++)\n{\n  k = partial_verify_vals[i];\n  if ((0 < k) && (k <= ((1 << 16) - 1)))\n  {\n    INT_TYPE key_rank = key_buff_ptr[k - 1];\n    INT_TYPE test_rank = test_rank_array[i];\n    int failed = 0;\n    switch (CLASS)\n    {\n      case 'S':\n        if (i <= 2)\n        test_rank += iteration;\n      else\n        test_rank -= iteration;\n\n        break;\n\n      case 'W':\n        if (i < 2)\n        test_rank += iteration - 2;\n      else\n        test_rank -= iteration;\n\n        break;\n\n      case 'A':\n        if (i <= 2)\n        test_rank += iteration - 1;\n      else\n        test_rank -= iteration - 1;\n\n        break;\n\n      case 'B':\n        if (((i == 1) || (i == 2)) || (i == 4))\n        test_rank += iteration;\n      else\n        test_rank -= iteration;\n\n        break;\n\n      case 'C':\n        if (i <= 2)\n        test_rank += iteration;\n      else\n        test_rank -= iteration;\n\n        break;\n\n      case 'D':\n        if (i < 2)\n        test_rank += iteration;\n      else\n        test_rank -= iteration;\n\n        break;\n\n      case 'E':\n        if (i < 2)\n        test_rank += iteration - 2;\n      else\n        if (i == 2)\n      {\n        test_rank += iteration - 2;\n        if (iteration > 4)\n          test_rank -= 2;\n        else\n          if (iteration > 2)\n          test_rank -= 1;\n\n\n      }\n      else\n        test_rank -= iteration - 2;\n\n\n        break;\n\n    }\n\n    if (key_rank != test_rank)\n      failed = 1;\n    else\n      passed_verification++;\n\n    if (failed == 1)\n      printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, (int) i);\n\n  }\n\n}\n",
        "pragma": ""
    },
    "PhuNH/parprog/assignment6/student/loop_fusion_par/0": {
        "code": "for (int i = 0; i < N; i++)\n{\n  a[i][0] = 2 * c[i][0];\n  for (int j = 1; j < N; j++)\n  {\n    a[i][j] = 2 * c[i][j];\n    d[i][j - 1] = (a[i][j] * b[i][j]) + c[i][j - 1];\n  }\n\n  d[i][N - 1] = a[i][N - 1] * b[i][N - 1];\n}\n",
        "pragma": "#pragma omp parallel for num_threads(num_threads)"
    },
    "ROCm-Developer-Tools/aomp/test/smoke-fails/no-loop-8/no_loop_8/1": {
        "code": "for (j = 1; j < N; j = j + 3)\n  a[j] = b[j];\n",
        "pragma": ""
    },
    "ROCm-Developer-Tools/aomp/test/smoke/fprintf/fprintf/0": {
        "code": "for (int i = 0; i < N; i++)\n{\n  fprintf(fileptr, \"fprintf: updating a[%d] addr:%p  file ptr:%p\\n\", i, &a[i], fileptr);\n  a[i] = i;\n}\n",
        "pragma": "#pragma omp target teams distribute parallel for map(tofrom: a[0:N]) is_device_ptr(fileptr)"
    },
    "ROCm-Developer-Tools/aomp/test/smoke/schedule/schedule/2": {
        "code": "for (int j = 0; j < size; j++)\n{\n  for (int jj = j + 1; jj < size; jj++)\n  {\n    if (output[j] > output[jj])\n    {\n      printf(\"Fail to schedule in order.\\n\");\n      free(output);\n      return 1;\n    }\n\n  }\n\n}\n",
        "pragma": ""
    },
    "Ric0rdanza/HPC_Openmp_GEMV/hpc-mpi/5": {
        "code": "for (int i = 0; i < 4; i++)\n{\n  printf(\"%.2f, \", vector[i]);\n}\n",
        "pragma": ""
    },
    "RizkyAnggita/openmp/loops/15": {
        "code": "for (int i = 0; i < num_targets; i++)\n  printf(\"Range Konvo:%d\\n \", arrRangeKonvo[i]);\n",
        "pragma": ""
    },
    "Romen-Adama-Dev/High-Performance-Computing-Lab7/lab7-critical-matrix/2": {
        "code": "for (i = 0; i < 1000; i++)\n  for (j = 0; j < 1000; j++)\n{\n  A[i][j] = ((rand() % 1001) / 1000.) * 100;\n  B[i][j] = ((rand() % 1001) / 1000.) * 100;\n}\n\n",
        "pragma": ""
    },
    "SOLLVE/sollve_vv/tests/4.5/target_teams_distribute_parallel_for/test_target_teams_distribute_parallel_for_if_no_modifier/6": {
        "code": "for (i = 0; i < 1024; i++)\n{\n  OMPVV_TEST_AND_SET(errors, a[i] != (1 + (100 - 70)));\n  if (warning[i] != 0)\n  {\n    raiseWarning = 1;\n  }\n\n}\n",
        "pragma": ""
    },
    "SOLLVE/sollve_vv/tests/5.0/loop/test_loop_reduction_add/3": {
        "code": "for (int x = 0; x < 1024; ++x)\n{\n  expect_total += a[x] + b[x];\n}\n",
        "pragma": ""
    },
    "SOLLVE/sollve_vv/tests/5.0/target_teams_distribute_parallel_for/test_target_teams_distribute_parallel_for_collapse/1": {
        "code": "for (i = 0; i < 10; i++)\n{\n  for (j = 0; j < 12; j++)\n  {\n    for (k = 0; k < 10; k++)\n    {\n      for (l = 0; l < 12; l++)\n      {\n        a[i][j][k][l] = 1;\n      }\n\n    }\n\n  }\n\n}\n",
        "pragma": ""
    },
    "SchawnnDev/MNT/src/main/2": {
        "code": "for (size_t i = 0; i < size; i++)\n  rowsPerProc[i] = m->nrows / size;\n",
        "pragma": ""
    },
    "SgtSwagrid/supercomputing/02 - Conway+RDF/rdf/0": {
        "code": "for (i = 0; i < fluid.count; i++)\n{\n  for (j = i + 1; j < fluid.count; j++)\n  {\n    dist = distance(fluid.molecules[i], fluid.molecules[j], fluid.width);\n    if (dist < (fluid.width / 2.0F))\n    {\n      bin = (int) ((res * dist) / (fluid.width / 2.0F));\n      p_bins[bin] += 2.0F;\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp for schedule(dynamic, CHUNKSIZE)"
    },
    "ShadenSmith/splatt/src/ftensor/3": {
        "code": "for (idx_t n = 1; n < nnz; ++n)\n{\n  int newfib = 0;\n  for (idx_t m = 0; m < (nmodes - 1); ++m)\n  {\n    if (ttinds[m][n] != ttinds[m][n - 1])\n    {\n      newfib = 1;\n      break;\n    }\n\n  }\n\n  if (newfib)\n  {\n    ft->fptr[fib] = n;\n    ft->fids[fib] = ttinds[1][n];\n    if (ft->tiled != SPLATT_NOTILE)\n    {\n      ft->sids[fib] = ttinds[0][n];\n    }\n\n    ++fib;\n  }\n\n}\n",
        "pragma": ""
    },
    "ShadenSmith/splatt/src/matrix/18": {
        "code": "for (idx_t mode = 0; mode < nmults; ++mode)\n{\n  const idx_t m = (start + mode) % nmats;\n  const idx_t I = mats[m]->I;\n  const val_t * const Av = mats[m]->vals;\n  memset(bufv, 0, (F * F) * (sizeof(val_t)));\n  for (idx_t i = 0; i < I; ++i)\n  {\n    for (idx_t mi = 0; mi < F; ++mi)\n    {\n      for (idx_t mj = mi; mj < F; ++mj)\n      {\n        bufv[mj + (mi * F)] += Av[mi + (i * F)] * Av[mj + (i * F)];\n      }\n\n    }\n\n  }\n\n  for (idx_t mi = 0; mi < F; ++mi)\n  {\n    for (idx_t mj = mi; mj < F; ++mj)\n    {\n      rv[mj + (mi * F)] *= bufv[mj + (mi * F)];\n    }\n\n  }\n\n}\n",
        "pragma": ""
    },
    "Shaunak04/PDC-Parallel-Encryption-Algorithms/rsa/utils/4": {
        "code": "for (int i = 63; i >= 0; i--)\n{\n  if (n & (1ULL << i))\n    printf(\"1\");\n  else\n    printf(\"0\");\n\n  if ((i % 4) == 0)\n    printf(\" \");\n\n  if ((i % 8) == 0)\n    printf(\"| \");\n\n}\n",
        "pragma": ""
    },
    "SkySpecial/OpenMP-studying/sum/0": {
        "code": "for (i = 1; i <= num_of_iter; i++)\n  result += 1.0 / i;\n",
        "pragma": "#pragma omp parallel for"
    },
    "SumedhArani/Parallel-Computing/matmul/basic/1": {
        "code": "for (k = 0; k < M; ++k)\n{\n  cij += A[(k * M) + i] * B[(j * M) + k];\n}\n",
        "pragma": "#pragma omp parallel for shared(cij)"
    },
    "TheTwoOfUs/video-canny-edge-detection/mpi-omp/mpi-omp/8": {
        "code": "for (i = 1; i < (num_workers - 1); i++)\n{\n  MPI_Send(size_buffer, 2, (MPI_Datatype) 0x4c000405, i, 43, (MPI_Comm) 0x44000000);\n  memcpy(buffer, frame->data + (i * chunk_start), chunk_size);\n  MPI_Send(buffer, chunk_size, (MPI_Datatype) 0x4c000102, i, 42, (MPI_Comm) 0x44000000);\n}\n",
        "pragma": ""
    },
    "TuitaTeam/Knapsack-OpenMP/knapsackDYN_omp/0": {
        "code": "for (w = 0; w <= W; w++)\n{\n  if ((i == 0) || (w == 0))\n    K[w] = 0;\n  else\n    if (wt[i - 1] <= w)\n    K[w] = max(val[i - 1] + Kp[w - wt[i - 1]], Kp[w]);\n  else\n    K[w] = Kp[w];\n\n\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic2/mbpush2/19": {
        "code": "for (i = nyi - 1; i < nyt; i++)\n{\n  joff = (3 * nxhd) * i;\n  kmr = nxy / nx;\n  for (j = 1; j < nxhh; j++)\n  {\n    t3 = cimagf(sct[kmr * j]) + (crealf(sct[kmr * j]) * _Complex_I);\n    for (jj = 0; jj < 3; jj++)\n    {\n      t2 = conjf(f[(jj + (3 * (nxh - j))) + joff]);\n      t1 = f[(jj + (3 * j)) + joff] + t2;\n      t2 = (f[(jj + (3 * j)) + joff] - t2) * t3;\n      f[(jj + (3 * j)) + joff] = t1 + t2;\n      f[(jj + (3 * (nxh - j))) + joff] = conjf(t1 - t2);\n    }\n\n  }\n\n  for (jj = 0; jj < 3; jj++)\n  {\n    f[(jj + (3 * nxhh)) + joff] = 2.0 * conjf(f[(jj + (3 * nxhh)) + joff]);\n    f[jj + joff] = (crealf(f[jj + joff]) + cimagf(f[jj + joff])) + ((crealf(f[jj + joff]) - cimagf(f[jj + joff])) * _Complex_I);\n  }\n\n  for (j = 0; j < nxh; j++)\n  {\n    j1 = (mixup[j] - 1) / nrxb;\n    if (j < j1)\n    {\n      t1 = f[(3 * j1) + joff];\n      t2 = f[(1 + (3 * j1)) + joff];\n      t3 = f[(2 + (3 * j1)) + joff];\n      f[(3 * j1) + joff] = f[(3 * j) + joff];\n      f[(1 + (3 * j1)) + joff] = f[(1 + (3 * j)) + joff];\n      f[(2 + (3 * j1)) + joff] = f[(2 + (3 * j)) + joff];\n      f[(3 * j) + joff] = t1;\n      f[(1 + (3 * j)) + joff] = t2;\n      f[(2 + (3 * j)) + joff] = t3;\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indx1; l++)\n  {\n    ns2 = ns + ns;\n    km = nxhh / ns;\n    kmr = km * nrx;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        j1 = j + k1;\n        j2 = j + k2;\n        t1 = conjf(sct[kmr * j]);\n        t2 = t1 * f[(3 * j2) + joff];\n        t3 = t1 * f[(1 + (3 * j2)) + joff];\n        t4 = t1 * f[(2 + (3 * j2)) + joff];\n        f[(3 * j2) + joff] = f[(3 * j1) + joff] - t2;\n        f[(1 + (3 * j2)) + joff] = f[(1 + (3 * j1)) + joff] - t3;\n        f[(2 + (3 * j2)) + joff] = f[(2 + (3 * j1)) + joff] - t4;\n        f[(3 * j1) + joff] += t2;\n        f[(1 + (3 * j1)) + joff] += t3;\n        f[(2 + (3 * j1)) + joff] += t4;\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n  for (j = 0; j < nxh; j++)\n  {\n    at1 = crealf(f[(2 + (3 * j)) + joff]);\n    f[(2 + (3 * j)) + joff] = cimagf(f[(1 + (3 * j)) + joff]) + (cimagf(f[(2 + (3 * j)) + joff]) * _Complex_I);\n    at2 = crealf(f[(1 + (3 * j)) + joff]);\n    f[(1 + (3 * j)) + joff] = at1 + (cimagf(f[(3 * j) + joff]) * _Complex_I);\n    f[(3 * j) + joff] = crealf(f[(3 * j) + joff]) + (at2 * _Complex_I);\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for private(i,j,k,l,ns,ns2,km,kmr,k1,k2,jj,j1,j2,joff,at1,at2,t1,t2,t3,t4)"
    },
    "UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic3/mbpush3/20": {
        "code": "for (k = 1; k < nyh; k++)\n{\n  dky = dny * ((float) k);\n  kk = nxhd * k;\n  kj = nxvh * k;\n  k1 = (nxvh * ny) - kj;\n  ws = 0.0;\n  wp = 0.0;\n  for (j = 1; j < nxh; j++)\n  {\n    dkx = dnx * ((float) j);\n    afdt = adt * cimagf(ffc[j + kk]);\n    zt1 = (-cimagf(exyz[2 + (3 * (j + kj))])) + (crealf(exyz[2 + (3 * (j + kj))]) * _Complex_I);\n    zt2 = (-cimagf(exyz[1 + (3 * (j + kj))])) + (crealf(exyz[1 + (3 * (j + kj))]) * _Complex_I);\n    zt3 = (-cimagf(exyz[3 * (j + kj)])) + (crealf(exyz[3 * (j + kj)]) * _Complex_I);\n    zt4 = bxyz[3 * (j + kj)] - (dth * (dky * zt1));\n    zt5 = bxyz[1 + (3 * (j + kj))] + (dth * (dkx * zt1));\n    zt6 = bxyz[2 + (3 * (j + kj))] - (dth * ((dkx * zt2) - (dky * zt3)));\n    zt1 = (-cimagf(zt6)) + (crealf(zt6) * _Complex_I);\n    zt2 = (-cimagf(zt5)) + (crealf(zt5) * _Complex_I);\n    zt3 = (-cimagf(zt4)) + (crealf(zt4) * _Complex_I);\n    zt7 = (exyz[3 * (j + kj)] + (cdt * (dky * zt1))) - (afdt * cu[3 * (j + kj)]);\n    zt8 = (exyz[1 + (3 * (j + kj))] - (cdt * (dkx * zt1))) - (afdt * cu[1 + (3 * (j + kj))]);\n    zt9 = (exyz[2 + (3 * (j + kj))] + (cdt * ((dkx * zt2) - (dky * zt3)))) - (afdt * cu[2 + (3 * (j + kj))]);\n    zt1 = (-cimagf(zt9)) + (crealf(zt9) * _Complex_I);\n    zt2 = (-cimagf(zt8)) + (crealf(zt8) * _Complex_I);\n    zt3 = (-cimagf(zt7)) + (crealf(zt7) * _Complex_I);\n    exyz[3 * (j + kj)] = zt7;\n    exyz[1 + (3 * (j + kj))] = zt8;\n    exyz[2 + (3 * (j + kj))] = zt9;\n    ws += anorm * (((zt7 * conjf(zt7)) + (zt8 * conjf(zt8))) + (zt9 * conjf(zt9)));\n    zt4 -= dth * (dky * zt1);\n    zt5 += dth * (dkx * zt1);\n    zt6 -= dth * ((dkx * zt2) - (dky * zt3));\n    bxyz[3 * (j + kj)] = zt4;\n    bxyz[1 + (3 * (j + kj))] = zt5;\n    bxyz[2 + (3 * (j + kj))] = zt6;\n    wp += anorm * (((zt4 * conjf(zt4)) + (zt5 * conjf(zt5))) + (zt6 * conjf(zt6)));\n    zt1 = (-cimagf(exyz[2 + (3 * (j + k1))])) + (crealf(exyz[2 + (3 * (j + k1))]) * _Complex_I);\n    zt2 = (-cimagf(exyz[1 + (3 * (j + k1))])) + (crealf(exyz[1 + (3 * (j + k1))]) * _Complex_I);\n    zt3 = (-cimagf(exyz[3 * (j + k1)])) + (crealf(exyz[3 * (j + k1)]) * _Complex_I);\n    zt4 = bxyz[3 * (j + k1)] + (dth * (dky * zt1));\n    zt5 = bxyz[1 + (3 * (j + k1))] + (dth * (dkx * zt1));\n    zt6 = bxyz[2 + (3 * (j + k1))] - (dth * ((dkx * zt2) + (dky * zt3)));\n    zt1 = (-cimagf(zt6)) + (crealf(zt6) * _Complex_I);\n    zt2 = (-cimagf(zt5)) + (crealf(zt5) * _Complex_I);\n    zt3 = (-cimagf(zt4)) + (crealf(zt4) * _Complex_I);\n    zt7 = (exyz[3 * (j + k1)] - (cdt * (dky * zt1))) - (afdt * cu[3 * (j + k1)]);\n    zt8 = (exyz[1 + (3 * (j + k1))] - (cdt * (dkx * zt1))) - (afdt * cu[1 + (3 * (j + k1))]);\n    zt9 = (exyz[2 + (3 * (j + k1))] + (cdt * ((dkx * zt2) + (dky * zt3)))) - (afdt * cu[2 + (3 * (j + k1))]);\n    zt1 = (-cimagf(zt9)) + (crealf(zt9) * _Complex_I);\n    zt2 = (-cimagf(zt8)) + (crealf(zt8) * _Complex_I);\n    zt3 = (-cimagf(zt7)) + (crealf(zt7) * _Complex_I);\n    exyz[3 * (j + k1)] = zt7;\n    exyz[1 + (3 * (j + k1))] = zt8;\n    exyz[2 + (3 * (j + k1))] = zt9;\n    ws += anorm * (((zt7 * conjf(zt7)) + (zt8 * conjf(zt8))) + (zt9 * conjf(zt9)));\n    zt4 += dth * (dky * zt1);\n    zt5 += dth * (dkx * zt1);\n    zt6 -= dth * ((dkx * zt2) + (dky * zt3));\n    bxyz[3 * (j + k1)] = zt4;\n    bxyz[1 + (3 * (j + k1))] = zt5;\n    bxyz[2 + (3 * (j + k1))] = zt6;\n    wp += anorm * (((zt4 * conjf(zt4)) + (zt5 * conjf(zt5))) + (zt6 * conjf(zt6)));\n    bxyz[3 * ((j + kj) + l1)] = zero;\n    bxyz[1 + (3 * ((j + kj) + l1))] = zero;\n    bxyz[2 + (3 * ((j + kj) + l1))] = zero;\n    exyz[3 * ((j + kj) + l1)] = zero;\n    exyz[1 + (3 * ((j + kj) + l1))] = zero;\n    exyz[2 + (3 * ((j + kj) + l1))] = zero;\n    bxyz[3 * ((j + k1) + l1)] = zero;\n    bxyz[1 + (3 * ((j + k1) + l1))] = zero;\n    bxyz[2 + (3 * ((j + k1) + l1))] = zero;\n    exyz[3 * ((j + k1) + l1)] = zero;\n    exyz[1 + (3 * ((j + k1) + l1))] = zero;\n    exyz[2 + (3 * ((j + k1) + l1))] = zero;\n  }\n\n  afdt = adt * cimagf(ffc[kk]);\n  zt1 = (-cimagf(exyz[2 + (3 * kj)])) + (crealf(exyz[2 + (3 * kj)]) * _Complex_I);\n  zt3 = (-cimagf(exyz[3 * kj])) + (crealf(exyz[3 * kj]) * _Complex_I);\n  zt4 = bxyz[3 * kj] - (dth * (dky * zt1));\n  zt6 = bxyz[2 + (3 * kj)] + (dth * (dky * zt3));\n  zt1 = (-cimagf(zt6)) + (crealf(zt6) * _Complex_I);\n  zt3 = (-cimagf(zt4)) + (crealf(zt4) * _Complex_I);\n  zt7 = (exyz[3 * kj] + (cdt * (dky * zt1))) - (afdt * cu[3 * kj]);\n  zt9 = (exyz[2 + (3 * kj)] - (cdt * (dky * zt3))) - (afdt * cu[2 + (3 * kj)]);\n  zt1 = (-cimagf(zt9)) + (crealf(zt9) * _Complex_I);\n  zt3 = (-cimagf(zt7)) + (crealf(zt7) * _Complex_I);\n  exyz[3 * kj] = zt7;\n  exyz[1 + (3 * kj)] = zero;\n  exyz[2 + (3 * kj)] = zt9;\n  ws += anorm * ((zt7 * conjf(zt7)) + (zt9 * conjf(zt9)));\n  zt4 -= dth * (dky * zt1);\n  zt6 += dth * (dky * zt3);\n  bxyz[3 * kj] = zt4;\n  bxyz[1 + (3 * kj)] = zero;\n  bxyz[2 + (3 * kj)] = zt6;\n  wp += anorm * ((zt4 * conjf(zt4)) + (zt6 * conjf(zt6)));\n  bxyz[3 * k1] = zero;\n  bxyz[1 + (3 * k1)] = zero;\n  bxyz[2 + (3 * k1)] = zero;\n  exyz[3 * k1] = zero;\n  exyz[1 + (3 * k1)] = zero;\n  exyz[2 + (3 * k1)] = zero;\n  bxyz[3 * (kj + l1)] = zero;\n  bxyz[1 + (3 * (kj + l1))] = zero;\n  bxyz[2 + (3 * (kj + l1))] = zero;\n  exyz[3 * (kj + l1)] = zero;\n  exyz[1 + (3 * (kj + l1))] = zero;\n  exyz[2 + (3 * (kj + l1))] = zero;\n  bxyz[3 * (k1 + l1)] = zero;\n  bxyz[1 + (3 * (k1 + l1))] = zero;\n  bxyz[2 + (3 * (k1 + l1))] = zero;\n  exyz[3 * (k1 + l1)] = zero;\n  exyz[1 + (3 * (k1 + l1))] = zero;\n  exyz[2 + (3 * (k1 + l1))] = zero;\n  sum3 += ws;\n  sum4 += wp;\n}\n",
        "pragma": "#pragma omp parallel for private(j,k,k1,kk,kj,dky,dkx,afdt,zt1,zt2,zt3,zt4,zt5,zt6,zt7,zt8,zt9, ws,wp) reduction(+:sum3,sum4)"
    },
    "UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mdpic2/mdpush2/12": {
        "code": "for (i = nxi - 1; i < nxt; i++)\n{\n  for (k = 0; k < ny; k++)\n  {\n    joff = (ndim * nxhd) * k;\n    k1 = (mixup[k] - 1) / nryb;\n    if (k < k1)\n    {\n      k1 = (ndim * nxhd) * k1;\n      for (jj = 0; jj < ndim; jj++)\n      {\n        t1 = f[(jj + (ndim * i)) + k1];\n        f[(jj + (ndim * i)) + k1] = f[(jj + (ndim * i)) + joff];\n        f[(jj + (ndim * i)) + joff] = t1;\n      }\n\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indy; l++)\n  {\n    ns2 = ns + ns;\n    km = nyh / ns;\n    kmr = km * nry;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        j1 = (ndim * nxhd) * (j + k1);\n        j2 = (ndim * nxhd) * (j + k2);\n        t1 = sct[kmr * j];\n        for (jj = 0; jj < ndim; jj++)\n        {\n          t2 = t1 * f[(jj + (ndim * i)) + j2];\n          f[(jj + (ndim * i)) + j2] = f[(jj + (ndim * i)) + j1] - t2;\n          f[(jj + (ndim * i)) + j1] += t2;\n        }\n\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for private(i,j,k,l,ns,ns2,km,kmr,k1,k2,jj,j1,j2,joff,t1,t2)"
    },
    "UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mpic2/mpush2/5": {
        "code": "for (i = nxi - 1; i < nxt; i++)\n{\n  for (k = 0; k < ny; k++)\n  {\n    koff = (2 * nxhd) * k;\n    k1 = (mixup[k] - 1) / nryb;\n    if (k < k1)\n    {\n      k1 = (2 * nxhd) * k1;\n      t1 = f[(2 * i) + k1];\n      t2 = f[(1 + (2 * i)) + k1];\n      f[(2 * i) + k1] = f[(2 * i) + koff];\n      f[(1 + (2 * i)) + k1] = f[(1 + (2 * i)) + koff];\n      f[(2 * i) + koff] = t1;\n      f[(1 + (2 * i)) + koff] = t2;\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indy; l++)\n  {\n    ns2 = ns + ns;\n    km = nyh / ns;\n    kmr = km * nry;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        j1 = (2 * nxhd) * (j + k1);\n        j2 = (2 * nxhd) * (j + k2);\n        t1 = sct[kmr * j];\n        t2 = t1 * f[(2 * i) + j2];\n        t3 = t1 * f[(1 + (2 * i)) + j2];\n        f[(2 * i) + j2] = f[(2 * i) + j1] - t2;\n        f[(1 + (2 * i)) + j2] = f[(1 + (2 * i)) + j1] - t3;\n        f[(2 * i) + j1] += t2;\n        f[(1 + (2 * i)) + j1] += t3;\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for private(i,j,k,l,ns,ns2,km,kmr,k1,k2,jj,j1,j2,koff,t1,t2,t3)"
    },
    "UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpbpic2/mpbpush2/38": {
        "code": "for (k = 1; k < nyh; k++)\n{\n  k1 = ny - k;\n  dky = dny * ((float) k);\n  at1 = ci2 * crealf(ffc[k]);\n  at2 = dky * at1;\n  at1 = at1 * cimagf(ffc[k]);\n  zt1 = (-cimagf(cu[2 + (3 * k)])) + (crealf(cu[2 + (3 * k)]) * _Complex_I);\n  zt2 = (-cimagf(cu[3 * k])) + (crealf(cu[3 * k]) * _Complex_I);\n  bxy[3 * k] = at2 * zt1;\n  bxy[1 + (3 * k)] = zero;\n  bxy[2 + (3 * k)] = (-at2) * zt2;\n  bxy[3 * k1] = zero;\n  bxy[1 + (3 * k1)] = zero;\n  bxy[2 + (3 * k1)] = zero;\n  wp += at1 * (((cu[3 * k] * conjf(cu[3 * k])) + (cu[1 + (3 * k)] * conjf(cu[1 + (3 * k)]))) + (cu[2 + (3 * k)] * conjf(cu[2 + (3 * k)])));\n}\n",
        "pragma": ""
    },
    "UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mppic2/mppush2/4": {
        "code": "for (i = kypi - 1; i < kypt; i++)\n{\n  joff = (2 * nxvh) * i;\n  kmr = nxy / nx;\n  for (j = 1; j < nxhh; j++)\n  {\n    t1 = cimagf(sct[kmr * j]) + (crealf(sct[kmr * j]) * _Complex_I);\n    for (k = 0; k < 2; k++)\n    {\n      t = conjf(f[(k + (2 * (nxh - j))) + joff]);\n      s = f[(k + (2 * j)) + joff] + t;\n      t = (f[(k + (2 * j)) + joff] - t) * t1;\n      f[(k + (2 * j)) + joff] = s + t;\n      f[(k + (2 * (nxh - j))) + joff] = conjf(s - t);\n    }\n\n  }\n\n  for (k = 0; k < 2; k++)\n  {\n    f[k + joff] = (crealf(f[k + joff]) + cimagf(f[k + joff])) + ((crealf(f[k + joff]) - cimagf(f[k + joff])) * _Complex_I);\n    if (nxhh > 0)\n      f[(k + (2 * nxhh)) + joff] = 2.0 * conjf(f[(k + (2 * nxhh)) + joff]);\n\n  }\n\n  for (j = 0; j < nxh; j++)\n  {\n    j1 = (mixup[j] - 1) / nrxb;\n    if (j < j1)\n    {\n      t1 = f[(2 * j1) + joff];\n      t2 = f[(1 + (2 * j1)) + joff];\n      f[(2 * j1) + joff] = f[(2 * j) + joff];\n      f[(1 + (2 * j1)) + joff] = f[(1 + (2 * j)) + joff];\n      f[(2 * j) + joff] = t1;\n      f[(1 + (2 * j)) + joff] = t2;\n    }\n\n  }\n\n  ns = 1;\n  for (m = 0; m < indx1; m++)\n  {\n    ns2 = ns + ns;\n    km = nxhh / ns;\n    kmr = km * nrx;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        j1 = j + k1;\n        j2 = j + k2;\n        s = conjf(sct[kmr * j]);\n        t1 = s * f[(2 * j2) + joff];\n        t2 = s * f[(1 + (2 * j2)) + joff];\n        f[(2 * j2) + joff] = f[(2 * j1) + joff] - t1;\n        f[(1 + (2 * j2)) + joff] = f[(1 + (2 * j1)) + joff] - t2;\n        f[(2 * j1) + joff] += t1;\n        f[(1 + (2 * j1)) + joff] += t2;\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n  for (j = 0; j < nxh; j++)\n  {\n    at1 = cimagf(f[(2 * j) + joff]);\n    f[(2 * j) + joff] = crealf(f[(2 * j) + joff]) + (crealf(f[(1 + (2 * j)) + joff]) * _Complex_I);\n    f[(1 + (2 * j)) + joff] = at1 + (cimagf(f[(1 + (2 * j)) + joff]) * _Complex_I);\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for private(i,j,k,m,ns,ns2,km,kmr,k1,k2,j1,j2,joff,at1,s,t,t1,t2)"
    },
    "UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/vmbpush2/1": {
        "code": "for (k = 0; k < mxy1; k++)\n{\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  npp = kpic[k];\n  nn = nx - noff;\n  nn = (mx < nn) ? (mx) : (nn);\n  mm = ny - moff;\n  mm = (my < mm) ? (my) : (mm);\n  edgelx = noff;\n  edgerx = noff + nn;\n  edgely = moff;\n  edgery = moff + mm;\n  for (j = 0; j < npp; j++)\n  {\n    dx = ppart[j + (nppmx * (idimp * k))];\n    dy = ppart[j + (nppmx * (1 + (idimp * k)))];\n    ist = 0;\n    if (dx < edgelx)\n      ist = 1;\n\n    if (dx >= edgerx)\n      ist = 2;\n\n    if (dy < edgely)\n      ist += 3;\n\n    if (dy >= edgery)\n      ist += 6;\n\n    if (ist > 0)\n      *irc = k + 1;\n\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for private(j,k,noff,moff,npp,nn,mm,ist,edgelx,edgely,edgerx,edgery,dx,dy)"
    },
    "UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/kncmbpush3/14": {
        "code": "for (k = 0; k < ny; k++)\n{\n  for (j = 0; j < nxs; j += 16)\n  {\n    v_q = _mm512_load_ps(&q[(j + (nxe * k)) + (nxye * nz)]);\n    v_q = _mm512_add_ps(_mm512_load_ps(&q[j + (nxe * k)]), v_q);\n    _mm512_store_ps(&q[j + (nxe * k)], v_q);\n    _mm512_store_ps(&q[(j + (nxe * k)) + (nxye * nz)], _mm512_setzero_ps());\n  }\n\n  for (j = nxs; j < nx; j++)\n  {\n    q[j + (nxe * k)] += q[(j + (nxe * k)) + (nxye * nz)];\n    q[(j + (nxe * k)) + (nxye * nz)] = 0.0;\n  }\n\n  q[nxe * k] += q[(nx + (nxe * k)) + (nxye * nz)];\n  q[(nx + (nxe * k)) + (nxye * nz)] = 0.0;\n}\n",
        "pragma": "#pragma omp for private(j,k,v_q)"
    },
    "UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/kncmbpush3/64": {
        "code": "for (n = 1; n < nzh; n++)\n{\n  ll = nxhyd * n;\n  l1 = (nxhyd * nz) - ll;\n  for (jj = 0; jj < 3; jj++)\n  {\n    t1 = cimagf(f[jj + l1]) + (crealf(f[jj + l1]) * _Complex_I);\n    f[jj + l1] = conjf(f[jj + ll] - t1);\n    f[jj + ll] += t1;\n  }\n\n}\n",
        "pragma": ""
    },
    "UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/vmbpush3/48": {
        "code": "for (j = 0; j < nop; j++)\n{\n  n = part[idimp * j];\n  n = n / mx;\n  m = part[1 + (idimp * j)];\n  m = m / my;\n  l = part[2 + (idimp * j)];\n  l = l / mz;\n  m = (n + (mx1 * m)) + (mxy1 * l);\n  ip = kpic[m];\n  if (ip < nppmx)\n  {\n    for (i = 0; i < idimp; i++)\n    {\n      ppart[ip + (nppmx * (i + (idimp * m)))] = part[i + (idimp * j)];\n    }\n\n  }\n  else\n  {\n    ierr = (ierr > ((ip - nppmx) + 1)) ? (ierr) : ((ip - nppmx) + 1);\n  }\n\n  kpic[m] = ip + 1;\n}\n",
        "pragma": ""
    },
    "UK-MAC/TeaLeaf_OpenMP4/ext_update_halo/2": {
        "code": "for (int jj = 0; jj < depth; ++jj)\n{\n  for (int kk = HALO_PAD; kk < (_chunk.x - HALO_PAD); ++kk)\n  {\n    int base = kk;\n    buffer[base + (((_chunk.y - HALO_PAD) + jj) * _chunk.x)] = buffer[base + ((((_chunk.y - HALO_PAD) - 1) - jj) * _chunk.x)];\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "Udbhavbisarya23/OpenMP-Codes/Lab3-Collapse/collapse/0": {
        "code": "for (i = 0; i < 4; i++)\n  for (j = 0; j < 3; j++)\n  for (k = 0; k < 3; k++)\n{\n  int tid2 = omp_get_thread_num();\n  printf(\"tid=%d, i=%d j=%d k=%d\\n\", omp_get_thread_num(), i, j, k);\n}\n\n\n",
        "pragma": "#pragma omp for schedule(static,3) private(i,j,k) collapse(3)"
    },
    "UoB-HPC/SNAP-OpenMP/src/ext_kernels/5": {
        "code": "for (int i = 0; i < flux_in_len; ++i)\n{\n  flux_in[i] = 0.0;\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "VictorYaoHZ/openmp/omp+kmeans/0": {
        "code": "for (int m = 0; m < 8; ++m)\n{\n  for (int n = 0; n < 256; ++n)\n  {\n    tep[m].elements[n] = 0;\n  }\n\n}\n",
        "pragma": "#pragma omp for"
    },
    "ViktorooReps/skpod/openmp/src/tria_det/2": {
        "code": "for (col_idx = 0; col_idx < row_len; ++col_idx)\n{\n  row_dest[col_idx] += row_to_add[col_idx];\n}\n",
        "pragma": ""
    },
    "VishalVishnani/CUDA-pthread-openMP-implementation-of-Graph-Algorithms/Dijkstra/1": {
        "code": "for (i = 0; i < 1000; i++)\n{\n  if ((Node_Shortest_Dist[i] < smallest_dist_thread) && (Completed_Node[i] == 0))\n  {\n    smallest_dist_thread = Node_Shortest_Dist[i];\n    closest_node_thread = i;\n  }\n\n}\n",
        "pragma": "#pragma omp for nowait"
    },
    "YannChemin/distRS/prog/prog_ALB/alb/1": {
        "code": "for (rowcol = 0; rowcol < N; rowcol++)\n  if (lOut[rowcol] > 0)\n  lOut[rowcol] = 10 * lOut[rowcol];\n\n",
        "pragma": "#pragma omp parallel for default(none) private (rowcol) shared (N, lOut, a, b)"
    },
    "YannChemin/distRS/prog/prog_T0Dem/t0dem/0": {
        "code": "for (rowcol = 0; rowcol < N; rowcol++)\n{\n  qa = mod11A1a(l3[rowcol]);\n  if ((qa == 0) || (qa == 1))\n    lOut[rowcol] = (l2[rowcol] * 0.02) + (0.00627 * l1[rowcol]);\n  else\n    lOut[rowcol] = -28768;\n\n}\n",
        "pragma": "#pragma omp parallel for default (none) private (rowcol, qa) shared (N, l1, l2, l3, lOut)"
    },
    "YarinDev/Parallel-Sequence-Alignment/src/main/3": {
        "code": "for (i = 0; i < 26; i++)\n  scoringMatrix[i][i] = weights[0];\n",
        "pragma": ""
    },
    "YarnSeemannsgarn/University_Innsbruck-Parallel_Systems-Homework_6/programme/dijkstra_openmp/3": {
        "code": "for (i = 0; i < node_count; i++)\n{\n  if (i != current)\n  {\n    nodes[i].total_distance = -1;\n    add_unvisited_node(&unvisited_nodes_head, i);\n  }\n\n}\n",
        "pragma": ""
    },
    "a2gs/OMP_studies/sample/0": {
        "code": "for (i = 0; i < 4; ++i)\n{\n  printf(\"Hello World parallel for!\\n\");\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "aaronweeden/pi2018-hybrid-exercise-solns/life/2": {
        "code": "for (col = 1; col <= NUM_COLS; col++)\n{\n  current_grid[row][col] = next_grid[row][col];\n}\n",
        "pragma": "#pragma omp parallel for private(col)"
    },
    "aaronweeden/pi2018-omp-examples/heat1/5": {
        "code": "for (row = 0; row < RowCount; row++)\n{\n  for (col = 0; col < ColCount; col++)\n  {\n    printf(\"%6.3f \", CellArray[row][col]);\n  }\n\n  printf(\"\\n\");\n}\n",
        "pragma": ""
    },
    "abdussametkaci/Parallel_Programming/Lecture13/pi_omp/0": {
        "code": "for (i = 0; i < 1000000000; i++)\n  pi += f(i * h);\n",
        "pragma": "#pragma omp parallel for schedule(static) reduction(+:pi) private(i)"
    },
    "abidrahman/Discovering-OpenMP/static/1": {
        "code": "for (i = k - 1; i >= 0; --i)\n{\n  temp = Au[index[i]][k] / Au[index[k]][k];\n  Au[index[i]][k] -= temp * Au[index[k]][k];\n  Au[index[i]][size] -= temp * Au[index[k]][size];\n}\n",
        "pragma": "#pragma omp for schedule(static, 64) private(temp, i)"
    },
    "abignoli/find-communities-OpenMP/src/community-computation-weighted/0": {
        "code": "for (i = 0; i < cd->n; i++)\n{\n  internal_weight_community = (double) (*(cd->internal_weight_community + i));\n  incoming_weight_community = (double) (*(cd->incoming_weight_community + i));\n  result += internal_weight_community - ((incoming_weight_community * incoming_weight_community) / double_m);\n}\n",
        "pragma": "#pragma omp parallel for schedule(dynamic, 20) default(shared) private(internal_weight_community, incoming_weight_community) reduction(+:result)"
    },
    "abu-abraham/open-MP/examples/matmult/3": {
        "code": "for (i = 0; i < dimension; i++)\n{\n  for (j = 0; j < dimension; j++)\n  {\n    matrix[i][j] = ((rand() % 1000) + 1) * const_value;\n  }\n\n}\n",
        "pragma": ""
    },
    "acenet-arc/ACENET_Summer_School_OpenMP_ACC/code/elect_energy_avx2/0": {
        "code": "for (i = 0; i < v_count; i++)\n{\n  tmpQ[0] = _mm256_broadcast_ss(&Q[i][0]);\n  tmpQ[1] = _mm256_broadcast_ss(&Q[i][1]);\n  tmpQ[2] = _mm256_broadcast_ss(&Q[i][2]);\n  tmpQ[3] = _mm256_broadcast_ss(&Q[i][3]);\n  tmpQ[4] = _mm256_broadcast_ss(&Q[i][4]);\n  tmpQ[5] = _mm256_broadcast_ss(&Q[i][5]);\n  tmpQ[6] = _mm256_broadcast_ss(&Q[i][6]);\n  tmpQ[7] = _mm256_broadcast_ss(&Q[i][7]);\n  tmpX[0] = _mm256_broadcast_ss(&X[i][0]);\n  tmpX[1] = _mm256_broadcast_ss(&X[i][1]);\n  tmpX[2] = _mm256_broadcast_ss(&X[i][2]);\n  tmpX[3] = _mm256_broadcast_ss(&X[i][3]);\n  tmpX[4] = _mm256_broadcast_ss(&X[i][4]);\n  tmpX[5] = _mm256_broadcast_ss(&X[i][5]);\n  tmpX[6] = _mm256_broadcast_ss(&X[i][6]);\n  tmpX[7] = _mm256_broadcast_ss(&X[i][7]);\n  tmpY[0] = _mm256_broadcast_ss(&Y[i][0]);\n  tmpY[1] = _mm256_broadcast_ss(&Y[i][1]);\n  tmpY[2] = _mm256_broadcast_ss(&Y[i][2]);\n  tmpY[3] = _mm256_broadcast_ss(&Y[i][3]);\n  tmpY[4] = _mm256_broadcast_ss(&Y[i][4]);\n  tmpY[5] = _mm256_broadcast_ss(&Y[i][5]);\n  tmpY[6] = _mm256_broadcast_ss(&Y[i][6]);\n  tmpY[7] = _mm256_broadcast_ss(&Y[i][7]);\n  tmpZ[0] = _mm256_broadcast_ss(&Z[i][0]);\n  tmpZ[1] = _mm256_broadcast_ss(&Z[i][1]);\n  tmpZ[2] = _mm256_broadcast_ss(&Z[i][2]);\n  tmpZ[3] = _mm256_broadcast_ss(&Z[i][3]);\n  tmpZ[4] = _mm256_broadcast_ss(&Z[i][4]);\n  tmpZ[5] = _mm256_broadcast_ss(&Z[i][5]);\n  tmpZ[6] = _mm256_broadcast_ss(&Z[i][6]);\n  tmpZ[7] = _mm256_broadcast_ss(&Z[i][7]);\n  vcps = _mm256_setzero_ps();\n  for (m = 0; m < 8; m++)\n  {\n    diff[0] = _mm256_sub_ps(tmpX[m], X[i]);\n    diff[1] = _mm256_sub_ps(tmpY[m], Y[i]);\n    diff[2] = _mm256_sub_ps(tmpZ[m], Z[i]);\n    r_vec = _mm256_fmadd_ps(diff[0], diff[0], _mm256_setzero_ps());\n    r_vec = _mm256_fmadd_ps(diff[1], diff[1], r_vec);\n    r_vec = _mm256_fmadd_ps(diff[2], diff[2], r_vec);\n    r_vec = _mm256_rsqrt_ps(r_vec);\n    result = _mm256_mul_ps(tmpQ[m], Q[i]);\n    result = _mm256_mul_ps(result, r_vec);\n    result = _mm256_and_ps(mask[m], result);\n    vcps = _mm256_add_ps(vcps, result);\n  }\n\n  _mm256_store_ps(tmp_add, vcps);\n  Energy += ((((((tmp_add[0] + tmp_add[1]) + tmp_add[2]) + tmp_add[3]) + tmp_add[4]) + tmp_add[5]) + tmp_add[6]) + tmp_add[7];\n  for (j = i + 1; j < v_count; j++)\n  {\n    vcps = _mm256_setzero_ps();\n    for (m = 0; m < 8; m++)\n    {\n      diff[0] = _mm256_sub_ps(tmpX[m], X[j]);\n      diff[1] = _mm256_sub_ps(tmpY[m], Y[j]);\n      diff[2] = _mm256_sub_ps(tmpZ[m], Z[j]);\n      r_vec = _mm256_fmadd_ps(diff[0], diff[0], _mm256_setzero_ps());\n      r_vec = _mm256_fmadd_ps(diff[1], diff[1], r_vec);\n      r_vec = _mm256_fmadd_ps(diff[2], diff[2], r_vec);\n      r_vec = _mm256_rsqrt_ps(r_vec);\n      result = _mm256_mul_ps(tmpQ[m], Q[j]);\n      vcps = _mm256_fmadd_ps(result, r_vec, vcps);\n    }\n\n    _mm256_store_ps(tmp_add, vcps);\n    Energy += ((((((tmp_add[0] + tmp_add[1]) + tmp_add[2]) + tmp_add[3]) + tmp_add[4]) + tmp_add[5]) + tmp_add[6]) + tmp_add[7];\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for private(tmpQ, tmpX, tmpY, tmpZ, i, j, m, diff, r_vec, vcps, tmp_add, result) reduction(+ : Energy) schedule(dynamic)"
    },
    "adhithadias/matrix-multiply/omp-mat-mul/omp-mat-mul/0": {
        "code": "for (t = 0; t < 1600; t++)\n{\n  for (i = t * stripeSize; i < min((t * stripeSize) + stripeSize, 1600); i++)\n  {\n    for (j = 0; j < 1600; j++)\n    {\n      double comp = 0.;\n      for (k = 0; k < 1600; k++)\n      {\n        comp += (*((a + (i * 1600)) + k)) * (*((b + (k * 1600)) + j));\n      }\n\n      *((c + (i * 1600)) + j) = comp;\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for shared(a,b,c) private(i,j,k,t)"
    },
    "adtac/openmp-graph/src/kcommittee/9": {
        "code": "for (int i = 0; i < g->N; i++)\n{\n  if (committee_count[i] > K)\n  {\n    WARN(\"committee %d has too many members (%d > %d)\\n\", i, committee_count[i], K);\n    correct = 0;\n  }\n\n}\n",
        "pragma": ""
    },
    "afdezfraga/APP_Lab1/Vect/swim-parallel-vect/5": {
        "code": "for (I = 0; I < M; I++)\n{\n  UNEW[I + 1][N] = UNEW[I + 1][0];\n  VNEW[I][0] = VNEW[I][N];\n  PNEW[I][N] = PNEW[I][0];\n}\n",
        "pragma": "#pragma omp for simd nowait schedule(simd:static)"
    },
    "agujjar2206/OpenMP/openMp/3": {
        "code": "for (int i = 0; i < 12000000; i++)\n{\n  dist = ((x[i] * x[i]) + (y[i] * y[i])) + (z[i] * z[i]);\n  if (dist > result->maxProduct)\n  {\n    result->maxProduct = dist;\n    result->idx_max = i;\n  }\n\n  if (dist < result->minProduct)\n  {\n    result->minProduct = dist;\n    result->idx_min = i;\n  }\n\n}\n",
        "pragma": ""
    },
    "ahalyasanjiv/Parallel-Programming-LTDP/viterbi/viterbi_ltdp_openmp/1": {
        "code": "for (int i = 0; i < q; i++)\n{\n  for (int j = 0; j < t; j++)\n  {\n    if (j == 0)\n    {\n      int observation = Y[0];\n      dp1[i][0] = I[i] + B[i][observation];\n      dp2[i][0] = 0;\n    }\n    else\n    {\n      dp1[i][j] = get_rand_float(min_prob, max_prob);\n      dp2[i][j] = 0;\n    }\n\n  }\n\n}\n",
        "pragma": ""
    },
    "aignacio/openmp_eval_arm/generic_alg/src/RandomForest/12": {
        "code": "for (j = 0; j < k; j++)\n{\n  treeRF[j] = nodes + AddressNode;\n  AddressNode = n[j] + AddressNode;\n}\n",
        "pragma": ""
    },
    "ainsleyrutterford/HPC-OpenCL/openmp_d2q9-bgk/2": {
        "code": "for (int jj = 0; jj < params->ny; jj++)\n{\n  for (int ii = 0; ii < params->nx; ii++)\n  {\n    (*cells_ptr)[((0 * params->ny) * params->nx) + (ii + (jj * params->nx))] = w0;\n    (*cells_ptr)[((1 * params->ny) * params->nx) + (ii + (jj * params->nx))] = w1;\n    (*cells_ptr)[((2 * params->ny) * params->nx) + (ii + (jj * params->nx))] = w1;\n    (*cells_ptr)[((3 * params->ny) * params->nx) + (ii + (jj * params->nx))] = w1;\n    (*cells_ptr)[((4 * params->ny) * params->nx) + (ii + (jj * params->nx))] = w1;\n    (*cells_ptr)[((5 * params->ny) * params->nx) + (ii + (jj * params->nx))] = w2;\n    (*cells_ptr)[((6 * params->ny) * params->nx) + (ii + (jj * params->nx))] = w2;\n    (*cells_ptr)[((7 * params->ny) * params->nx) + (ii + (jj * params->nx))] = w2;\n    (*cells_ptr)[((8 * params->ny) * params->nx) + (ii + (jj * params->nx))] = w2;\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "ajs7270/snu_shpc21/hw4/mat_mul/mat_mul/0": {
        "code": "for (int i = M / 2; i < M; ++i)\n{\n  for (int j = 0; j < N; ++j)\n  {\n    C[(i * N) + j] = 0;\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "akarazeev/MolecularDynamics-3sem-MIPT-2015/OmpMolecDynam/OmpMolecDynam/main/3": {
        "code": "for (int i = 0; i < N; ++i)\n{\n  for (int k = 0; k < 3; ++k)\n  {\n    f[i][k] = 0;\n  }\n\n}\n",
        "pragma": ""
    },
    "akuldr67/OpenMP-CovarianceMatrix/cov/2": {
        "code": "for (i = 0; i < count; i++)\n{\n  for (j = 0; j < rows; j++)\n    data[i][j] -= mean[j];\n\n}\n",
        "pragma": "#pragma omp parallel for private(j)"
    },
    "amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/BT/bt-long/22": {
        "code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 3; j < (grid_points[1] - 3); j++)\n  {\n    for (k = 1; k < (grid_points[2] - 1); k++)\n    {\n      for (m_imopVar18 = 0; m_imopVar18 < 5; m_imopVar18++)\n      {\n        rhs[i][j][k][m_imopVar18] = rhs[i][j][k][m_imopVar18] - (dssp * ((((u[i][j - 2][k][m_imopVar18] - (4.0 * u[i][j - 1][k][m_imopVar18])) + (6.0 * u[i][j][k][m_imopVar18])) - (4.0 * u[i][j + 1][k][m_imopVar18])) + u[i][j + 2][k][m_imopVar18]));\n      }\n\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp for nowait"
    },
    "amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/FT/ft/0": {
        "code": "for (i_imopVarPre87 = 0; i_imopVarPre87 < dims[2][0]; i_imopVarPre87++)\n{\n  ii_imopVarPre90 = (((((i_imopVarPre87 + 1) + xstart[2]) - 2) + (64 / 2)) % 64) - (64 / 2);\n  ii2_imopVarPre91 = ii_imopVarPre90 * ii_imopVarPre90;\n  for (j_imopVarPre88 = 0; j_imopVarPre88 < dims[2][1]; j_imopVarPre88++)\n  {\n    jj_imopVarPre92 = (((((j_imopVarPre88 + 1) + ystart[2]) - 2) + (64 / 2)) % 64) - (64 / 2);\n    ij2_imopVarPre93 = (jj_imopVarPre92 * jj_imopVarPre92) + ii2_imopVarPre91;\n    for (k_imopVarPre89 = 0; k_imopVarPre89 < dims[2][2]; k_imopVarPre89++)\n    {\n      kk_imopVarPre94 = (((((k_imopVarPre89 + 1) + zstart[2]) - 2) + (64 / 2)) % 64) - (64 / 2);\n      indexmap[k_imopVarPre89][j_imopVarPre88][i_imopVarPre87] = (kk_imopVarPre94 * kk_imopVarPre94) + ij2_imopVarPre93;\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp for nowait"
    },
    "amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/LU/lu/20": {
        "code": "for (i_imopVarPre93 = ist; i_imopVarPre93 <= iend; i_imopVarPre93++)\n{\n  for (j_imopVarPre94 = jst; j_imopVarPre94 <= jend; j_imopVarPre94++)\n  {\n    for (k_imopVarPre95 = 1; k_imopVarPre95 <= (nz0 - 2); k_imopVarPre95++)\n    {\n      sum0 = sum0 + (v[i_imopVarPre93][j_imopVarPre94][k_imopVarPre95][0] * v[i_imopVarPre93][j_imopVarPre94][k_imopVarPre95][0]);\n      sum1 = sum1 + (v[i_imopVarPre93][j_imopVarPre94][k_imopVarPre95][1] * v[i_imopVarPre93][j_imopVarPre94][k_imopVarPre95][1]);\n      sum2 = sum2 + (v[i_imopVarPre93][j_imopVarPre94][k_imopVarPre95][2] * v[i_imopVarPre93][j_imopVarPre94][k_imopVarPre95][2]);\n      sum3 = sum3 + (v[i_imopVarPre93][j_imopVarPre94][k_imopVarPre95][3] * v[i_imopVarPre93][j_imopVarPre94][k_imopVarPre95][3]);\n      sum4 = sum4 + (v[i_imopVarPre93][j_imopVarPre94][k_imopVarPre95][4] * v[i_imopVarPre93][j_imopVarPre94][k_imopVarPre95][4]);\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp for nowait"
    },
    "amannougrahiya/imop-compiler/tests/bt-long/1": {
        "code": "for (i_imopVar150 = 0; i_imopVar150 < grid_points[0]; i_imopVar150++)\n{\n  for (j_imopVar151 = 0; j_imopVar151 < grid_points[1]; j_imopVar151++)\n  {\n    for (k_imopVar152 = 0; k_imopVar152 < grid_points[2]; k_imopVar152++)\n    {\n      for (m_imopVar153 = 0; m_imopVar153 < 5; m_imopVar153++)\n      {\n        lhs[i_imopVar150][j_imopVar151][k_imopVar152][1][m_imopVar153][m_imopVar153] = 1.0;\n      }\n\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp for nowait"
    },
    "amannougrahiya/imop-compiler/tests/bt-long/51": {
        "code": "for (i_imopVar110 = 0; i_imopVar110 < grid_points[0]; i_imopVar110++)\n{\n  for (j_imopVar111 = 0; j_imopVar111 < grid_points[1]; j_imopVar111++)\n  {\n    for (k_imopVar112 = 0; k_imopVar112 < grid_points[2]; k_imopVar112++)\n    {\n      rho_inv = 1.0 / u[i_imopVar110][j_imopVar111][k_imopVar112][0];\n      rho_i[i_imopVar110][j_imopVar111][k_imopVar112] = rho_inv;\n      us[i_imopVar110][j_imopVar111][k_imopVar112] = u[i_imopVar110][j_imopVar111][k_imopVar112][1] * rho_inv;\n      vs[i_imopVar110][j_imopVar111][k_imopVar112] = u[i_imopVar110][j_imopVar111][k_imopVar112][2] * rho_inv;\n      ws[i_imopVar110][j_imopVar111][k_imopVar112] = u[i_imopVar110][j_imopVar111][k_imopVar112][3] * rho_inv;\n      square[i_imopVar110][j_imopVar111][k_imopVar112] = (0.5 * (((u[i_imopVar110][j_imopVar111][k_imopVar112][1] * u[i_imopVar110][j_imopVar111][k_imopVar112][1]) + (u[i_imopVar110][j_imopVar111][k_imopVar112][2] * u[i_imopVar110][j_imopVar111][k_imopVar112][2])) + (u[i_imopVar110][j_imopVar111][k_imopVar112][3] * u[i_imopVar110][j_imopVar111][k_imopVar112][3]))) * rho_inv;\n      qs[i_imopVar110][j_imopVar111][k_imopVar112] = square[i_imopVar110][j_imopVar111][k_imopVar112] * rho_inv;\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp for nowait"
    },
    "amannougrahiya/imop-compiler/tests/testis/8": {
        "code": "for (i = 0; i < (1 << 11); i++)\n{\n  key_buff1[i] += prv_buff1[i];\n}\n",
        "pragma": ""
    },
    "an31146/source_code/mpi+omp/openmp_for_loop/1": {
        "code": "for (i = 0; i < 1000; i++)\n  a[i] = (b[i] = i);\n",
        "pragma": ""
    },
    "an4/HPC-OpenMP/d2q9-bgk/8": {
        "code": "for (ii = 0; ii < params.ny; ii++)\n{\n  for (jj = 0; jj < params.nx; jj++)\n  {\n    if (obstacles[(ii * params.nx) + jj])\n    {\n      u_x = (u_y = (u = 0.0));\n      pressure = params.density * c_sq;\n    }\n    else\n    {\n      local_density = 0.0;\n      for (kk = 0; kk < 9; kk++)\n      {\n        local_density += cells[(ii * params.nx) + jj].speeds[kk];\n      }\n\n      u_x = (((cells[(ii * params.nx) + jj].speeds[1] + cells[(ii * params.nx) + jj].speeds[5]) + cells[(ii * params.nx) + jj].speeds[8]) - ((cells[(ii * params.nx) + jj].speeds[3] + cells[(ii * params.nx) + jj].speeds[6]) + cells[(ii * params.nx) + jj].speeds[7])) / local_density;\n      u_y = (((cells[(ii * params.nx) + jj].speeds[2] + cells[(ii * params.nx) + jj].speeds[5]) + cells[(ii * params.nx) + jj].speeds[6]) - ((cells[(ii * params.nx) + jj].speeds[4] + cells[(ii * params.nx) + jj].speeds[7]) + cells[(ii * params.nx) + jj].speeds[8])) / local_density;\n      u = sqrt((u_x * u_x) + (u_y * u_y));\n      pressure = local_density * c_sq;\n    }\n\n    fprintf(fp, \"%d %d %.12E %.12E %.12E %.12E %d\\n\", jj, ii, u_x, u_y, u, pressure, obstacles[(ii * params.nx) + jj]);\n  }\n\n}\n",
        "pragma": ""
    },
    "ananthsuresh/eecs438-hw6/threadedheat/2": {
        "code": "for (i = 0; i <= (ROWS + 1); i++)\n{\n  for (j = 0; j <= (COLUMNS + 1); j++)\n  {\n    Temperature_last[(i * (COLUMNS + 2)) + j] = 0.0;\n  }\n\n}\n",
        "pragma": ""
    },
    "apollo12221/Parallel-AG-Gen-Docker/c_bfs/3": {
        "code": "for (int i = 0; i < 20000033; i++)\n  edgeDirTable[i].hashNum = 0;\n",
        "pragma": ""
    },
    "apooreapo/PageRank/pageRankParallelFinal/18": {
        "code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    temp = 0;\n    for (k = 0; k < N; k++)\n    {\n      temp += A[i][k] * B[k][j];\n    }\n\n    C[i][j] = temp;\n  }\n\n}\n",
        "pragma": ""
    },
    "arielfreire/conways-game-of-life/jogo_da_vida/3": {
        "code": "for (i = 0; i < size; i++)\n{\n  for (j = 0; j < size; j++)\n  {\n    printf(\"%c\", *((table + (i * size)) + j));\n  }\n\n  printf(\"\\n\");\n}\n",
        "pragma": ""
    },
    "arjunpatel422/OpenMPLab/edgedetect/3": {
        "code": "for (y = *width; y < maxRowLimit; y += *width)\n{\n  gx = 0.f;\n  gy = 0.f;\n  srcPosition = y - (*width);\n  for (mPosition = 0; mPosition < 9; srcPosition += *width)\n  {\n    gx += src[srcPosition] * (mx[mPosition] + mx[mPosition + 1]);\n    gy += src[srcPosition++] * (my[mPosition] + my[mPosition + 1]);\n    mPosition++;\n    gx += src[srcPosition] * mx[++mPosition];\n    gy += src[srcPosition--] * my[mPosition++];\n  }\n\n  srcPosition = y;\n  g_mag[srcPosition] = hypotf(gy, gx);\n  g_ang[srcPosition++] = atan2f(gy, gx);\n  for (x = 1; x < maxColumnLimit; x++)\n  {\n    gx = 0.f;\n    gy = 0.f;\n    srcPosition -= *width;\n    for (mPosition = 0; mPosition < 9; srcPosition += *width)\n    {\n      gx += src[--srcPosition] * mx[mPosition];\n      gy += src[srcPosition++] * my[mPosition++];\n      gx += src[srcPosition] * mx[mPosition];\n      gy += src[srcPosition++] * my[mPosition++];\n      gx += src[srcPosition] * mx[mPosition];\n      gy += src[srcPosition--] * my[mPosition++];\n    }\n\n    srcPosition -= doubleWidth;\n    g_mag[srcPosition] = hypotf(gy, gx);\n    g_ang[srcPosition++] = atan2f(gy, gx);\n  }\n\n  gx = 0.f;\n  gy = 0.f;\n  srcPosition -= *width;\n  for (mPosition = 0; mPosition < 9; srcPosition += *width)\n  {\n    gx += src[--srcPosition] * mx[mPosition];\n    gy += src[srcPosition++] * my[mPosition++];\n    gx += src[srcPosition] * (mx[mPosition] + mx[mPosition + 1]);\n    gy += src[srcPosition] * (my[mPosition] + my[mPosition + 1]);\n    mPosition += 2;\n  }\n\n  srcPosition -= doubleWidth;\n  g_mag[srcPosition] = hypotf(gy, gx);\n  g_ang[srcPosition] = atan2f(gy, gx);\n}\n",
        "pragma": "#pragma omp parallel for private(y,x,srcPosition,mPosition,gx,gy)"
    },
    "arjunth2001/Software-Programming-for-Performance/Assignment2/trials/4/3": {
        "code": "for (i = 0; i < k; ++i)\n{\n  a = *(result->matrix + i);\n  for (j = 0; j < temp; ++j)\n  {\n    printf(\"%lld \", *(a + j));\n  }\n\n  printf(\"\\n\");\n}\n",
        "pragma": ""
    },
    "arneish/parallel-PCA-openmp/lab2_omp_orig/1": {
        "code": "for (row = 0; row < col; row++)\n{\n  result = 0.0;\n  for (row_ = 0; row_ < P; row_++)\n  {\n    result += Q_[(row_ * P) + row] * A_T[(col * P) + row_];\n  }\n\n  R_[(row * P) + col] = result;\n  for (row_ = 0; row_ < P; row_++)\n  {\n    v_col[row_] -= R_[(row * P) + col] * Q_[(row_ * P) + row];\n  }\n\n}\n",
        "pragma": "#pragma omp for collapse(2) private(i, j)"
    },
    "arslansadiq/Parallel-Programming-TUM/Assignment12_Hybrid/student/heat_par/1": {
        "code": "for (int i = 0; i < nsources; ++i)\n{\n  int locx = sources[i][0] - offx;\n  int locy = sources[i][1] - offy;\n  if ((((locx >= 0) && (locx < bx)) && (locy >= 0)) && (locy < by))\n  {\n    locsources[locnsources][0] = locx + 1;\n    locsources[locnsources][1] = locy + 1;\n    locnsources++;\n  }\n\n}\n",
        "pragma": ""
    },
    "atanu151/Matrix-Multiplication/main/12": {
        "code": "for (i = 0; i < 2048; i++)\n{\n  for (j = 0; j < 2048; j++)\n  {\n    sum = 0.0;\n    for (k = 0; k < 2048; k++)\n    {\n      sum += A[i][k] * B[k][j];\n    }\n\n    C[i][j] = sum;\n  }\n\n}\n",
        "pragma": ""
    },
    "atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SPMV/22": {
        "code": "for (j = 0; j < totalPartitions; ++j)\n{\n  uint32_t k;\n  uint32_t src;\n  uint32_t dest;\n  float weight = 0.0001f;\n  struct Partition *partition = &graph->grid->partitions[(i * totalPartitions) + j];\n  for (k = 0; k < partition->num_edges; ++k)\n  {\n    src = partition->edgeList->edges_array_src[k];\n    dest = partition->edgeList->edges_array_dest[k];\n    weight = partition->edgeList->edges_array_weight[k];\n    stats->vector_output[dest] += weight * stats->vector_input[src];\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for private(j) schedule (dynamic,arguments->algo_numThreads)"
    },
    "atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/bellmanFord/17": {
        "code": "for (vertex_id = 0; vertex_id < stats->num_vertices; vertex_id++)\n{\n  sum += stats->distances[vertex_id];\n  printf(\"v: %u d: %u \\n\", vertex_id, sum);\n}\n",
        "pragma": ""
    },
    "atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/connectedComponents/31": {
        "code": "for (iter = 0; iter < graph->num_vertices; iter++)\n{\n  comp = stats->components[iter];\n  n = inverselabels[comp];\n  softResetArrayQueue(frontier);\n  enArrayQueueWithBitmap(frontier, n);\n  for (i = frontier->head; i < frontier->tail; i++)\n  {\n    uint32_t u = frontier->queue[i];\n    uint32_t edge_idx = graph->vertices->edges_idx[u];\n    uint32_t out_degree = graph->vertices->out_degree[u];\n    for (j = edge_idx; j < (edge_idx + out_degree); j++)\n    {\n      uint32_t v = EXTRACT_VALUE(graph->sorted_edges_array->edges_array_dest[j]);\n      if (stats->components[v] != comp)\n      {\n        pass = 0;\n      }\n\n      if (!isEnArrayQueued(frontier, v))\n        enArrayQueueWithBitmap(frontier, v);\n\n    }\n\n    uint32_t in_edge_idx = graph->inverse_vertices->edges_idx[u];\n    uint32_t in_degree = graph->inverse_vertices->out_degree[u];\n    for (j = in_edge_idx; j < (in_edge_idx + in_degree); j++)\n    {\n      uint32_t v = EXTRACT_VALUE(graph->inverse_sorted_edges_array->edges_array_dest[j]);\n      if (stats->components[v] != comp)\n      {\n        pass = 0;\n      }\n\n      if (!isEnArrayQueued(frontier, v))\n        enArrayQueueWithBitmap(frontier, v);\n\n    }\n\n  }\n\n}\n",
        "pragma": ""
    },
    "atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/pageRank/39": {
        "code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  aResiduals[v] = 0.0f;\n  workListCurr[v] = 1;\n  workListNext[v] = 0;\n  activeVertices++;\n  Nodes = graph->vertices[v].outNodes;\n  degree = graph->vertices[v].out_degree;\n  for (j = 0; j < degree; j++)\n  {\n    u = Nodes->dest;\n    Nodes = Nodes->next;\n    if (graph->vertices[u].out_degree)\n      aResiduals[v] += 1.0f / graph->vertices[u].out_degree;\n\n  }\n\n  aResiduals[v] = ((1.0f - stats->damp) * stats->damp) * aResiduals[v];\n}\n",
        "pragma": "#pragma omp parallel for private(Nodes,degree,v,j,u) shared(stats,workListCurr,workListNext,aResiduals) reduction(+:activeVertices)"
    },
    "atmughrabi/OpenGraph/00_graph_bench/src/preprocess/reorder/26": {
        "code": "for (j = num_buckets - 1; j >= 0; --j)\n{\n  k = start_idx[(t_id * num_buckets) + j];\n  for (iter = vc_vector_begin(buckets[(t_id * num_buckets) + j]); iter != vc_vector_end(buckets[(t_id * num_buckets) + j]); iter = vc_vector_next(buckets[(t_id * num_buckets) + j], iter))\n  {\n    verticesHot[j][k] = *((uint32_t *) iter);\n    degreesHot[j][k] = degrees[*((uint32_t *) iter)];\n    k++;\n  }\n\n}\n",
        "pragma": ""
    },
    "atmughrabi/OpenGraph/00_graph_bench/src/structures/grid/2": {
        "code": "for (i = 0; i < grid->num_vertices; ++i)\n{\n  grid->out_degree[i] = 0;\n  grid->in_degree[i] = 0;\n}\n",
        "pragma": "#pragma omp parallel for default(none) private(i) shared(grid)"
    },
    "atmughrabi/OpenGraph/00_graph_bench/src/utils/graphStats/29": {
        "code": "for (x = 0; x < topK_array_size; ++x)\n{\n  if (ref_stats->num_vertices < topK_array[x])\n    break;\n\n  fprintf(fptr, \"%-14lf \", pageRankCorrelationStats_array[x].real_Kendall);\n}\n",
        "pragma": ""
    },
    "atmughrabi/OpenGraphSim/00_graph_bench/src/cache/cache/41": {
        "code": "for (i = 0; i < cache->num_buckets; ++i)\n{\n  if (cache->thresholds_count[i])\n  {\n    thresholds_avgDegrees[i] = XPRRPV_INIT * (((float) cache->thresholds_totalDegrees[i]) / totalDegrees);\n  }\n  else\n  {\n    thresholds_avgDegrees[i] = 0;\n  }\n\n}\n",
        "pragma": ""
    },
    "avr-aics-riken/PMlib/doc/src_advanced/sub_copy/4": {
        "code": "for (k = 1; k < 10; k++)\n{\n  j = 3;\n  avgtime[j] = avgtime[j] + times[j][k];\n  mintime[j] = (mintime[j] < times[j][k]) ? (mintime[j]) : (times[j][k]);\n  maxtime[j] = (maxtime[j] > times[j][k]) ? (maxtime[j]) : (times[j][k]);\n}\n",
        "pragma": ""
    },
    "axell-brendow/seminars-ii/Trabalho Paralelismo/Quicksort/6": {
        "code": "for (i = 0; i < arrayLength; i++)\n{\n  array[i] = (rand() % arrayLength) + 1;\n}\n",
        "pragma": ""
    },
    "ayan2809/Parallel-and-Distributed-Computing/Lab 3/code1_1/0": {
        "code": "for (int j = 0; j < ((sizeof(a)) / (sizeof(a[0]))); j++)\n{\n  cube = (a[j] * a[j]) * a[j];\n  printf(\"Cube value = %d\\n\", cube);\n}\n",
        "pragma": "#pragma omp parallel for private(cube)"
    },
    "bastiendearaujo/MPI_OpenMp_DeepNeural/sources/rnn/13": {
        "code": "for (i = 0; i < layer->nbNodes; ++i)\n{\n  if (layer->value[i] > max)\n  {\n    max = layer->value[i];\n    res = outTableRnn[i];\n    indiceMax = i;\n  }\n\n  if (out[i] == 1)\n  {\n    indiceOut = i;\n  }\n\n}\n",
        "pragma": "#pragma omp for schedule(static) private(i)"
    },
    "batux/hybrid_high_performance_parallel_computing/sample_array_processing_01/main/1": {
        "code": "for (i = 0; i < 10000; i++)\n{\n  data[i] = i * 1.0f;\n}\n",
        "pragma": "#pragma omp parallel for shared(data)"
    },
    "belinguc/Parallel_Computing/OpenMP_APSP/MatUtil/2": {
        "code": "for (int k = 0; k < N; k++)\n  for (int i = 0; i < N; i++)\n  for (int j = 0; j < N; j++)\n{\n  int i0 = (i * N) + j;\n  int i1 = (i * N) + k;\n  int i2 = (k * N) + j;\n  if ((mat[i1] != (-1)) && (mat[i2] != (-1)))\n  {\n    int sum = mat[i1] + mat[i2];\n    if ((mat[i0] == (-1)) || (sum < mat[i0]))\n      mat[i0] = sum;\n\n  }\n\n}\n\n\n",
        "pragma": ""
    },
    "benchmark-subsetting/NPB3.0-omp-C/MG/mg/0": {
        "code": "for (i3 = 1; i3 < (n3 - 1); i3++)\n{\n  for (i2 = 1; i2 < (n2 - 1); i2++)\n  {\n    for (i1 = 1; i1 < (n1 - 1); i1++)\n    {\n      s = s + (r[i3][i2][i1] * r[i3][i2][i1]);\n      a = fabs(r[i3][i2][i1]);\n      if (a > tmp)\n        tmp = a;\n\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for default(shared) private(i1,i2,i3,a) reduction(+:s) reduction(max:tmp)"
    },
    "benwaffle/omp_trip/omp_trip/0": {
        "code": "for (unsigned i = 0; decimal > 0; ++i)\n{\n  pass[i] = (decimal % 95) + 32;\n  decimal /= 95;\n}\n",
        "pragma": ""
    },
    "bernardoduarte/PPD/OpenMP/assignments/01_matrix_multiplication/prog/0": {
        "code": "for (i = 0; i < rowsC; ++i)\n{\n  for (j = 0; j < columnsC; ++j)\n  {\n    for (k = 0; k < columnsA; ++k)\n    {\n      matrixC[i][j] += matrixA[i][k] * matrixB[k][j];\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for private(i,j,k) num_threads(numThreads)"
    },
    "bgin/Guided_Missile_Simulation/blas-kernels/GMS_copy_avx_unrolled16x/37": {
        "code": "for (i = 0; (i + 127) < n; i += 128)\n{\n  _mm_prefetch((const char *) (&x[i + 32]), _MM_HINT_T0);\n  xv[0] = _mm256_loadu_ps(&x[i + 0]);\n  _mm256_storeu_ps(&y[i + 0], xv[0]);\n  xv[1] = _mm256_loadu_ps(&x[i + 8]);\n  _mm256_storeu_ps(&y[i + 8], xv[1]);\n  xv[2] = _mm256_loadu_ps(&x[i + 16]);\n  _mm256_storeu_ps(&y[i + 16], xv[2]);\n  xv[3] = _mm256_loadu_ps(&x[i + 24]);\n  _mm256_storeu_ps(&y[i + 24], xv[3]);\n  xv[4] = _mm256_loadu_ps(&x[i + 32]);\n  _mm256_storeu_ps(&y[i + 32], xv[4]);\n  _mm_prefetch((const char *) (&x[i + 64]), _MM_HINT_T0);\n  xv[5] = _mm256_loadu_ps(&x[i + 40]);\n  _mm256_storeu_ps(&y[i + 40], xv[5]);\n  xv[6] = _mm256_loadu_ps(&x[i + 48]);\n  _mm256_storeu_ps(&y[i + 48], xv[6]);\n  xv[7] = _mm256_loadu_ps(&x[i + 56]);\n  _mm256_storeu_ps(&y[i + 56], xv[7]);\n  xv[8] = _mm256_loadu_ps(&x[i + 64]);\n  _mm256_storeu_ps(&y[i + 64], xv[8]);\n  xv[9] = _mm256_loadu_ps(&x[i + 72]);\n  _mm256_storeu_ps(&y[i + 72], xv[9]);\n  _mm_prefetch((const char *) (&x[i + 96]), _MM_HINT_T0);\n  xv[10] = _mm256_loadu_ps(&x[i + 80]);\n  _mm256_storeu_ps(&y[i + 80], xv[10]);\n  xv[11] = _mm256_loadu_ps(&x[i + 88]);\n  _mm256_storeu_ps(&y[i + 88], xv[11]);\n  xv[12] = _mm256_loadu_ps(&x[i + 96]);\n  _mm256_storeu_ps(&y[i + 96], xv[12]);\n  xv[13] = _mm256_loadu_ps(&x[i + 104]);\n  _mm256_storeu_ps(&y[i + 104], xv[13]);\n  xv[14] = _mm256_loadu_ps(&x[i + 112]);\n  _mm256_storeu_ps(&y[i + 112], xv[14]);\n  xv[15] = _mm256_loadu_ps(&x[i + 120]);\n  _mm256_storeu_ps(&y[i + 120], xv[15]);\n}\n",
        "pragma": ""
    },
    "bikashtudu/LU-Factorisation/LU_Parallel/18": {
        "code": "for (int i = 0; i < size; i++)\n  printf(\"x[%d]: %f\\n\", i, x[i]);\n",
        "pragma": ""
    },
    "billmats96/Parallel-and-Distributed-Systems/Project 2/src/mpi_threaded_blocking/4": {
        "code": "for (int j = 0; j < ((k * totalPoints) / processes); j++)\n  finDistances[j] = 1000000;\n",
        "pragma": ""
    },
    "biotrump/openmp-simd/openmpmflops/OpenMPMFLOPS/3": {
        "code": "for (i = 0; i < repeats; i++)\n{\n  if (part == 0)\n  {\n    triad(words, aval, xval, x_cpu);\n    opwd = 2;\n  }\n\n  if (part == 1)\n  {\n    triadplus(words, aval, bval, cval, dval, eval, fval, x_cpu);\n    opwd = 8;\n  }\n\n  if (part == 2)\n  {\n    triadplus2(words, aval, bval, cval, dval, eval, fval, gval, hval, jval, kval, lval, mval, oval, pval, qval, rval, sval, tval, uval, vval, wval, yval, x_cpu);\n    opwd = 32;\n  }\n\n}\n",
        "pragma": ""
    },
    "bkazi/lattice-boltzmann/d2q9-bgk/5": {
        "code": "for (int tt = 0; tt < maxIters; ++tt)\n{\n  float global_tot_vel;\n  MPI_Reduce(&reduction_buffer[tt], &global_tot_vel, 1, (MPI_Datatype) 0x4c00040a, (MPI_Op) 0x58000003, 0, cart_world);\n  if (rank == 0)\n  {\n    av_vels[tt] = global_tot_vel / ((float) tot_cells);\n  }\n\n}\n",
        "pragma": ""
    },
    "breiters/papi_omp_util/src/papi_util/6": {
        "code": "for (int i = 0; i < _num_formulas; i++)\n  destroy_formula(&_formulas[i]);\n",
        "pragma": ""
    },
    "bruno-braganca/gameOfLife_OpenMP/game_of_life/1": {
        "code": "for (linha = 0; linha < tamanhoTotal; linha++)\n{\n  matriz[linha] = (int *) malloc((sizeof(int)) * tamanhoTotal);\n  matrizResultado[linha] = (int *) malloc((sizeof(int)) * tamanhoTotal);\n}\n",
        "pragma": ""
    },
    "bsc-pm/mcxx/tests/07_phases_omp.dg/common/c/success_for_11/0": {
        "code": "for (i = 0; i < 100; i++)\n{\n  s = s + i;\n}\n",
        "pragma": "#pragma omp for reduction(+:s)"
    },
    "bsc-pm/mcxx/tests/07_phases_omp.dg/simd/mic/success_simd_33_parallel_convolv_overlap/6": {
        "code": "for (i = 0; i < H; i++)\n{\n  for (j = 0; j < W; j++)\n  {\n    if (output_image_sc[(i * W) + j] != output_image[(i * W) + j])\n    {\n      printf(\"Bad [%d][%d]: %d instead of %d\\n\", i, j, output_image[(i * W) + j], output_image_sc[(i * W) + j]);\n      status++;\n    }\n\n  }\n\n}\n",
        "pragma": ""
    },
    "bsc-pm/mcxx/tests/07_phases_omp.dg/simd/success_simd_03_parallel_saxpy/3": {
        "code": "for (i = 0; i < N; i++)\n{\n  if (z[i] != ((a * x[i]) + y[i]))\n  {\n    printf(\"Error\\n\");\n    return 1;\n  }\n\n}\n",
        "pragma": ""
    },
    "cart-pucminas/machine-learning/Apriori/AprioriOpenMP/AP/apriori/2": {
        "code": "for (int i = 0; i < it->num_itens; i++)\n{\n  for (int k = 0; (it->item[j] != ',') && (j < strlen(it->item)); k++, j++)\n  {\n    token[k] = it->item[j];\n  }\n\n  ++j;\n  if (strstr(line, token) != 0)\n  {\n    aux[i] = 1;\n  }\n\n}\n",
        "pragma": ""
    },
    "catamaro/CPD_Project/OpenMP/matFact-omp/5": {
        "code": "for (int i = 0; i < nF; i++)\n{\n  (*R)[i] = (double *) malloc((sizeof(double)) * nI);\n  (*newR)[i] = (double *) malloc((sizeof(double)) * nI);\n}\n",
        "pragma": "#pragma omp for"
    },
    "cegonse/Jacobi/src/mathsub/7": {
        "code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < m; j++)\n  {\n    C[i + (j * n)] = 0.0;\n    for (k = 0; k < m; k++)\n    {\n      C[i + (j * n)] += (alpha * A[i + (k * m)]) * B[k + (j * m)];\n    }\n\n  }\n\n}\n",
        "pragma": ""
    },
    "chamodi08jaya/Parallel-Computing/openMPmm/1": {
        "code": "for (i = 0; i < 2000; i++)\n  for (j = 0; j < 2000; j++)\n{\n  a[i][j] = 1 + ((int) ((70.0 * rand()) / (32767 + 1.0)));\n  b[i][j] = (double) (rand() % 5);\n}\n\n",
        "pragma": ""
    },
    "chaquator/chaq-sdfgen/openmp/df/2": {
        "code": "for (size_t q = offset + 1; q < w; ++q)\n{\n  if (isinf(img_row[q]))\n    continue;\n\n  float s = parabola_intersect(img_row, v[k], q);\n  while ((k > 0) && (s <= z[k - 1]))\n  {\n    --k;\n    s = parabola_intersect(img_row, v[k], q);\n  }\n\n  z[k] = s;\n  ++k;\n  v[k] = q;\n  h[k] = img_row[q];\n}\n",
        "pragma": ""
    },
    "charidimosv/parallel/src/mpi/src/heatconv/10": {
        "code": "for (currentRow = 2; currentRow < subProblemSize[0]; ++currentRow)\n{\n  splitter[0][tempCounter] = currentRow;\n  splitter[1][tempCounter++] = subProblemSize[1];\n}\n",
        "pragma": ""
    },
    "charlesxu90/Speedup-program-using-OpenMP-and-OpenACC-on-CUDA-and-Coprocessor/HW2/openmp/cs280hw2t1/cpu/src/driver/3": {
        "code": "for (k = 1; k < 5; k++)\n  courant += fabs(coef[k]) * 6;\n",
        "pragma": ""
    },
    "chenxuhao/gardenia/src/vecAdd/matmul_tiled/4": {
        "code": "for (i = 0; i < lDIM; ++i)\n  for (j = 0; j < nDIM; ++j)\n{\n  currentValue = (i * BSIZE) + 1;\n  for (k = 0; k < BSIZE; ++k, currentValue += 1)\n    for (y = 0; y < BSIZE; ++y)\n  {\n    if (((i == (lDIM - 1)) && (lDIM > perfectL)) && (k >= leftOutL))\n      tileB[(i * nDIM) + j][(k * BSIZE) + y] = 0.0;\n    else\n      if (((j == (nDIM - 1)) && (nDIM > perfectN)) && (y >= leftOutN))\n      tileB[(i * nDIM) + j][(k * BSIZE) + y] = 0.0;\n    else\n      tileB[(i * nDIM) + j][(k * BSIZE) + y] = 1.0 / currentValue;\n\n\n  }\n\n\n}\n\n",
        "pragma": ""
    },
    "chigbojk/CS922-High-Performance-Computing-Assignment-2/cfd/simulation/5": {
        "code": "for (i = iLeft; i <= iRight; i++)\n{\n  for (j = 1; j <= jmax; j++)\n  {\n    if (flag[i][j] & C_F)\n    {\n      p0 += p[i][j] * p[i][j];\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for schedule(static) private(i,j) reduction(+:p0)"
    },
    "clang-ykt/openmp/libomptarget/omptests/t-distribute-simd-dist-clauses/test/0": {
        "code": "for (int i = 0; i < 512; i++)\n  if (A[i] != 1)\n{\n  printf(\"Error at %d, h = %lf, d = %lf\\n\", i, (double) 1, A[i]);\n  fail = 1;\n}\n\n",
        "pragma": ""
    },
    "clang-ykt/openmp/libomptarget/omptests/t-target-enter-nowait/test/9": {
        "code": "for (i = 0; i < 1024; i++)\n{\n  if (a[i] != (i + 1))\n    printf(\"%d: a error %d != %d, error %d\\n\", i, a[i], i + 1, ++error);\n\n}\n",
        "pragma": ""
    },
    "cniethammer/openmp_validation_suite/src/c/omp_parallel_for/0": {
        "code": "for (i = 0; i < 1000; i++)\n{\n  data[i] = i;\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "compparalela/openmp/omp8/if/0": {
        "code": "for (i = 0; i < n; i++)\n  c[i] = a[i] + b[i];\n",
        "pragma": "#pragma omp for"
    },
    "cvetkovic/mups/dz1/z4/dosharpen/2": {
        "code": "for (i = 0; i < nx; i++)\n{\n  for (j = 0; j < ny; j++)\n  {\n    fuzzy[i][j] = 0;\n    sharp[i][j] = 0.0;\n  }\n\n}\n",
        "pragma": ""
    },
    "danidiaz1/AC-Arquitectura-de-Computadores-UGR-2015-2016/Practica3/src/pmtv-OpenMP/2": {
        "code": "for (f = 0; f < N; f++)\n  for (c = f; c < N; c++)\n  v2[f] += M[f][c] * v1[c];\n\n",
        "pragma": "#pragma omp parallel for schedule(runtime)"
    },
    "dankleying/openmp/openmp_example/test/1": {
        "code": "for (i = 0; i < (1048576 * 64); i++)\n{\n  A[i] = atoi(argv[1]) + i;\n}\n",
        "pragma": ""
    },
    "dasosjt/openMP/SudokuValidator/7": {
        "code": "for (int i = 0; i < 9; i++)\n{\n  check_column(i);\n  check_row(i);\n}\n",
        "pragma": ""
    },
    "davidjmstewart/ParallelNewmanModularity/benchmarking/dot_product/dot_product_benchmarking/2": {
        "code": "for (int m = 0; m < 8; m++)\n{\n  sequentialTimings[m] = 0;\n  for (int t = 0; t < 8; t++)\n  {\n    parallelTimings[m][t] = 0;\n  }\n\n}\n",
        "pragma": ""
    },
    "davidjmstewart/ParallelNewmanModularity/lib/CDUtils/10": {
        "code": "for (int i = 0; i < size; i++)\n{\n  for (int j = 0; j < size; j++)\n  {\n    fprintf(fp, \"%d\", A[(i * size) + j]);\n    if (j != (size - 1))\n    {\n      fwrite(\" \", sizeof(char), 1, fp);\n    }\n\n  }\n\n  fwrite(\"\\n\", sizeof(char), 1, fp);\n}\n",
        "pragma": ""
    },
    "dbsousa01/Game-of-Life3D/life3d-omp/life3d-omp/1": {
        "code": "for (x = 0; x < size; x++)\n{\n  for (y = 0; y < size; y++)\n  {\n    head = &cube[x][y];\n    while (((*head) != 0) && ((*head)->status == 0))\n    {\n      temp = *head;\n      *head = (*head)->next;\n      free(temp);\n    }\n\n    for (curr = *head; curr != 0; curr = curr->next)\n    {\n      while ((curr->next != 0) && (curr->next->status == 0))\n      {\n        temp = curr->next;\n        curr->next = temp->next;\n        free(temp);\n      }\n\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp for collapse(2) schedule(static)"
    },
    "ddsihongliang/ece_5720/hw2/hs983_hw2_openmp_sort_block/1": {
        "code": "for (k = 0; k < n_row; k++)\n{\n  int swap;\n  int cRow;\n  cRow = cur_pos;\n  swap = *((A + k) + (cRow * n_col));\n  *((A + (cRow * n_col)) + k) = *((A + (row_pos * n_col)) + k);\n  *((A + (row_pos * n_col)) + k) = swap;\n}\n",
        "pragma": ""
    },
    "denisrosas/openmp/radixsort/2": {
        "code": "for (i = 1; i < tamanho; i++)\n{\n  if (vetor[i] > maior)\n    maior = vetor[i];\n\n}\n",
        "pragma": ""
    },
    "derrickkarake/Lab-1-Openmp/main/0": {
        "code": "for (long long int toss = 0; toss < number_of_tosses; toss++)\n{\n  double x = getRand(&seed);\n  double y = getRand(&seed);\n  double distance_squared = (x * x) + (y * y);\n  if (distance_squared <= 1)\n    number_in_circle++;\n\n}\n",
        "pragma": "#pragma omp for reduction(+: number_in_circle)"
    },
    "dfordivam/perf-check/haskellWithOpenMP/omp_mm/0": {
        "code": "for (i = 0; i < 62; i++)\n{\n  for (j = 0; j < 7; j++)\n    for (k = 0; k < 15; k++)\n    c[i][j] += a[i][k] * b[k][j];\n\n\n}\n",
        "pragma": "#pragma omp for schedule (static, chunk)"
    },
    "dhawal777/Handwritten-Digit-Recoganization-by-ANN-in-openmp/nn/4": {
        "code": "for (int hn = 0; hn < previousLayer->numberOfNodes; ++hn)\n{\n  Node *previousLayerNode = &previousLayer->nodes[hn];\n  node->weights[hn] += (LEARNING_RATE * previousLayerNode->output) * backPropValue;\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "dimgrav/OpenMP/OMPFibon/1": {
        "code": "for (i = 2; i < N; i++)\n{\n  f[i] = Fibon(i);\n  printf(\"%5d\", f[i]);\n}\n",
        "pragma": ""
    },
    "dimitris21gr/Boruvka_and_Dijkstra_Parallel/openMP_boruvka/openMP_boruvka/3": {
        "code": "for (i = 0; i < gr->nodes; i++)\n{\n  unsigned int my_color = color[i];\n  unsigned int other_color = color[my_color];\n  if (my_color != other_color)\n  {\n    color[i] = other_color;\n    my_changed = 1;\n  }\n\n}\n",
        "pragma": "#pragma omp for"
    },
    "dimizisis/high-performance-computing/OpenMP/char_freq/char_freq_parallel_array_of_locks_global/1": {
        "code": "for (int i = 0; i < n; ++i)\n  omp_init_lock(&locks[i]);\n",
        "pragma": ""
    },
    "district10/tryopenmp/src/chapter4/fig4.47-barrier/2": {
        "code": "for (i = 0; i < n; i++)\n  printf(\" a[%3d] = %6d ref[%3d] = %6d\\n\", i, a[i], i, ref[i]);\n",
        "pragma": ""
    },
    "dkefalos/Spectral-Unmixing/MNF/25": {
        "code": "for (i = 0; i < (bands - 1); i++)\n{\n  free(R[i]);\n}\n",
        "pragma": ""
    },
    "dkefalos/Spectral-Unmixing/SEE-E/16": {
        "code": "for (i = 0; i < (2 * (nendmembers - 1)); i++)\n{\n  fprintf(report, \"%lf\\n\", sum[i]);\n}\n",
        "pragma": ""
    },
    "dlcheng/LTic/local_shape_transfer/5": {
        "code": "for (m = 0; m < np1; m++)\n{\n  fft_data_local[2 * m] = f[m][j][k].Re;\n  fft_data_local[(2 * m) + 1] = f[m][j][k].Im;\n}\n",
        "pragma": ""
    },
    "dvhh/massCorrelation/src/correlationOMP/2": {
        "code": "for (size_t j = i + 1; j < rows; j++)\n{\n  size_t baseY = j * cols;\n  float sumXY = 0.0;\n  for (size_t k = 0; k < cols; k++)\n  {\n    float a = vectors[baseX + k];\n    float b = vectors[baseY + k];\n    sumXY += a * b;\n  }\n\n  float sumY = preSum[j];\n  float s3 = preS23[j];\n  float s1 = (sumXY * fCols) - (sumX * sumY);\n  float s4 = sqrtf(s2 * s3);\n  float correlation = s1 / s4;\n  size_t index = getIndex(i, j, rows);\n  output[index] = correlation;\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "dxAdam/Parallel_Programming/Parallel_Poisson/openMP/poissonOMP/2": {
        "code": "for (int i = 0; i < N; i++)\n{\n  T[M * i] = source_function(X_MIN + (i * dx), Y_MIN);\n  T[((M * i) + M) - 1] = source_function(X_MIN + (i * dx), Y_MAX);\n}\n",
        "pragma": ""
    },
    "dylancornelie/openMP_TP/parallel/nn-main/0": {
        "code": "for (int j = 0; j < NUMHID; j++)\n{\n  SumH = 0.0;\n  for (int i = 0; i < NUMIN; i++)\n    SumH += tSet[p][i] * WeightIH[j][i];\n\n  Hidden[j] = 1.0 / (1.0 + exp(-SumH));\n}\n",
        "pragma": "#pragma omp for"
    },
    "dzarrr/Tugas-Sister-OpenMP/src/bitonic_sort/5": {
        "code": "for (k = 2; k <= paddedN; k = 2 * k)\n{\n  for (j = k >> 1; j > 0; j = j >> 1)\n  {\n    for (i = 0; i < paddedN; i++)\n    {\n      int ij = i ^ j;\n      if (ij > i)\n      {\n        if (((i & k) == 0) && (a[i] > a[ij]))\n          exchange(i, ij);\n\n        if (((i & k) != 0) && (a[i] < a[ij]))\n          exchange(i, ij);\n\n      }\n\n    }\n\n  }\n\n}\n",
        "pragma": ""
    },
    "ebardes/cluster/src/cluster/105": {
        "code": "for (i = 0; i < ncolumns; i++)\n{\n  double closest;\n  int ix;\n  int iy;\n  for (j = 0; j < ndata; j++)\n    celldatavector[j] = &celldata[ixbest][iybest][j];\n\n  closest = metric(ndata, data, celldatavector, mask, dummymask, weights, i, 0, transpose);\n  for (ix = 0; ix < nxgrid; ix++)\n  {\n    for (iy = 0; iy < nygrid; iy++)\n    {\n      double distance;\n      for (j = 0; j < ndata; j++)\n        celldatavector[j] = &celldata[ix][iy][j];\n\n      distance = metric(ndata, data, celldatavector, mask, dummymask, weights, i, 0, transpose);\n      if (distance < closest)\n      {\n        ixbest = ix;\n        iybest = iy;\n        closest = distance;\n      }\n\n    }\n\n  }\n\n  clusterid[i][0] = ixbest;\n  clusterid[i][1] = iybest;\n}\n",
        "pragma": ""
    },
    "ebardes/cluster/src/cluster/5": {
        "code": "for (k = i; k <= hi; k++)\n  xmin = min(xmin, x[k]);\n",
        "pragma": ""
    },
    "ebardes/cluster/src/cluster/55": {
        "code": "for (k = 0; k < ncolumns; k++)\n{\n  i = clusterid[k];\n  for (j = 0; j < nrows; j++)\n  {\n    if (mask[j][k] != 0)\n    {\n      cdata[j][i] += data[j][k];\n      cmask[j][i]++;\n    }\n\n  }\n\n}\n",
        "pragma": ""
    },
    "eduardlopez/swallow-water-simulation-parallel-multiprocessing/swater2D-omp/10": {
        "code": "for (i = 0, tmp = ((-dy) / 2) + 0.0; i < n; i++, tmp += dy)\n  y[i] = tmp;\n",
        "pragma": ""
    },
    "eduardnegru/Parallel-Odd-Even-Transposition-Sort/hybrid_omp/7": {
        "code": "for (i = 1; i < nrProcesses; i++)\n{\n  int sliceLength = arrayLength / (nrProcesses - 1);\n  MPI_Status status;\n  if (i == (nrProcesses - 1))\n  {\n    sliceLength = arrayLength - ((i - 1) * sliceLength);\n  }\n\n  int *receivedArray = (int *) calloc(sliceLength, sizeof(int));\n  MPI_Recv(receivedArray, sliceLength, (MPI_Datatype) 0x4c000405, i, 0, 1, &status);\n  join_arrays(sortedArray, receivedArray, sliceLength, currentOffset);\n  currentOffset += sliceLength;\n}\n",
        "pragma": ""
    },
    "ejhusom/IN3200/page_rank_partial_exam/src/PE_functions/7": {
        "code": "for (int edge = 0; edge < edge_count; edge++)\n{\n  col = from_node_id[edge];\n  row = to_node_id[edge];\n  elm_count[row]++;\n  idx = ((*row_ptr)[row] + elm_count[row]) - 1;\n  (*col_idx)[idx] = col;\n}\n",
        "pragma": ""
    },
    "ekloberdanz/ekblas/benchmark_double/3": {
        "code": "for (i = 0; i < n; i++)\n{\n  if (compare_floats(a[i], b[i]) == 0)\n  {\n    return 0;\n  }\n\n}\n",
        "pragma": ""
    },
    "elegaanz/MN-TP2/src/gemv/2": {
        "code": "for (int tmpi = 0; tmpi < M; tmpi++)\n{\n  res.real = 0;\n  res.imaginary = 0;\n  tmpj = 0;\n  while (tmpj < N)\n  {\n    res = add_complexe_float(res, mult_complexe_float(PA[(tmpi * M) + tmpj], PX[tmpj]));\n    tmpj++;\n  }\n\n  tmp[tmpi] = res;\n  tmpi++;\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "erdemegemarasli/Parallel-Computing-CS426-P3/main/0": {
        "code": "for (int i = 0; i < rowCount; i++)\n{\n  for (int j = row_ptr[i]; j < row_ptr[i + 1]; j++)\n    x[k + 1][i] += values[j] * x[k][col_ind[j]];\n\n}\n",
        "pragma": "#pragma omp parallel for schedule(static)"
    },
    "fabrizio-indirli/sobel-parallel/src/mpi_mode_0/2": {
        "code": "for (i = 0; i < image->n_images; i++)\n{\n  width = image->width[i];\n  height = image->height[i];\n  pixel *pi = p[i];\n  int rank = 0;\n  apply_gray_filter(width, height, pi);\n  apply_blur_filter(width, height, pi, 5, 20);\n  apply_sobel_filter(width, height, pi);\n}\n",
        "pragma": "#pragma omp for schedule(static,1)"
    },
    "felixarpa/PAR-Lab/boada/lab3/par2312-lab3/code/mandel-omp-taskloop-point/2": {
        "code": "for (int i = 1; i < argc; i++)\n{\n  if (strcmp(argv[i], \"-i\") == 0)\n  {\n    maxiter = atoi(argv[++i]);\n  }\n  else\n    if (strcmp(argv[i], \"-w\") == 0)\n  {\n    width = atoi(argv[++i]);\n    height = width;\n  }\n  else\n    if (strcmp(argv[i], \"-s\") == 0)\n  {\n    size = atof(argv[++i]);\n  }\n  else\n    if (strcmp(argv[i], \"-c\") == 0)\n  {\n    x0 = atof(argv[++i]);\n    y0 = atof(argv[++i]);\n  }\n  else\n  {\n    fprintf(stderr, \"Usage: %s [-o -i maxiter -w windowsize -c x0 y0 -s size]\\n\", argv[0]);\n    fprintf(stderr, \"\t   -o to write computed image to disk (default no file generated)\\n\");\n    fprintf(stderr, \"\t   -i to specify maximum number of iterations at each point (default 1000)\\n\");\n    fprintf(stderr, \"\t   -w to specify the size of the image to compute (default 800x800 elements)\\n\");\n    fprintf(stderr, \"\t   -c to specify the center x0+iy0 of the square to compute (default origin)\\n\");\n    fprintf(stderr, \"\t   -s to specify the size of the square to compute (default 2, i.e. size 4 by 4)\\n\");\n    return 1;\n  }\n\n\n\n\n}\n",
        "pragma": ""
    },
    "firehawk23/Parallel-Programming/Assignments/2/LA2/6": {
        "code": "for (i = 0; i < 500; i++)\n{\n  for (j = 0; j < 500; j++)\n  {\n    c4[i][j] = 0;\n  }\n\n}\n",
        "pragma": "#pragma omp for"
    },
    "gaengj/MD5BruteforceCracker/2-bruteforce-md5-openmp/bruteforce-md5-openmp/0": {
        "code": "for (int a = 0; a < 94; a++)\n{\n  byte password[4] = {33 + a};\n  byte *hashByteArray = StringHashToByteArray(\"f71dbe52628a3f83a77ab494817525c6\");\n  computeCombination(4, password, hashByteArray, 4);\n  free(hashByteArray);\n}\n",
        "pragma": "#pragma omp for"
    },
    "gapgag55/OpenMP-Excercise/3.MaxReductionClause/openmp/0": {
        "code": "for (i = 0; i < 100; i++)\n{\n  max = (A[i] > max) ? (A[i]) : (max);\n  printf(\"A[%d]: %d,\\tmax:%d\\n\", i, A[i], max);\n}\n",
        "pragma": "#pragma omp parallel for reduction(max:max)"
    },
    "gattazr-student/MN-openmp/src/matrb/3": {
        "code": "for (wI = 0; wI < BIGN_MATR; wI++)\n{\n  wSomme = 0;\n  for (wJ = 0; wJ < BIGN_MATR; wJ++)\n  {\n    wSomme = wSomme + (aMatr[wI][wJ] * aX[wJ]);\n  }\n\n  aResult[wI] = wSomme + aY[wI];\n}\n",
        "pragma": "#pragma omp for schedule(static)"
    },
    "gciotto/MO644/task10/mvt_parallel/14": {
        "code": "for (i = 0; i < 2048; i++)\n{\n  x1[i] = ((float) i) / 2048;\n  x2[i] = (((float) i) + 1) / 2048;\n  y1[i] = (((float) i) + 3) / 2048;\n  y2[i] = (((float) i) + 4) / 2048;\n  for (j = 0; j < 2048; j++)\n    A[(i * 2048) + j] = (((float) i) * j) / 2048;\n\n}\n",
        "pragma": ""
    },
    "gdimitriu/parallel_works/hpc-data/works/openmp_jr/jacobi_omp/2": {
        "code": "for (i = 1; i < dim; i++)\n{\n  temp = 0.0;\n  for (j = 0; j < dim; j++)\n    if (i != j)\n    temp += fabs(mat[i][j] / mat[i][i]);\n\n\n  if (sum_p[th] < temp)\n    sum_p[th] = temp;\n\n}\n",
        "pragma": "#pragma omp for private(temp,j)"
    },
    "gdimitriu/parallel_works/parallel_laboratory/parallel/cluster-system/openmp/reduction-omp-carte/1": {
        "code": "for (i = 0; i < 10; i++)\n  vec[i] = i;\n",
        "pragma": ""
    },
    "georgevangelou/parallel_programming_with_OpenMP/3. Travelling salesman problem/tsp_ant04/3": {
        "code": "for (int i = 0; i < SIZE; i++)\n{\n  printf(\"%3d  \", ARRAY[i]);\n}\n",
        "pragma": ""
    },
    "georgevangelou/parallel_programming_with_OpenMP/4. Neural networks/nn06/0": {
        "code": "for (int i = 0; i < neurons; i++)\n{\n  for (int j = 0; j < inputsNum; j++)\n  {\n    weightsDelta[(i * inputsNum) + j] += (0.3 * errors[i]) * inputs[j];\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for schedule(static, 10)"
    },
    "gioele-maruccia/parallel-K-means-openmp/src/second_implementation/0": {
        "code": "for (int i = 0; i < n; i++)\n{\n  lowerDist = m;\n  for (int ki = 0; ki < k; ki++)\n  {\n    getRow(centroids, ki, supCentroid, m);\n    getRow(dataset, i, supDataset, m);\n    dist = eucliDist(supCentroid, supDataset, m);\n    if (dist <= lowerDist)\n    {\n      lowerDist = dist;\n      salvaK = ki;\n    }\n\n  }\n\n  clusters[i][salvaK] = 1;\n}\n",
        "pragma": "#pragma omp parallel for schedule(static, chunkn) private(lowerDist, dist, salvaK, supCentroid, supDataset)"
    },
    "gjbex/training-material/LinuxTools/Checkpointing/Hybrid/pi/1": {
        "code": "for (i = 0; i < size; i++)\n{\n  limits[2 * i] = i * delta;\n  limits[(2 * i) + 1] += (i + 1) * delta;\n}\n",
        "pragma": ""
    },
    "gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Polybench/3MM/src/3mm/1": {
        "code": "for (i = 0; i < 512; i++)\n{\n  for (j = 0; j < 512; j++)\n  {\n    B[(i * 512) + j] = (((DATA_TYPE) i) * (j + 1)) / 512;\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Polybench/GESUMMV/src/gesummv/0": {
        "code": "for (i = 0; i < 8192; i++)\n{\n  tmp[i] = 0;\n  y[i] = 0;\n  for (j = 0; j < 8192; j++)\n  {\n    tmp[i] = (A[(i * 8192) + j] * x[j]) + tmp[i];\n    y[i] = (B[(i * 8192) + j] * x[j]) + y[i];\n  }\n\n  y[i] = (43532.0f * tmp[i]) + (12313.0f * y[i]);\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/mgBench/floyd/src/floyd_gpu/5": {
        "code": "for (i = 0; i < 400; i++)\n{\n  for (j = 0; j < 400; j++)\n  {\n    if (percentDiff(B[(i * 400) + j], B_GPU[(i * 400) + j]) > 0.05)\n    {\n      fail++;\n    }\n\n  }\n\n}\n",
        "pragma": ""
    },
    "glgerard/HeatedPlate2D/src/RedBlack_GaussSeidel/10": {
        "code": "for (i = 0; i < m; i++)\n  for (j = (i + 1) % 2; j < n; j += 2)\n{\n  black[i][j / 2] = u[i][j];\n}\n\n",
        "pragma": "#pragma omp for"
    },
    "gopal-panigrahi/parallel-programs/Mergesort_Serial_Parallel/3": {
        "code": "for (int i = low, j = low, k = mid + 1; i <= high; i++)\n{\n  if (j > mid)\n  {\n    aux[i] = array[k++];\n  }\n  else\n    if (k > high)\n  {\n    aux[i] = array[j++];\n  }\n  else\n    if (array[j] <= array[k])\n  {\n    aux[i] = array[j++];\n  }\n  else\n  {\n    aux[i] = array[k++];\n  }\n\n\n\n}\n",
        "pragma": ""
    },
    "gpsilva2003/OPENMP/src/omp_ordered/1": {
        "code": "for (i = 0; i < 5; i++)\n  teste2(i);\n",
        "pragma": "#pragma omp for ordered"
    },
    "grypp/NPB2.3-OpenMP-ACC/IS/is/15": {
        "code": "for (i = 0; i < ((1 << MAX_KEY_LOG_2) - 1); i++)\n  key_buff1[i + 1] += key_buff1[i];\n",
        "pragma": ""
    },
    "gustavopergola/ParalelMatrixMultiplier/OpenMP/main/0": {
        "code": "for (i = 0; i < rowsA; i++)\n{\n  for (j = 0; j < colsB; j++)\n  {\n    result[i][j] = 0;\n    for (k = 0; k < rowsB; k++)\n    {\n      result[i][j] = result[i][j] + (matrixA[i][k] * matrixB[k][j]);\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp for schedule(static)"
    },
    "gzachos/parallel-course-uoi/hw2/ex1/matmul_parallel_l0/2": {
        "code": "for (i = 0; i < n; i++, fprintf(fp, \"\\n\"))\n  for (j = 0; j < n; j++)\n  fprintf(fp, \" %d\", mat[(i * n) + j]);\n\n",
        "pragma": ""
    },
    "h3nnn4n/Parallel_Mandelbrot_set/src/main_openmp/1": {
        "code": "for (iy = 0; iy < config.screeny; iy++)\n{\n  for (ix = 0; ix < config.screenx; ix++)\n  {\n    bitmap[(iy * config.screenx) + ix].r = escapetime[(iy * config.screenx) + ix];\n    bitmap[(iy * config.screenx) + ix].g = escapetime[(iy * config.screenx) + ix];\n    bitmap[(iy * config.screenx) + ix].b = escapetime[(iy * config.screenx) + ix];\n  }\n\n}\n",
        "pragma": ""
    },
    "hannahGulle/Baby_BLAS/OMPSolvers/openmp/ils/1": {
        "code": "for (i = 0; i < N; i++)\n  *(x0 + i) = *(b + i);\n",
        "pragma": "#pragma omp for"
    },
    "hdelcampo/OpenMP-Samples/Lab4_OpenMP/Test1_Schedules/ejemplo2/0": {
        "code": "for (i = 0; i < 768; i++)\n  for (j = 0; j < 768; j++)\n{\n  int end = 0;\n  while (!end)\n  {\n    V[i][j] += 0.00001 + ((((0.0002 * ((double) i)) / 768) * ((double) j)) / 768);\n    if (V[i][j] > 1.0)\n      end = 1;\n\n  }\n\n}\n\n",
        "pragma": "#pragma omp parallel for shared(V) private(i,j) schedule(dynamic, 16)"
    },
    "hennimohammed/parallel_chess_engine/src/parallel_vs_parallel_with_reordering/1": {
        "code": "for (i = n - 1; i >= 0; i--)\n{\n  score2 = minmax_ab2(T[i], +1, niv - 1, alpha, score, nb_noeuds, nb_coupes);\n  if (score2 < score)\n    score = score2;\n\n  if (score < alpha)\n  {\n    *nb_coupes += 1;\n    return alpha;\n  }\n\n}\n",
        "pragma": ""
    },
    "hfinkel/openmp-bgq-old/runtime/test/atomic/omp_atomic/0": {
        "code": "for (j = 0; j < 20; ++j)\n{\n  dpt *= dt;\n}\n",
        "pragma": ""
    },
    "hfinkel/openmp-bgq-old/runtime/test/worksharing/for/omp_for_schedule_guided/4": {
        "code": "for (i = 0; i < 20; i++)\n{\n  if (!test_omp_for_schedule_guided())\n  {\n    num_failed++;\n  }\n\n}\n",
        "pragma": ""
    },
    "hfinkel/openmp-bgq/runtime/test/worksharing/for/bug_set_schedule_0/0": {
        "code": "for (i = 0; i < 20; i++)\n{\n  if (!test_set_schedule_0())\n  {\n    num_failed++;\n  }\n\n}\n",
        "pragma": ""
    },
    "hpc2n/OpenMP-Collaboration/Templates/Day_4/FirstTouch/SampleSolution/C/firstTouch_allparallel/0": {
        "code": "for (int i = 0; i < 500000000; i++)\n{\n  a[i] = 2.0 * ((double) i);\n  b[i] = 3.0 * ((double) i);\n  c[i] = (double) i;\n}\n",
        "pragma": "#pragma omp parallel for default(none) shared(a,b,c) schedule(static)"
    },
    "hughnatt/blas-library-openmp/src/exo/2": {
        "code": "for (i = 0; i < 8192; i = i + 8)\n{\n  dot += X[i] * Y[i];\n  dot += X[i + 1] * Y[i + 1];\n  dot += X[i + 2] * Y[i + 2];\n  dot += X[i + 3] * Y[i + 3];\n  dot += X[i + 4] * Y[i + 4];\n  dot += X[i + 5] * Y[i + 5];\n  dot += X[i + 6] * Y[i + 6];\n  dot += X[i + 7] * Y[i + 7];\n}\n",
        "pragma": "#pragma omp parallel for schedule(static) reduction(+ : dot)"
    },
    "huynguyen7/Distributed-Monte-Carlo-Pi/omp_pi/0": {
        "code": "for (i = 0; i < num_trials; ++i)\n{\n  x = get_random();\n  y = get_random();\n  if (((x * x) + (y * y)) <= 1.0)\n    num_points_circle++;\n\n}\n",
        "pragma": "#pragma omp parallel for private(i) firstprivate(x,y) reduction(+:num_points_circle)"
    },
    "hyejin97/GPU_programming_openmp-cuda/MatMul/matrixMul/2": {
        "code": "for (i = 0; i < n; ++i)\n{\n  for (j = 0; j < n; ++j)\n  {\n    B[(i * n) + j] = 2;\n  }\n\n}\n",
        "pragma": ""
    },
    "iPogot/Parallel-Programming/term_2/exp/prog/0": {
        "code": "for (int i = 1; i < 1000000000; i++)\n{\n  add[thread_num] = add[thread_num] / ((long double) i);\n  sum += add[thread_num];\n}\n",
        "pragma": "#pragma omp for"
    },
    "iakovts/openMP_set_2021_Tsouros/exe2/matmul_omp_tsouros/3": {
        "code": "for (i = 0; i < 768; i++)\n{\n  for (j = 0; j < 768; j++)\n  {\n    printf(\"%f \", c[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n",
        "pragma": ""
    },
    "ibrahim65432/GeneratingPrimeNumbers_using_OpenMP/genprimes/1": {
        "code": "for (int i = 2; i < N; i++)\n{\n  if (list[i] != (-1))\n  {\n    fprintf(fp, \"%d\\n\", i);\n  }\n\n}\n",
        "pragma": ""
    },
    "ilkoch008/OpenMP_tasks/task7/main/9": {
        "code": "for (int i = 0; i < HEIGHT; ++i)\n{\n  for (int j = 0; j < WIDTH; ++j)\n  {\n    temp = convert(field[i][j]);\n    SDL_SetRenderDrawColor(renderer, temp.r, temp.g, temp.b, 255);\n    SDL_RenderDrawPoint(renderer, j, i);\n  }\n\n}\n",
        "pragma": ""
    },
    "ivanbgd/Matrices-C/matrices_1d_openmp/10": {
        "code": "for (i = 0; i < ((int) n_rows_a); i++)\n{\n  for (k = 0; k < ((int) n_cols_b); k++)\n  {\n    data_t sum = 0.0;\n    for (j = 0; j < ((int) n_cols_a); j++)\n    {\n      sum += a[(i * n_cols_a) + j] * bt[(k * n_rows_b) + j];\n    }\n\n    c[(i * n_cols_b) + k] = sum;\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for default(none) private(i, j, k) shared(a, n_rows_a, n_cols_a, b, n_rows_b, n_cols_b, c, bt) schedule(static)"
    },
    "iyan22/Genetics/vparallel/gengrupos_p/1": {
        "code": "for (i = 0; i < NGRUPOS; i++)\n{\n  if (additions[i][NCAR] > 0)\n  {\n    for (j = 0; j < NCAR; j++)\n    {\n      newcent[i][j] = additions[i][j] / additions[i][NCAR];\n    }\n\n    discent = gendist(&newcent[i][0], &cent[i][0]);\n    if (discent > DELTA)\n    {\n      fin = 0;\n    }\n\n    for (j = 0; j < NCAR; j++)\n    {\n      cent[i][j] = newcent[i][j];\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp for private(i, j, discent) schedule(dynamic,2)"
    },
    "jaaasonwu/HeatDistribution/mpi_heat_distribution/2": {
        "code": "for (i = 1; i <= rows; i++)\n{\n  j = ((i % 2) == 0) ? (1) : (0);\n  for (; j < cols; j += 2)\n  {\n    if (data[(offset + i) - 1][j] == 0)\n    {\n      double left;\n      double right;\n      double up;\n      double down;\n      double diff;\n      double prev;\n      up = local_data[i - 1][j];\n      down = local_data[i + 1][j];\n      left = ((j - 1) < 0) ? (0) : (local_data[i][j - 1]);\n      right = ((j + 1) >= cols) ? (0) : (local_data[i][j + 1]);\n      prev = local_data[i][j];\n      local_data[i][j] = 0.25 * (((left + right) + up) + down);\n      diff = fabs(prev - local_data[i][j]);\n      if (diff > max_black)\n      {\n        max_black = diff;\n      }\n\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for shared (data,local_data) private (i, j) reduction(max: max_black)"
    },
    "jacob-lidman/rose/projects/OpenMP_Translator/tests/cvalidationsuite/for_reduction/0": {
        "code": "for (i = 1; i <= 1000; i++)\n{\n  sum = sum + i;\n}\n",
        "pragma": "#pragma omp for schedule(dynamic,1) reduction(+:sum)"
    },
    "jacob-lidman/rose/projects/OpenMP_Translator/tests/developmentTests/inputBug342/0": {
        "code": "for (i = 0; i < 10; i++)\n  j = 0;\n",
        "pragma": "#pragma omp for"
    },
    "jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/BT/bt/24": {
        "code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((u[i - 2][j][k][m] - (4.0 * u[i - 1][j][k][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i + 1][j][k][m])));\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp for nowait"
    },
    "jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/CG/cg/11": {
        "code": "for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n{\n  rho = rho + (r[j] * r[j]);\n}\n",
        "pragma": "#pragma omp for reduction(+:rho)"
    },
    "jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/IS/is/2": {
        "code": "for (i = 1; i <= 46; i++)\n{\n  R46 = 0.50 * R46;\n  T46 = 2.0 * T46;\n}\n",
        "pragma": ""
    },
    "jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/IS/is/52": {
        "code": "for (i = 1; i < (1 << TOTAL_KEYS_LOG_2); i++)\n  if (key_array[i - 1] > key_array[i])\n  j++;\n\n",
        "pragma": ""
    },
    "jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/LU/lu/37": {
        "code": "for (i = ibeg; i <= ifin1; i++)\n{\n  for (j = jbeg; j <= jfin1; j++)\n  {\n    frc1 = frc1 + (((((((phi1[i][j] + phi1[i + 1][j]) + phi1[i][j + 1]) + phi1[i + 1][j + 1]) + phi2[i][j]) + phi2[i + 1][j]) + phi2[i][j + 1]) + phi2[i + 1][j + 1]);\n  }\n\n}\n",
        "pragma": ""
    },
    "jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/4": {
        "code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  lhs[0][i][j][k] = 0.0;\n  lhs[1][i][j][k] = ((-dttx2) * cv[i - 1]) - (dttx1 * rhon[i - 1]);\n  lhs[2][i][j][k] = 1.0 + (c2dttx1 * rhon[i]);\n  lhs[3][i][j][k] = (dttx2 * cv[i + 1]) - (dttx1 * rhon[i + 1]);\n  lhs[4][i][j][k] = 0.0;\n}\n",
        "pragma": "#pragma omp for"
    },
    "jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/54": {
        "code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    fac1 = 1. / lhs[n + 2][i][j][k];\n    lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n    lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n    for (m = 0; m < 3; m++)\n    {\n      rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n    }\n\n    lhs[n + 2][i][j1][k] = lhs[n + 2][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 3][i][j][k]);\n    lhs[n + 3][i][j1][k] = lhs[n + 3][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 4][i][j][k]);\n    for (m = 0; m < 3; m++)\n    {\n      rhs[m][i][j1][k] = rhs[m][i][j1][k] - (lhs[n + 1][i][j1][k] * rhs[m][i][j][k]);\n    }\n\n    lhs[n + 1][i][j2][k] = lhs[n + 1][i][j2][k] - (lhs[n + 0][i][j2][k] * lhs[n + 3][i][j][k]);\n    lhs[n + 2][i][j2][k] = lhs[n + 2][i][j2][k] - (lhs[n + 0][i][j2][k] * lhs[n + 4][i][j][k]);\n    for (m = 0; m < 3; m++)\n    {\n      rhs[m][i][j2][k] = rhs[m][i][j2][k] - (lhs[n + 0][i][j2][k] * rhs[m][i][j][k]);\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp for"
    },
    "jacob-lidman/rose/tests/CompileTests/OpenMP_tests/cvalidation/omp_pragma_example2/1": {
        "code": "for (i = 0; i < 10; i++)\n  m++;\n",
        "pragma": ""
    },
    "jacob-lidman/rose/tests/CompileTests/OpenMP_tests/lockarray/3": {
        "code": "for (i = 0; i < 5000; i++)\n  a[i] = 0;\n",
        "pragma": ""
    },
    "jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/XSBench/GridInit/0": {
        "code": "for (int i = 0; i < (n_isotopes * n_gridpoints); i++)\n{\n  double quarry = energy_grid[i].energy;\n  if (((1 && (mype == 0)) && (omp_get_thread_num() == 0)) && ((i % 200) == 0))\n    printf(\"\\rAligning Unionized Grid...(%.0lf%% complete)\", (100.0 * ((double) i)) / ((n_isotopes * n_gridpoints) / omp_get_num_threads()));\n\n  for (int j = 0; j < n_isotopes; j++)\n  {\n    energy_grid[i].xs_ptrs[j] = binary_search(nuclide_grids[j], quarry, n_gridpoints);\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for default(none) shared( energy_grid, nuclide_grids, n_isotopes, n_gridpoints, mype )"
    },
    "jandres742/omp2cd/darts-x86/omp2cd-examples/tests/ompcodeletclause-test/ompcodeletclause/4": {
        "code": "for (i = 0; i < NUM_THREADS; i++)\n{\n  outVector[i] += parallelSum;\n}\n",
        "pragma": ""
    },
    "jar-evans/Krylov_subspace_methods/c_openmp/libeig_pair/2": {
        "code": "for (i = 0; i < N; i++)\n{\n  x[i] = 0;\n}\n",
        "pragma": ""
    },
    "javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/144": {
        "code": "for (j = 1; j < (((L / NODESY) + 2) - 1); j++)\n{\n  i = 0;\n  ii = ((((i + j) % 2) * ((L / NODESX) + 2)) + i) / 2;\n  if (ii < (((L / NODESX) + 2) / 2))\n    whites[ii][j].data = grn[j];\n  else\n    blacks[ii - (((L / NODESX) + 2) / 2)][j].data = grn[j];\n\n  i = ((L / NODESX) + 2) - 1;\n  ii = ((((i + j) % 2) * ((L / NODESX) + 2)) + i) / 2;\n  if (ii < (((L / NODESX) + 2) / 2))\n    whites[ii][j].data = grs[j];\n  else\n    blacks[ii - (((L / NODESX) + 2) / 2)][j].data = grs[j];\n\n}\n",
        "pragma": ""
    },
    "javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/44": {
        "code": "for (i = 1; i < (((L / 1) + 2) - 1); i++)\n{\n  j = ((L / 5) + 2) - 1;\n  ii = ((((i + j) % 2) * ((L / 1) + 2)) + i) / 2;\n  if (ii < (((L / 1) + 2) / 2))\n    whites[ii][j].data = gre[i];\n  else\n    blacks[ii - (((L / 1) + 2) / 2)][j].data = gre[i];\n\n  j = 0;\n  ii = ((((i + j) % 2) * ((L / 1) + 2)) + i) / 2;\n  if (ii < (((L / 1) + 2) / 2))\n    whites[ii][j].data = gro[i];\n  else\n    blacks[ii - (((L / 1) + 2) / 2)][j].data = gro[i];\n\n}\n",
        "pragma": ""
    },
    "javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/94": {
        "code": "for (unsigned int i = 0; i < (((L / 1) + 2) / 2); i++)\n{\n  int h_before;\n  int h_after;\n  int delta_E;\n  byte spin_old;\n  byte spin_new;\n  byte spin_neigh_x;\n  byte spin_neigh_y;\n  byte spin_neigh_z;\n  byte spin_neigh_w;\n  for (unsigned int j = 0; j < ((L / NODESY) + 2); j++)\n  {\n    if (write[i][j].isGhost == 1)\n    {\n      spin_old = write[i][j].data;\n      spin_neigh_x = read[i][j].data;\n      spin_neigh_y = read[i][j + 1].data;\n      spin_neigh_z = read[i][j - 1].data;\n      spin_neigh_w = read[i + ((2 * (color ^ (j % 2))) - 1)][j].data;\n      h_before = (((-(spin_old == spin_neigh_x)) - (spin_old == spin_neigh_y)) - (spin_old == spin_neigh_z)) - (spin_old == spin_neigh_w);\n      spin_new = (spin_old + ((byte) (1 + (rand_MWC_co(&x_l, &a_l) * (Q - 1))))) % Q;\n      h_after = (((-(spin_new == spin_neigh_x)) - (spin_new == spin_neigh_y)) - (spin_new == spin_neigh_z)) - (spin_new == spin_neigh_w);\n      delta_E = h_after - h_before;\n      float p = rand_MWC_co(&x_l, &a_l);\n      if ((delta_E <= 0) || (p <= table_expf_temp[delta_E]))\n      {\n        write[i][j].data = spin_new;\n      }\n\n    }\n    else\n    {\n      continue;\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp for schedule(static, CHUNKSIZE)"
    },
    "javiercba/potts_tesis_javier_uranga_2012/potts_OpenMP/potts3-cpu-OMP/45": {
        "code": "for (index = 0, temp = min; (modifier * temp) <= (modifier * max); index++, temp += step)\n{\n  for (unsigned int j = 0; j < TRAN; j++)\n  {\n    update(temp, whites, blacks);\n  }\n\n  unsigned int measurments = 0;\n  double e = 0.0;\n  double e2 = 0.0;\n  double e4 = 0.0;\n  double m = 0.0;\n  double m2 = 0.0;\n  double m4 = 0.0;\n  for (unsigned int j = 0; j < TMAX; j++)\n  {\n    update(temp, whites, blacks);\n    if ((j % calc_step) == 0)\n    {\n      double energy = 0.0;\n      double mag = 0.0;\n      unsigned int M_max = 0;\n      energy = calculateKernel(whites, blacks, &M_max);\n      mag = (((9 * M_max) / (1.0 * (L * L))) - 1) / ((double) (9 - 1));\n      e += energy;\n      e2 += energy * energy;\n      e4 += ((energy * energy) * energy) * energy;\n      m += mag;\n      m2 += mag * mag;\n      m4 += ((mag * mag) * mag) * mag;\n      measurments++;\n    }\n\n  }\n\n  assert(index < (1 + ((int) ((TEMP_MAX - TEMP_MIN) / 0.00005))));\n  stats[index].t = temp;\n  stats[index].e += e / measurments;\n  stats[index].e2 += e2 / measurments;\n  stats[index].e4 += e4 / measurments;\n  stats[index].m += m / measurments;\n  stats[index].m2 += m2 / measurments;\n  stats[index].m4 += m4 / measurments;\n}\n",
        "pragma": ""
    },
    "jb25/openmp-mpi/cracker_final/0": {
        "code": "for (i = 0; i < keyspace; ++i)\n{\n  if (found == 0)\n  {\n    strcpy(candidate, \"\");\n    for (j = max - 1; j >= 0; --j)\n    {\n      index[j] = (i / ((int) pow(strlen(alpha), j))) % strlen(alpha);\n      sprintf(candidate, \"%s%c\", candidate, alpha[index[j]]);\n    }\n\n    sprintf(str, \"%lu\", compute_hash(candidate));\n    if (strcmp(str, secret) == 0)\n    {\n      printf(\"Secret found: **%s**\\n\", candidate);\n      found = 1;\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for private(i, j, candidate, str) shared(found)"
    },
    "jbreitbart/OpenMP-GASPI-MicroBenchmark-Suite/collective_scatterGather/2": {
        "code": "for (i = 0; i < sizeofBuffer; i++)\n{\n  testBuf[i] = startVal + i;\n}\n",
        "pragma": ""
    },
    "jhoncabanilla/Pr-ctica-OpenMP/src/mejor/7": {
        "code": "for (i = 0; i < 3; i++)\n{\n  random_seq[i] = (unsigned short) atoi(argv[8 + i]);\n}\n",
        "pragma": ""
    },
    "jhuber6/cgo2022-artifacts/XSBench/openmp-offload/Simulation/1": {
        "code": "for (int i = 0; i < in.lookups; i++)\n  validation_hash += verification[i];\n",
        "pragma": ""
    },
    "jiangmoquan/OpenMP-Parallel-Programming-Assignment-/histogram/histo_atomic/7": {
        "code": "for (i = rowmax; i < image->row; i++)\n  for (j = 0; j < image->col; j++)\n  output->content[i][j] = image->content[i][j];\n\n",
        "pragma": ""
    },
    "jiawen11/OpenCL-OpenMP-Cuda-and-Rodinia/offomp/runtime/homp_dev/7": {
        "code": "for (i = 0; i < num_nvgpu_dev; i++)\n  gpu_selection[i] = 1;\n",
        "pragma": ""
    },
    "jing2018/OpenMP-programming-in-C/parallel_for_example/0": {
        "code": "for (index = 0; index < 10; index++)\n{\n  printf(\"Hello world. I am %d of %d\\n\", omp_get_thread_num(), omp_get_num_threads());\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "jkrishnavs/OpenMPGraphAlgorithms/src/train10/0": {
        "code": "for (node_t t = 0; t < G->numNodes; t++)\n{\n  aed[t] = t / 1024;\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "joao-lima/CoMD/src-omp-task-deps/initAtoms/0": {
        "code": "for (int iBox = 0; iBox < s->boxes->nLocalBoxes; ++iBox)\n{\n  for (int iOff = MAXATOMS * iBox, ii = 0; ii < s->boxes->nAtoms[iBox]; ++ii, ++iOff)\n  {\n    int iSpecies = s->atoms->iSpecies[iOff];\n    real_t mass = s->species[iSpecies].mass;\n    s->atoms->p[iOff][0] += mass * vShift[0];\n    s->atoms->p[iOff][1] += mass * vShift[1];\n    s->atoms->p[iOff][2] += mass * vShift[2];\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "joao-lima/bots-omp4/omp-tasks/alignment/alignment_for/alignment/13": {
        "code": "for (j = N - 1; j >= 0; j--)\n{\n  RR[j] = (t = t - gh);\n  SS[j] = t - g;\n}\n",
        "pragma": ""
    },
    "joaopalet/matFact-CPD/openmp/matFact-omp/1": {
        "code": "for (int i = 0; i < max; i++)\n  for (int j = 0; j < nFeatures; j++)\n{\n  if (i < nUsers)\n  {\n    L[i][j] -= privLsum[nt][i][j];\n    privLsum[nt][i][j] = 0;\n  }\n\n  if (i < nItems)\n  {\n    RT[i][j] -= privRTsum[nt][i][j];\n    privRTsum[nt][i][j] = 0;\n  }\n\n}\n\n",
        "pragma": "#pragma omp for"
    },
    "joewledger/Parallel_K_Medoids/Final_Report/k_medoids/4": {
        "code": "for (i = 0; i < k; i++)\n{\n  buffer[i] = i;\n  buffer_values[i] = v_scores[i];\n}\n",
        "pragma": ""
    },
    "joewledger/Parallel_K_Medoids/Final_Report/k_medoids/54": {
        "code": "for (i = 0; i < 150; i++)\n{\n  matrix[i] = malloc(150 * (sizeof(double)));\n  for (j = 0; j < 150; j++)\n  {\n    matrix[i][j] = distance(datapoints[i], datapoints[j]);\n  }\n\n}\n",
        "pragma": ""
    },
    "johnboulder/PSU-CMPSC450-Parallel-Programming/omp/sum_omp/2": {
        "code": "for (i = 0; i < n; i++)\n{\n  part_sums[tid] += A[i];\n}\n",
        "pragma": "#pragma omp for private(i)"
    },
    "josemonsalve2/openmp_microbench/benchmarks/NAS_SHOC_OpenACC_2.5/NAS-OMP-OFFLOADING/LU-HP/erhs/21": {
        "code": "for (j = jst; j <= jend; j++)\n{\n  for (i = ist; i <= iend; i++)\n  {\n    for (k = 3; k < (nz - 3); k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        frct[m][k][j][i] = frct[m][k][j][i] - (dssp * ((((rsd[m][k - 2][j][i] - (4.0 * rsd[m][k - 1][j][i])) + (6.0 * rsd[m][k][j][i])) - (4.0 * rsd[m][k + 1][j][i])) + rsd[m][k + 2][j][i]));\n      }\n\n    }\n\n  }\n\n}\n",
        "pragma": ""
    },
    "josemonsalve2/openmp_microbench/benchmarks/NAS_SHOC_OpenACC_2.5/NAS-OMP-OFFLOADING/MG/mg/17": {
        "code": "for (i2 = 1; i2 < (n2 - 1); i2++)\n{\n  for (i1 = 1; i1 < (n1 - 1); i1++)\n  {\n    s = s + pow(or[(((i3 * n2) * n1) + (i2 * n1)) + i1], 2.0);\n    a = fabs(or[(((i3 * n2) * n1) + (i2 * n1)) + i1]);\n    temp = max(temp, a);\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for reduction(+:s) reduction(max:temp) private(i2,i1) collapse(2)"
    },
    "josephbieselin/Primes-OpenMP/parallel/genprime/3": {
        "code": "for (i = 2; i <= N; ++i)\n{\n  if (nums[i] != 0)\n  {\n    curr_num = i;\n    fprintf(fp, \"%d, %d, %d\\n\", rank++, curr_num, curr_num - prev_num);\n    prev_num = curr_num;\n  }\n\n}\n",
        "pragma": ""
    },
    "josephmcl/labyrinth-openmp/omp/6": {
        "code": "for (i = 0; i < h->Length; ++i)\n{\n  if (Priority >= h->Links[i].V)\n    Location = i;\n\n}\n",
        "pragma": ""
    },
    "josthoma/Distributed-Quantum-Computing/QuEST/testCode/eceBenchmark_0812/0": {
        "code": "for (index = 0; index < stateVecSize; index++)\n{\n  bit1 = extractBit_copy(idQubit1, index + (chunkId * chunkSize));\n  bit2 = extractBit_copy(idQubit2, index + (chunkId * chunkSize));\n  if (bit1 && bit2)\n  {\n    stateVecReal[index] = -stateVecReal[index];\n    stateVecImag[index] = -stateVecImag[index];\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for default (none) shared (stateVecSize, stateVecReal,stateVecImag ) private (index,bit1,bit2) schedule (static)"
    },
    "jrk/QuakeTM/server/sv_phys/0": {
        "code": "for (i = 0; i < 3; i++)\n{\n  if (IS_NAN(ent->v.velocity[i]))\n  {\n    Con_Printf(\"Got a NaN velocity on %s\\n\", PR_GetString(ent->v.classname));\n    ent->v.velocity[i] = 0;\n  }\n\n  if (IS_NAN(ent->v.origin[i]))\n  {\n    Con_Printf(\"Got a NaN origin on %s\\n\", PR_GetString(ent->v.classname));\n    ent->v.origin[i] = 0;\n  }\n\n  if (ent->v.velocity[i] > sv_maxvelocity.value)\n    ent->v.velocity[i] = sv_maxvelocity.value;\n  else\n    if (ent->v.velocity[i] < (-sv_maxvelocity.value))\n    ent->v.velocity[i] = -sv_maxvelocity.value;\n\n\n}\n",
        "pragma": ""
    },
    "jsbruglie/cpd/omp/par_grid_hash/par_grid_hash/3": {
        "code": "for (i = 0; i < cube_size; i++)\n{\n  for (j = 0; j < cube_size; j++)\n  {\n    omp_destroy_lock(&graph_lock[i][j]);\n  }\n\n}\n",
        "pragma": ""
    },
    "juanca-rf/Arquitectura-de-Computadores---OpenMP/BP3/ejer6/schedule-clauseModificado5/0": {
        "code": "for (i = 0; i < n; i++)\n{\n  if (i == 0)\n  {\n    printf(\"\\n_______________________________________________________________\\n\");\n    printf(\"\\nAntes del cambio DENTRO PARALLEL:\");\n    printf(\"\\n\\tdyn-var: %d\", omp_get_dynamic());\n    printf(\"\\n\\tnthreads-var: %d\", omp_get_max_threads());\n    omp_get_schedule(&kind, &modifier);\n    switch (kind)\n    {\n      case omp_sched_dynamic:\n        strcpy(ckind, \"dinamico\");\n        break;\n\n      case omp_sched_static:\n        strcpy(ckind, \"estatico\");\n        break;\n\n      case omp_sched_guided:\n        strcpy(ckind, \"guided\");\n        break;\n\n      case omp_sched_auto:\n        strcpy(ckind, \"auto\");\n        break;\n\n    }\n\n    printf(\"\\n\\trun-sched-var: %s\\n\", ckind);\n    omp_set_dynamic(1);\n    omp_set_num_threads(4);\n    kind = omp_sched_static;\n    omp_set_schedule(kind, modifier);\n    printf(\"\\n_______________________________________________________________\\n\");\n    printf(\"\\nDESPUES del cambio DENTRO PARALLEL:\");\n    printf(\"\\n\\tdyn-var: %d\", omp_get_dynamic());\n    printf(\"\\n\\tnthreads-var: %d\", omp_get_max_threads());\n    omp_get_schedule(&kind, &modifier);\n    switch (kind)\n    {\n      case omp_sched_dynamic:\n        strcpy(ckind, \"dinamico\");\n        break;\n\n      case omp_sched_static:\n        strcpy(ckind, \"estatico\");\n        break;\n\n      case omp_sched_guided:\n        strcpy(ckind, \"guided\");\n        break;\n\n      case omp_sched_auto:\n        strcpy(ckind, \"auto\");\n        break;\n\n    }\n\n    printf(\"\\n\\trun-sched-var: %s\\n\", ckind);\n    printf(\"\\n_______________________________________________________________\\n\");\n  }\n\n  suma = suma + a[i];\n  printf(\" thread %d suma a[%d] suma=%d \\n\", omp_get_thread_num(), i, suma);\n}\n",
        "pragma": "#pragma omp parallel for firstprivate(suma) lastprivate(suma) schedule(dynamic, chunk)"
    },
    "juandapradam12/JuanPrada_Ejercicio30/walkOPEN/0": {
        "code": "for (i = 0; i < n_walkers; i++)\n{\n  A[i] = walk(10.0, i);\n}\n",
        "pragma": "#pragma omp parallel for shared(A)"
    },
    "juliennelachance/apc524_hw4/heat_omp/2": {
        "code": "for (i = 0; i < nx; i++)\n{\n  heatgrid[0][0][i] = (heatgrid[1][0][i] = pow(cos(i * dx), 2));\n  heatgrid[0][nx - 1][i] = (heatgrid[1][nx - 1][i] = pow(sin(i * dx), 2));\n}\n",
        "pragma": "#pragma omp parallel for shared(heatgrid) private(i)"
    },
    "junstar92/parallel_programming_study/OpenMP/12_omp_mat_vec_mul/1": {
        "code": "for (int i = 0; i < m; i++)\n  for (int j = 0; j < n; j++)\n  mat[(i * n) + j] = (rand() % RMAX) / (RMAX / 10.0);\n\n",
        "pragma": ""
    },
    "kandasamy73/ECEC413/omp/code_examples/Simple OpenMP programs/omp_synchronization_constructs/0": {
        "code": "for (i = 0; i < num_elements; i++)\n{\n  local_sum += vector_a[i] * vector_b[i];\n}\n",
        "pragma": "#pragma omp for"
    },
    "kang235/OpenMP/TestParallelFor/0": {
        "code": "for (i = 0; i < 10000; ++i)\n{\n  counters[tid]++;\n}\n",
        "pragma": ""
    },
    "kapferer/tycho_cfd/tycho_release_v1.3.0/sources/copy_arrays_for_viscosity/0": {
        "code": "for (j = 0; j < y; j++)\n{\n  for (k = 0; k < z; k++)\n  {\n    rho_visc[i][j][k] = rho[i][j][k];\n    vx_visc[i][j][k] = vx[i][j][k];\n    vy_visc[i][j][k] = vy[i][j][k];\n    vz_visc[i][j][k] = vz[i][j][k];\n  }\n\n}\n",
        "pragma": "#pragma omp for schedule(static)"
    },
    "khaled3ttia/openmp-accessors/include/Accessor_c/ex/0": {
        "code": "for (int i = 0; i < 10; i++)\n{\n  ac_z.data[i] = ac_x.data[i] + ac_y.data[i];\n}\n",
        "pragma": "#pragma omp target teams distribute parallel for"
    },
    "kirillston/OpenMP-MPI/mpp/matop/2": {
        "code": "for (int i = 0; i < dim; i++)\n{\n  for (int j = 0; j < dim; j++)\n  {\n    self_mat[(i * dim) + j] = ((1 - a) * self_mat[(i * dim) + j]) + (a * mat[(i * dim) + j]);\n  }\n\n}\n",
        "pragma": ""
    },
    "kjisu96/OpenMP_examples/04_Reduction/04_Reduction/0": {
        "code": "for (i = 0; i < 1000; i++)\n{\n  sum += Data[i];\n}\n",
        "pragma": "#pragma omp parallel for reduction(+:sum)"
    },
    "kkasfikis/Smith-Waterman-/myProj_OMP_FG/3": {
        "code": "for (i = 0; i <= q_len; i++)\n{\n  array[i] = malloc((sizeof(int)) * (d_len + 1));\n}\n",
        "pragma": ""
    },
    "klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/loop-11/1": {
        "code": "for (p = &buf[3]; (&buf[63]) >= p; p += 2)\n  p[-2] = 6;\n",
        "pragma": "#pragma omp parallel for"
    },
    "klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/omp-loop01/6": {
        "code": "for (i = N1; i <= N2; i += step)\n  if (a[i] != b[i])\n  abort();\n\n",
        "pragma": ""
    },
    "klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/pr42029/0": {
        "code": "for (i = 0; i < 8; ++i)\n  c += 1;\n",
        "pragma": "#pragma omp parallel for private(i) reduction(+:c)"
    },
    "konfou/openmp-course-sols/c/ex4-matrix-multi-openmp/1": {
        "code": "for (i = 0; i < (n * n); ++i)\n  A[i] = (B[i] = i % 100);\n",
        "pragma": ""
    },
    "kt9302/ImageConvolution/part2/3": {
        "code": "for (int x = data_size_X - kern_cent_X; x < data_size_X; x++)\n{\n  for (int y = 0; y < kern_cent_Y; y++)\n  {\n    for (int j = -y; j <= kern_cent_Y; j++)\n    {\n      for (int i = -kern_cent_X; i <= ((data_size_X - 1) - x); i++)\n      {\n        out[x + (y * data_size_X)] += kernel[(kern_cent_X - i) + ((kern_cent_Y - j) * 3)] * in[(x + i) + ((y + j) * data_size_X)];\n      }\n\n    }\n\n  }\n\n  for (int y = data_size_Y - kern_cent_Y; y < data_size_Y; y++)\n  {\n    for (int j = -kern_cent_Y; j <= ((data_size_Y - 1) - y); j++)\n    {\n      for (int i = -kern_cent_X; i <= ((data_size_X - 1) - x); i++)\n      {\n        out[x + (y * data_size_X)] += kernel[(kern_cent_X - i) + ((kern_cent_Y - j) * 3)] * in[(x + i) + ((y + j) * data_size_X)];\n      }\n\n    }\n\n  }\n\n}\n",
        "pragma": ""
    },
    "kuanweih/XSEDE-HPC-Workshop/Exercises-my/OpenMP/Examples/laplace_parallel_region/0": {
        "code": "for (i = 1; i <= 1000; i++)\n{\n  for (j = 1; j <= 1000; j++)\n  {\n    t[i][j] = 0.25 * (((t_old[i + 1][j] + t_old[i - 1][j]) + t_old[i][j + 1]) + t_old[i][j - 1]);\n  }\n\n}\n",
        "pragma": "#pragma omp for"
    },
    "kylexu1005/Parallel-Binary-Search/pbsearch/4": {
        "code": "for (i = 0; i < npm; i++)\n  value[i] = (rank * (npm + 1)) + i;\n",
        "pragma": ""
    },
    "lapesd/libgomp/src/libgomp/testsuite/libgomp.c/loop-13/6": {
        "code": "for (j = 0; j < 4; j++)\n  for (i = ju; i < ku; i++)\n  for (k = 0; k < 5; k += 2)\n  l++;\n\n\n",
        "pragma": "#pragma omp for reduction(+: l) collapse(3)"
    },
    "lapesd/libgomp/src/libgomp/testsuite/libgomp.c/target-2/3": {
        "code": "for (i = 0; i < x; i++)\n  if (((b[i] != (i + 0.5)) || (c[i] != (0.5 - i))) || (d[x + i] != (0.5 * i)))\n  abort();\n\n",
        "pragma": ""
    },
    "larry-han-au/OpenMp-and-MPI/Project1A/dijkstra_f/4": {
        "code": "for (i = 1; i < nv; i++)\n  printf(\"%u\\n\", mind[i]);\n",
        "pragma": ""
    },
    "lazzati-astro/MCRaT/OLDER_MCRaT_VERSIONS/HYBRID_PARALLEL/mclib/11": {
        "code": "for (i = 0; i < array_length; i++)\n{\n  if (((((*(r + i)) >= rmin) && ((*(r + i)) < rmax)) && ((*(theta + i)) < theta_max)) && ((*(theta + i)) >= theta_min))\n  {\n    for (j = 0; j < (*(ph_dens + k)); j++)\n    {\n      y_dum = 1;\n      yfr_dum = 0;\n      while (y_dum > yfr_dum)\n      {\n        fr_dum = (gsl_rng_uniform_pos(rand) * 6.3e11) * (*(temps + i));\n        y_dum = gsl_rng_uniform_pos(rand);\n        if (spect == 'w')\n        {\n          yfr_dum = ((1.0 / 1.29e31) * pow(fr_dum / (*(temps + i)), 3.0)) / (exp((PL_CONST * fr_dum) / (K_B * (*(temps + i)))) - 1);\n        }\n        else\n        {\n          fr_max = 5.88e10 * (*(temps + i));\n          bb_norm = ((PL_CONST * fr_max) * pow(fr_max / C_LIGHT, 2.0)) / (exp((PL_CONST * fr_max) / (K_B * (*(temps + i)))) - 1);\n          yfr_dum = ((((1.0 / bb_norm) * PL_CONST) * fr_dum) * pow(fr_dum / C_LIGHT, 2.0)) / (exp((PL_CONST * fr_dum) / (K_B * (*(temps + i)))) - 1);\n        }\n\n      }\n\n      position_phi = (gsl_rng_uniform(rand) * 2) * M_PI;\n      com_v_phi = (gsl_rng_uniform(rand) * 2) * M_PI;\n      com_v_theta = acos((gsl_rng_uniform(rand) * 2) - 1);\n      *(p_comv + 0) = (PL_CONST * fr_dum) / C_LIGHT;\n      *(p_comv + 1) = (((PL_CONST * fr_dum) / C_LIGHT) * sin(com_v_theta)) * cos(com_v_phi);\n      *(p_comv + 2) = (((PL_CONST * fr_dum) / C_LIGHT) * sin(com_v_theta)) * sin(com_v_phi);\n      *(p_comv + 3) = ((PL_CONST * fr_dum) / C_LIGHT) * cos(com_v_theta);\n      *(boost + 0) = ((-1) * (*(vx + i))) * cos(position_phi);\n      *(boost + 1) = ((-1) * (*(vx + i))) * sin(position_phi);\n      *(boost + 2) = (-1) * (*(vy + i));\n      lorentzBoost(boost, p_comv, l_boost, 'p', fPtr);\n      (*ph)[ph_tot].p0 = *(l_boost + 0);\n      (*ph)[ph_tot].p1 = *(l_boost + 1);\n      (*ph)[ph_tot].p2 = *(l_boost + 2);\n      (*ph)[ph_tot].p3 = *(l_boost + 3);\n      (*ph)[ph_tot].r0 = (*(x + i)) * cos(position_phi);\n      (*ph)[ph_tot].r1 = (*(x + i)) * sin(position_phi);\n      (*ph)[ph_tot].r2 = *(y + i);\n      (*ph)[ph_tot].num_scatt = 0;\n      (*ph)[ph_tot].weight = ph_weight_adjusted;\n      (*ph)[ph_tot].nearest_block_index = 0;\n      ph_tot++;\n    }\n\n    k++;\n  }\n\n}\n",
        "pragma": ""
    },
    "lazzati-astro/MCRaT/Src/mc_cyclosynch/9": {
        "code": "for (i = 0; i < total_bins; i++)\n  free(avg_values_2d[i]);\n",
        "pragma": ""
    },
    "lazzati-astro/MCRaT/Src/mcrat_io/4": {
        "code": "for (i = 0; i < ((int) (*n_theta_j)); i++)\n{\n  strcpy(copied_str, value);\n  (*frm0)[i] = strtol(copied_str, buf2, 10);\n  value = strtok_r(0, \" \", &context);\n}\n",
        "pragma": ""
    },
    "leleyi/Parallel_Computing/lab4/lab4/2": {
        "code": "for (i = 0; i < iter; ++i)\n{\n  t1 = omp_get_wtime();\n  step_begin = omp_get_wtime();\n  fill_array(m1, N, 0, 12, i);\n  fill_array(m2, N / 2, 12, 10 * 12, i);\n  step_end = omp_get_wtime();\n  compare_time(step_begin, step_end, &minimal_generate_time);\n  step_begin = omp_get_wtime();\n  map(m1, N, m2, N / 2);\n  step_end = omp_get_wtime();\n  compare_time(step_begin, step_end, &minimal_map_time);\n  step_begin = omp_get_wtime();\n  merge(m1, m2, N / 2);\n  step_end = omp_get_wtime();\n  compare_time(step_begin, step_end, &minimal_merge_time);\n  step_begin = omp_get_wtime();\n  sort(&m2, N / 2);\n  step_end = omp_get_wtime();\n  compare_time(step_begin, step_end, &minimal_sort_time);\n  step_begin = omp_get_wtime();\n  x = reduce(m2, N / 2);\n  step_end = omp_get_wtime();\n  compare_time(step_begin, step_end, &minimal_reduce_time);\n  t2 = omp_get_wtime();\n  compare_time(t1, t2, &minimal_time_ms);\n}\n",
        "pragma": ""
    },
    "lineu96/relatorio_openmp/arquivos/02_kmeans/kmeans_paralelo/5": {
        "code": "for (i = 0; i < n; i++)\n{\n  count[cluster[i]]++;\n  for (j = 0; j < 3; j++)\n    sum[(cluster[i] * 3) + j] += x[(i * 3) + j];\n\n}\n",
        "pragma": ""
    },
    "littleblackfish/coilmd/src/langevin/1": {
        "code": "for (i = 0; i < (2 * N); i++)\n{\n  f[i][0] = ziggurat(thread_num) * randFmult;\n  f[i][1] = ziggurat(thread_num) * randFmult;\n  f[i][2] = ziggurat(thread_num) * randFmult;\n}\n",
        "pragma": "#pragma omp for schedule(static)"
    },
    "liuruogu/CS160_openmp/matmul/2": {
        "code": "for (i = 0; i < 1000; i++)\n  for (j = 0; j < 1000; j++)\n{\n  if ((Cs[(i * 1000) + j] - Cp[(i * 1000) + j]) < 0.000001)\n    continue;\n  else\n  {\n    printf(\"ERRORS DETECTED!!!!!!!!!!!!!\\n\");\n    return -1;\n  }\n\n}\n\n",
        "pragma": ""
    },
    "llvm-mirror/openmp/runtime/test/affinity/format/affinity_values/1": {
        "code": "for (id = b; id <= e; ++id)\n{\n  ids[ids_index++] = id;\n  if (ids_index >= ids_size)\n  {\n    free(aff);\n    return;\n  }\n\n}\n",
        "pragma": ""
    },
    "lolodino77/projet_hpc/mpi_et_openmp/cg/19": {
        "code": "for (int i = 0; i < (P - 1); i++)\n{\n  recvcounts[i] = quotient;\n}\n",
        "pragma": ""
    },
    "lreis2415/SEIMS/seims/src/metis/GKlib/csr/48": {
        "code": "for (i = 0; i < nf; i++)\n{\n  for (j = fptr[i]; j < fptr[i + 1]; j++)\n  {\n    rind[rptr[find[j]]++] = i;\n  }\n\n}\n",
        "pragma": ""
    },
    "lreis2415/SEIMS/seims/src/metis/GKlib/graph/32": {
        "code": "for (graph->xadj[0] = 0, k = 0, i = 0; i < nvtxs; i++)\n{\n  do\n  {\n    if (gk_getline(&line, &lnlen, fpin) == (-1))\n    {\n      gk_errexit(SIGERR, \"Pregraphure end of input file: file while reading row %d\\n\", i);\n    }\n\n  }\n  while (line[0] == '%');\n  head = line;\n  tail = 0;\n  if (readsizes)\n  {\n    if (isfvsizes)\n    {\n      graph->fvsizes[i] = strtof(head, &tail);\n      if (tail == head)\n      {\n        gk_errexit(SIGERR, \"The line for vertex %zd does not have size information\\n\", i + 1);\n      }\n\n      if (graph->fvsizes[i] < 0)\n      {\n        gk_errexit(SIGERR, \"The size for vertex %zd must be >= 0\\n\", i + 1);\n      }\n\n    }\n    else\n    {\n      graph->ivsizes[i] = strtol(head, &tail, 0);\n      if (tail == head)\n      {\n        gk_errexit(SIGERR, \"The line for vertex %zd does not have size information\\n\", i + 1);\n      }\n\n      if (graph->ivsizes[i] < 0)\n      {\n        gk_errexit(SIGERR, \"The size for vertex %zd must be >= 0\\n\", i + 1);\n      }\n\n    }\n\n    head = tail;\n  }\n\n  if (readwgts)\n  {\n    for (l = 0; l < ncon; l++)\n    {\n      if (isfvwgts)\n      {\n        graph->fvwgts[(i * ncon) + l] = (float) strtod(head, &tail);\n        if (tail == head)\n        {\n          gk_errexit(SIGERR, \"The line for vertex %zd does not have enough weights for the %d constraints.\\n\", i + 1, ncon);\n        }\n\n        if (graph->fvwgts[(i * ncon) + l] < 0)\n        {\n          gk_errexit(SIGERR, \"The weight vertex %zd and constraint %zd must be >= 0\\n\", i + 1, l);\n        }\n\n      }\n      else\n      {\n        graph->ivwgts[(i * ncon) + l] = strtol(head, &tail, 0);\n        if (tail == head)\n        {\n          gk_errexit(SIGERR, \"The line for vertex %zd does not have enough weights for the %d constraints.\\n\", i + 1, ncon);\n        }\n\n        if (graph->ivwgts[(i * ncon) + l] < 0)\n        {\n          gk_errexit(SIGERR, \"The weight vertex %zd and constraint %zd must be >= 0\\n\", i + 1, l);\n        }\n\n      }\n\n      head = tail;\n    }\n\n  }\n\n  while (1)\n  {\n    ival = (int) strtol(head, &tail, 0);\n    if (tail == head)\n    {\n      break;\n    }\n\n    head = tail;\n    if ((graph->adjncy[k] = ival + numbering) < 0)\n    {\n      gk_errexit(SIGERR, \"Error: Invalid column number %d at row %zd.\\n\", ival, i);\n    }\n\n    if (readvals)\n    {\n      if (isfewgts)\n      {\n        fval = (float) strtod(head, &tail);\n        if (tail == head)\n        {\n          gk_errexit(SIGERR, \"Value could not be found for edge! Vertex:%zd, NNZ:%zd\\n\", i, k);\n        }\n\n        graph->fadjwgt[k] = fval;\n      }\n      else\n      {\n        ival = strtol(head, &tail, 0);\n        if (tail == head)\n        {\n          gk_errexit(SIGERR, \"Value could not be found for edge! Vertex:%zd, NNZ:%zd\\n\", i, k);\n        }\n\n        graph->iadjwgt[k] = ival;\n      }\n\n      head = tail;\n    }\n\n    k++;\n  }\n\n  graph->xadj[i + 1] = k;\n}\n",
        "pragma": ""
    },
    "luanorlandi/Parallel-Sieve-Quicksort/sieve/0": {
        "code": "for (i = 2; i < size; i++)\n{\n  if (prime[i] == 0)\n  {\n    for (j = i + i; j < size; j += i)\n    {\n      prime[j] = 1;\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for num_threads(nthreads) private(j)"
    },
    "lucastavaresuerj/openMP/jogo_da_vida/paralell_life/7": {
        "code": "for (i = 0; i < steps; i++)\n{\n  play(prev, next, size);\n  printf(\"%d ----------\\n\", i);\n  print(next, size);\n  tmp = next;\n  next = prev;\n  prev = tmp;\n}\n",
        "pragma": ""
    },
    "lucaszm7/IPPD_OpenMP_RPC_RMI_MPI/IPPD_OpenMP/sort/2": {
        "code": "for (int i = 0; i < nl; ++i)\n  arr[i] = l[i];\n",
        "pragma": ""
    },
    "m-tavana/CNN_OPENMP/conv_layer4/8": {
        "code": "for (q = 8; q < 16; q++)\n{\n  for (r = 40; r < 80; r++)\n  {\n    for (n = 0; n < 313; n++)\n    {\n      for (m = 0; m < 173; m++)\n      {\n        for (l = 0; l < 5; l++)\n        {\n          for (k = 0; k < 5; k++)\n          {\n            y[(((r * 173) * 313) + (m * 313)) + n] += in_layer[((((q * 177) * 317) + ((m + k) * 317)) + n) + l] * weight[(((((r * 8) + q) - 8) * 25) + (k * 5)) + l];\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "maelso/OpenMP5.0/time_marching_cpu_gpu/2": {
        "code": "for (int i = 0; i < TIME_ORDER; i++)\n{\n  for (int j = 0; j < size_u[0]; j++)\n  {\n    for (int k = 0; k < size_u[1]; k++)\n    {\n      printf(\"%.2f \", u[((i * time_offset) + (j * size_u[0])) + k]);\n    }\n\n    printf(\"\\n\");\n  }\n\n  printf(\"\\n\\n\");\n}\n",
        "pragma": ""
    },
    "makariosb/Parallel-Machine-Learning-Algorithms/Project4/NeuralNet-OpenMP/10": {
        "code": "for (int i = 0; i < (60000 * 500); i++)\n{\n  tmp = rand() % 60000;\n  desiredOut[class_train[tmp]] = 0.9;\n  trainNN(data_train[tmp], desiredOut);\n  desiredOut[class_train[tmp]] = 0.1;\n}\n",
        "pragma": ""
    },
    "mandebi/Sobel-Edge-Detection-MPI-OpenMP/part2/sobel2/1": {
        "code": "for (i = 0; i < 3000; i++)\n{\n  for (j = 0; j < 3000; j++)\n    printf(\" %d\", A[i][j]);\n\n  printf(\"\\n\");\n}\n",
        "pragma": ""
    },
    "mapa17/teacup/teacup_tools/6": {
        "code": "for (i = 0; i < cM->columns; i++)\n{\n  nTotalZeros += cM->nZero[i];\n  nTotalNoneZeros += cM->nNoneZero[i];\n}\n",
        "pragma": ""
    },
    "markopand/Code/LU algorithm OpenMP/9": {
        "code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    if (i == j)\n    {\n      M[i][j] = 1;\n    }\n    else\n      M[i][j] = 0;\n\n  }\n\n}\n",
        "pragma": ""
    },
    "markpal/NPDP_Bench/mea/mea_pb_traco/2": {
        "code": "for (c3 = 0; c3 <= (((N - c1) - 3) / 16); c3 += 1)\n  for (c5 = 0; c5 <= ((c1 - 1) / 16); c5 += 1)\n  for (c7 = 0; c7 <= ((-c3) + (((N - c1) - 3) / 16)); c7 += 1)\n  for (c11 = (c1 + (16 * c3)) + 1; c11 <= ((((c1 + (16 * c3)) + 16) < ((N - (16 * c7)) - 2)) ? ((c1 + (16 * c3)) + 16) : ((N - (16 * c7)) - 2)); c11 += 1)\n{\n  if (N >= (((16 * c7) + c11) + 18))\n  {\n    for (c15 = ((16 * c7) + c11) + 1; c15 <= (((16 * c7) + c11) + 16); c15 += 1)\n      Pbp[c1][c11] += ((((Pbp[16 * c5][c15] * ERT) * Q[(16 * c5) + 1][c1]) * Qbp[c1][c11]) * Q[c11 + 1][c15 - 1]) / ((Qbp[16 * c5][c15] == 0) ? (1) : (Qbp[16 * c5][c15]));\n\n  }\n  else\n  {\n    for (c13 = 16 * c5; c13 <= (((c1 - 1) < ((16 * c5) + 15)) ? (c1 - 1) : ((16 * c5) + 15)); c13 += 1)\n    {\n      if (c13 >= ((16 * c5) + 1))\n        for (c15 = c11 + 1; c15 <= ((16 * c7) + c11); c15 += 1)\n        Pbp[c1][c11] += ((((Pbp[c13][c15] * ERT) * Q[c13 + 1][c1]) * Qbp[c1][c11]) * Q[c11 + 1][c15 - 1]) / ((Qbp[c13][c15] == 0) ? (1) : (Qbp[c13][c15]));\n\n\n      for (c15 = ((16 * c7) + c11) + 1; c15 < N; c15 += 1)\n        Pbp[c1][c11] += ((((Pbp[c13][c15] * ERT) * Q[c13 + 1][c1]) * Qbp[c1][c11]) * Q[c11 + 1][c15 - 1]) / ((Qbp[c13][c15] == 0) ? (1) : (Qbp[c13][c15]));\n\n    }\n\n  }\n\n}\n\n\n\n",
        "pragma": "#pragma omp parallel for schedule(dynamic, 1)"
    },
    "martinverup/OpenMP-Poisson-Problem/poisson/4": {
        "code": "for (i = 1; i < (N - 1); i++)\n{\n  for (j = 1; j < (N - 1); j++)\n  {\n    old_val = U_old[i][j];\n    U_old[i][j] = ((((U[i][j - 1] + U[i][j + 1]) + U[i - 1][j]) + U[i + 1][j]) + ((Delta * Delta) * F[i][j])) * one_fourth;\n    old_val -= U_old[i][j];\n    d += (old_val < 0) ? (-old_val) : (old_val);\n  }\n\n}\n",
        "pragma": ""
    },
    "mase28/OpenMPNeuralNetwork/main_par_layer/14": {
        "code": "for (int j = 0; j < numHidden1Nodes; ++j)\n{\n  double a = layer1_bias[j];\n  for (int k = 1; k < (numInputs + 1); ++k)\n  {\n    a += test[i][k] * layer1_weights[j][k - 1];\n  }\n\n  layer1[j] = act(a);\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "mateoochoa/Examples_Openmp/als-movie-recommender/C/main/4": {
        "code": "for (i = 0; i < maxUserId; i++)\n{\n  max[i] = 0;\n  for (j = 0; j < maxMovieId; j++)\n  {\n    if (max[i] < MatrixXd_get_coeff(aux, i, j))\n    {\n      max[i] = MatrixXd_get_coeff(aux, i, j);\n      pel[i] = j;\n    }\n\n  }\n\n  printf(\"Usuario: %d - Pelicula: %d\\n\", i, pel[i]);\n}\n",
        "pragma": ""
    },
    "matey97/LU_OpenMP_MPI/LU_pivR_OpenMP_MPI/3": {
        "code": "for (i = 0; i < size; i++)\n{\n  sendFromA[i] = (i == 0) ? (0) : (sendFromA[i - 1] + sizeToSendA[i - 1]);\n  sizeToSendA[i] = (i < n_bloque) ? (bloque + 1) : (bloque);\n}\n",
        "pragma": ""
    },
    "matiasmartineza/learning_omp/for_things/mvp/1": {
        "code": "for (i = 0; i < N; i++)\n{\n  x[i] = i;\n  for (j = 0; j < N; j++)\n  {\n    A[i][j] = i;\n  }\n\n}\n",
        "pragma": ""
    },
    "mattm401/pDAMGES/parallel/20": {
        "code": "for (kk = 0; kk < lF; kk++)\n{\n  k = F[kk] - 1;\n  if ((k != j) && (S[i][k] == 1))\n  {\n    lCk = 0;\n    for (l = 0; l < lCi; l++)\n    {\n      if (S[k][Ci[l][0] - 1] == 1)\n      {\n        lCk = lCk + 1;\n      }\n\n    }\n\n    if (lCk == 0)\n    {\n      fail = 1;\n    }\n\n  }\n\n}\n",
        "pragma": ""
    },
    "mayankmahavar111/pc/parallel/11": {
        "code": "for (i = 0; i < count; i++)\n{\n  fscanf(fp, \"%s\", a);\n  stringsize = strlen(a);\n  positive[i] = (char *) malloc(stringsize + 1);\n  strcpy(positive[i], a);\n}\n",
        "pragma": ""
    },
    "miaohuihui1995/parallel/omp/ex0/18": {
        "code": "for (i = 0; i < 5; i++)\n{\n  printf(\"a[%d] = %d, threadID = %d\\n\", i, a[i], omp_get_thread_num());\n}\n",
        "pragma": ""
    },
    "michal3141/openmp/counting/6": {
        "code": "for (i = 0; i < 100; i++)\n  C[i] += C_private[i];\n",
        "pragma": ""
    },
    "minavouronikou/kmeans_hybrid/Hybrid version/kmeans/15": {
        "code": "for (i = 0; i < num_points; i++)\n  data_points[i] = (double *) malloc(dimension * (sizeof(double)));\n",
        "pragma": ""
    },
    "mkhan5/mkl-kernels/dgemm/dgemm_papi_flops_par/1": {
        "code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    sum = 0.0;\n    for (k = 0; k < p; k++)\n      sum += A[(p * i) + k] * B[(n * k) + j];\n\n    C[(n * i) + j] = sum;\n  }\n\n}\n",
        "pragma": ""
    },
    "mklobukov/Parallel-Programming/Parallelized Programs/Gaussian Elimination/Mark_Klobukov_Assignment1_ECEC622/gauss_eliminate/0": {
        "code": "for (i = 0; i < num_elements; i++)\n{\n  for (int j = 0; j < num_elements; j++)\n  {\n    U[(num_elements * i) + j] = A[(num_elements * i) + j];\n  }\n\n}\n",
        "pragma": "#pragma omp for nowait"
    },
    "mominbuet/ParallelGST/TreeConstruction/OpenMPBoth/0": {
        "code": "for (int rank = 0; rank < num_procs; ++rank)\n{\n  int *setup_msg = setup_message(rank, splits, input_size);\n  do_work(setup_msg, rank, num_procs);\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "moruku36/openmp/OpenMP_Samples/Answer/Poisson/C/poisson/2": {
        "code": "for (k = 0; k < omp_get_max_threads(); k++)\n{\n  for (i = istart[k]; i <= iend[k]; i++)\n  {\n    for (j = 1; j < (100 + 1); j++)\n    {\n      dtemp = fabs(U_rhs[i][j] - U_lhs[i][j]);\n      if (dtemp > dmax_t[k])\n        dmax_t[k] = dtemp;\n\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for private(i,j,dtemp)"
    },
    "muniz034/open-mp/src/USING-OPENMP/mxv/3": {
        "code": "for (int i = 0; i < m; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    printf(\"%d \", matrix[(i * n) + j]);\n  }\n\n  printf(\"\\n\");\n}\n",
        "pragma": ""
    },
    "n-roussos/Parallel-Programming-with-OpenMP/5. N queens problem/Queens2/Queens2.0/0": {
        "code": "for (int i = 0; i < 4; i++)\n{\n  ROWS_PLACED[i] = -1;\n  VALID_ROWS[0][i] = 1;\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "nasaa0528/compactAndSparceMatrix/sparceMatrix/sparceMatrix_parallel/10": {
        "code": "for (i = 0; i < col; i++)\n  printf(\"%d%c\", multVector[i], (i == (col - 1)) ? ('\\n') : (' '));\n",
        "pragma": ""
    },
    "nctu-homeworks/PP-hw2/cg/14": {
        "code": "for (j = 0; j < nrows; j++)\n{\n  for (k = rowstr[j]; k < rowstr[j + 1]; k++)\n  {\n    a[k] = 0.0;\n    colidx[k] = -1;\n  }\n\n  nzloc[j] = 0;\n}\n",
        "pragma": ""
    },
    "nidabrahim/Parallel-computing-labs/TP1/matrices_calculator/4": {
        "code": "for (i = n - 1; i >= 0; i--)\n  free(A[i]);\n",
        "pragma": ""
    },
    "niksterg/openmp-course/poisson-SOR/12": {
        "code": "for (int i = 0; i < N; i++)\n  unew[i] = (double *) malloc(M * (sizeof(double)));\n",
        "pragma": ""
    },
    "niyasc/parallal-programming/openmp/dotp/1": {
        "code": "for (i = 0; i < 100; i++)\n{\n  localsum += a[i] * b[i];\n}\n",
        "pragma": "#pragma omp for"
    },
    "nmsafiri/openMP/pprog/1": {
        "code": "for (i = 0; i < N; i++)\n{\n  a[i] = i * 2;\n  b[i] = i;\n}\n",
        "pragma": ""
    },
    "nuitrcs/OpenMP-MPI-workshop/openmp_examples/pi_red/0": {
        "code": "for (i = 0; i < num_steps; ++i)\n{\n  x = (i + 0.5) * step;\n  sum = sum + (4.0 / (1.0 + (x * x)));\n}\n",
        "pragma": "#pragma omp for schedule(static) reduction(+:sum)"
    },
    "obernardocosta/High-Performance-Computing-HPC/OPEN_MP/2/linalg_par/5": {
        "code": "for (i = 0; i < size; i++)\n{\n  r[i] = value;\n}\n",
        "pragma": ""
    },
    "ochapman-code/fast-fourier-transform/fft/2": {
        "code": "for (int group = 0; group < group_num; group++)\n{\n  int index_0_i = group * group_size;\n  for (int index_2_i = 0; index_2_i < (group_size_half * group_num); index_2_i += group_num)\n  {\n    int index_1_i = index_0_i + group_size_half;\n    cplx f = array[index_0_i];\n    cplx g = array[index_1_i] * W_array[index_2_i];\n    array[index_0_i] = f + g;\n    array[index_1_i] = f - g;\n    index_0_i++;\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for if(ENABLE_PARALLEL)"
    },
    "olia92/OpenMP_Mattson/Histogram/histo_omp_StackOverDude/3": {
        "code": "for (int i = 0; i < NITEMS; i++)\n  omp_destroy_lock(&lock[i]);\n",
        "pragma": ""
    },
    "ompcloud/ompcloud/release/mat-mul/0": {
        "code": "for (int i = 0; i < 1000; ++i)\n{\n  for (int j = 0; j < 1000; ++j)\n  {\n    c[(i * 1000) + j] = 0;\n    for (int k = 0; k < 1000; ++k)\n    {\n      c[(i * 1000) + j] += a[(i * 1000) + k] * b[(k * 1000) + j];\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "openwall/john-core/src/BF_std/34": {
        "code": "for (t = 0; t < n; t++)\n{\n  BF_word L0;\n  BF_word R0;\n  BF_word u1;\n  BF_word u2;\n  BF_word u3;\n  BF_word u4;\n  BF_word *ptr;\n  BF_word count;\n  index = t;\n  {\n    int i;\n    memcpy(BF_current[index & 1].S, BF_init_state.S, sizeof(BF_current[index & 1].S));\n    memcpy(BF_current[index & 1].P, BF_init_key[index], sizeof(BF_current[index & 1].P));\n    L0 = (R0 = 0);\n    for (i = 0; i < (16 + 2); i += 2)\n    {\n      L0 ^= salt->salt[i & 2];\n      R0 ^= salt->salt[(i & 2) + 1];\n      L0 ^= BF_current[index & 1].P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current[index & 1].P[16 + 1];\n      ;\n      BF_current[index & 1].P[i] = L0;\n      BF_current[index & 1].P[i + 1] = R0;\n    }\n\n    ptr = BF_current[index & 1].S[0];\n    do\n    {\n      ptr += 4;\n      L0 ^= salt->salt[(16 + 2) & 3];\n      R0 ^= salt->salt[(16 + 3) & 3];\n      L0 ^= BF_current[index & 1].P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current[index & 1].P[16 + 1];\n      ;\n      *(ptr - 4) = L0;\n      *(ptr - 3) = R0;\n      L0 ^= salt->salt[(16 + 4) & 3];\n      R0 ^= salt->salt[(16 + 5) & 3];\n      L0 ^= BF_current[index & 1].P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index & 1].P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index & 1].P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current[index & 1].P[16 + 1];\n      ;\n      *(ptr - 2) = L0;\n      *(ptr - 1) = R0;\n    }\n    while (ptr < (&BF_current[index & 1].S[3][0xFF]));\n  }\n  count = 1 << salt->rounds;\n  do\n  {\n    index = t;\n    {\n      BF_current[index & 1].P[0] ^= BF_exp_key[index][0];\n      BF_current[index & 1].P[1] ^= BF_exp_key[index][1];\n      BF_current[index & 1].P[2] ^= BF_exp_key[index][2];\n      BF_current[index & 1].P[3] ^= BF_exp_key[index][3];\n      BF_current[index & 1].P[4] ^= BF_exp_key[index][4];\n      BF_current[index & 1].P[5] ^= BF_exp_key[index][5];\n      BF_current[index & 1].P[6] ^= BF_exp_key[index][6];\n      BF_current[index & 1].P[7] ^= BF_exp_key[index][7];\n      BF_current[index & 1].P[8] ^= BF_exp_key[index][8];\n      BF_current[index & 1].P[9] ^= BF_exp_key[index][9];\n      BF_current[index & 1].P[10] ^= BF_exp_key[index][10];\n      BF_current[index & 1].P[11] ^= BF_exp_key[index][11];\n      BF_current[index & 1].P[12] ^= BF_exp_key[index][12];\n      BF_current[index & 1].P[13] ^= BF_exp_key[index][13];\n      BF_current[index & 1].P[14] ^= BF_exp_key[index][14];\n      BF_current[index & 1].P[15] ^= BF_exp_key[index][15];\n      BF_current[index & 1].P[16] ^= BF_exp_key[index][16];\n      BF_current[index & 1].P[17] ^= BF_exp_key[index][17];\n    }\n    L0 = (R0 = 0);\n    ptr = BF_current.P;\n    do\n    {\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *ptr = L0;\n      *(ptr + 1) = R0;\n      ptr += 2;\n    }\n    while (ptr < (&BF_current.P[16 + 2]));\n    ptr = BF_current.S[0];\n    do\n    {\n      ptr += 2;\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *(ptr - 2) = L0;\n      *(ptr - 1) = R0;\n    }\n    while (ptr < (&BF_current.S[3][0xFF]));\n    ;\n    u1 = salt->salt[0];\n    u2 = salt->salt[1];\n    u3 = salt->salt[2];\n    u4 = salt->salt[3];\n    index = t;\n    {\n      BF_current[index & 1].P[0] ^= u1;\n      BF_current[index & 1].P[1] ^= u2;\n      BF_current[index & 1].P[2] ^= u3;\n      BF_current[index & 1].P[3] ^= u4;\n      BF_current[index & 1].P[4] ^= u1;\n      BF_current[index & 1].P[5] ^= u2;\n      BF_current[index & 1].P[6] ^= u3;\n      BF_current[index & 1].P[7] ^= u4;\n      BF_current[index & 1].P[8] ^= u1;\n      BF_current[index & 1].P[9] ^= u2;\n      BF_current[index & 1].P[10] ^= u3;\n      BF_current[index & 1].P[11] ^= u4;\n      BF_current[index & 1].P[12] ^= u1;\n      BF_current[index & 1].P[13] ^= u2;\n      BF_current[index & 1].P[14] ^= u3;\n      BF_current[index & 1].P[15] ^= u4;\n      BF_current[index & 1].P[16] ^= u1;\n      BF_current[index & 1].P[17] ^= u2;\n    }\n    L0 = (R0 = 0);\n    ptr = BF_current.P;\n    do\n    {\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *ptr = L0;\n      *(ptr + 1) = R0;\n      ptr += 2;\n    }\n    while (ptr < (&BF_current.P[16 + 2]));\n    ptr = BF_current.S[0];\n    do\n    {\n      ptr += 2;\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *(ptr - 2) = L0;\n      *(ptr - 1) = R0;\n    }\n    while (ptr < (&BF_current.S[3][0xFF]));\n    ;\n  }\n  while (--count);\n  index = t;\n  {\n    BF_word L;\n    BF_word R;\n    BF_word u1;\n    BF_word u2;\n    BF_word u3;\n    BF_word u4;\n    BF_word count;\n    int i;\n    memcpy(&BF_out[index], &BF_magic_w, sizeof(BF_out[index]));\n    count = 64;\n    do\n      for (i = 0; i < 6; i += 2)\n    {\n      L = BF_out[index][i];\n      R = BF_out[index][i + 1];\n      L ^= BF_current[index & 1].P[0];\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index & 1].P[0 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index & 1].P[1 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index & 1].P[2 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index & 1].P[3 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index & 1].P[4 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index & 1].P[5 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index & 1].P[6 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index & 1].P[7 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index & 1].P[8 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index & 1].P[9 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index & 1].P[10 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index & 1].P[11 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index & 1].P[12 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index & 1].P[13 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index & 1].P[14 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index & 1].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index & 1].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index & 1].P[15 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u4 = R;\n      R = L;\n      L = u4 ^ BF_current[index & 1].P[16 + 1];\n      ;\n      BF_out[index][i] = L;\n      BF_out[index][i + 1] = R;\n    }\n\n    while (--count);\n    BF_out[index][5] &= ~((BF_word) 0xFF);\n  }\n}\n",
        "pragma": ""
    },
    "openwall/john/src/DOMINOSEC8_fmt_plug/8": {
        "code": "for (; j > 16; j--)\n{\n  t0 = block0[(p0 - x[0].c) - 16] ^ lotus_magic_table[j + t0];\n  t1 = block1[(p1 - x[1].c) - 16] ^ lotus_magic_table[j + t1];\n  t2 = block2[(p2 - x[2].c) - 16] ^ lotus_magic_table[j + t2];\n  *(p0++) = t0;\n  *(p1++) = t1;\n  *(p2++) = t2;\n}\n",
        "pragma": ""
    },
    "openwall/john/src/NETLMv2_fmt_plug/3": {
        "code": "for (pos = ciphertext + ((sizeof(\"$NETLMv2$\")) - 1); (*pos) != '$'; pos++)\n  ;\n",
        "pragma": ""
    },
    "openwall/john/src/androidfde_fmt_plug/5": {
        "code": "for (index = 0; index < count; index += SSE_GROUP_SZ_SHA1)\n{\n  hash_plugin_check_hash(index);\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "openwall/john/src/clipperz_srp_fmt_plug/3": {
        "code": "for (i = 1; i < 33; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n  if (p >= q)\n    break;\n\n}\n",
        "pragma": ""
    },
    "openwall/john/src/ecryptfs_fmt_plug/1": {
        "code": "for (i = 0; i < cs.salt_length; i++)\n  cs.salt[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n",
        "pragma": ""
    },
    "openwall/john/src/keyring_fmt_plug/0": {
        "code": "for (; *p; p++)\n  if (((*p) < '0') || ((*p) > '9'))\n  return 0;\n\n",
        "pragma": ""
    },
    "openwall/john/src/lotus85_fmt_plug/0": {
        "code": "for (index = 0; index < count; index++)\n{\n  unsigned char user_key[8];\n  unsigned char deciphered_userid[0x64];\n  memset(lotus85_last_binary_hash1[index], 0, 5);\n  memset(lotus85_last_binary_hash2[index], 0, 5);\n  memset(user_key, 0, sizeof(user_key));\n  memset(deciphered_userid, 0, sizeof(deciphered_userid));\n  get_user_id_secret_key(lotus85_saved_passwords[index], user_key);\n  decipher_userid_blob(cur_salt->lotus85_user_blob, cur_salt->lotus85_user_blob_len, user_key, deciphered_userid);\n  memcpy(lotus85_last_binary_hash1[index], (deciphered_userid + cur_salt->lotus85_user_blob_len) - 5, 5);\n  compute_msg_mac(deciphered_userid, cur_salt->lotus85_user_blob_len - 5, lotus85_last_binary_hash2[index]);\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "openwall/john/src/mssql12_fmt_plug/5": {
        "code": "for (index = 0; index < count; index += SIMD_COEF_64 * SIMD_PARA_SHA512)\n{\n  SHA512_CTX ctx;\n  memcpy(saved_key[index] + saved_len[index], cursalt, 4);\n  SHA512_Init(&ctx);\n  SHA512_Update(&ctx, saved_key[index], saved_len[index] + 4);\n  SHA512_Final((unsigned char *) crypt_out[index], &ctx);\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "openwall/john/src/office_fmt_plug/7": {
        "code": "for (i = 0; i < cur_salt->spinCount; i++)\n{\n  *inputBuf = JOHNSWAP(i);\n  SHA512_Init(&ctx);\n  SHA512_Update(&ctx, inputBuf, 64 + 0x04);\n  SHA512_Final((uint8_t *) (&inputBuf[1]), &ctx);\n}\n",
        "pragma": ""
    },
    "openwall/john/src/pbkdf2-hmac-md5_fmt_plug/0": {
        "code": "for (index = 0; index < count; index += 1)\n{\n  pbkdf2_md5((unsigned char *) saved_key[index], strlen(saved_key[index]), (unsigned char *) cur_salt->salt, cur_salt->length, cur_salt->rounds, (unsigned char *) crypt_out[index], PBKDF2_MDx_BINARY_SIZE, 0);\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "openwall/john/src/rar5_fmt_plug/0": {
        "code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char PswCheckValue[SHA256_DIGEST_SIZE];\n  unsigned char PswCheck[SIZE_PSWCHECK];\n  int i;\n  pbkdf2_sha256((unsigned char *) saved_key[index], strlen(saved_key[index]), cur_salt->salt, SIZE_SALT50, cur_salt->iterations + 32, PswCheckValue, SHA256_DIGEST_SIZE, 0);\n  memset(PswCheck, 0, sizeof(PswCheck));\n  for (i = 0; i < SHA256_DIGEST_SIZE; i++)\n    PswCheck[i % SIZE_PSWCHECK] ^= PswCheckValue[i];\n\n  memcpy((void *) crypt_out[index], PswCheck, SIZE_PSWCHECK);\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "openwall/john/src/sapH_fmt_plug/12": {
        "code": "for (idx = 0; idx < count; idx += SIMD_COEF_64 * SIMD_PARA_SHA512)\n{\n  SHA512_CTX ctx;\n  uint32_t i;\n  uint32_t len = strlen(saved_plain[idx]);\n  unsigned char tmp[23 + 48];\n  unsigned char *cp = &tmp[len];\n  SHA384_Init(&ctx);\n  SHA384_Update(&ctx, saved_plain[idx], len);\n  SHA384_Update(&ctx, sapH_cur_salt->s, sapH_cur_salt->slen);\n  strcpy((char *) tmp, saved_plain[idx]);\n  len += 48;\n  SHA384_Final(cp, &ctx);\n  for (i = 1; i < sapH_cur_salt->iter; ++i)\n  {\n    SHA384_Init(&ctx);\n    SHA384_Update(&ctx, tmp, len);\n    SHA384_Final(cp, &ctx);\n  }\n\n  memcpy(crypt_key[idx], cp, 16);\n}\n",
        "pragma": "#pragma omp parallel for default(none) private(idx) shared(count, sapH_cur_salt, saved_plain, crypt_key)"
    },
    "openwall/john/src/strip_fmt_plug/0": {
        "code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char master[1][32];\n  unsigned char output[24];\n  unsigned char *iv_in;\n  unsigned char iv_out[16];\n  int size;\n  int i;\n  int page_sz = 1008;\n  int reserve_sz = 16;\n  AES_KEY akey;\n  pbkdf2_sha1((unsigned char *) saved_key[index], strlen(saved_key[index]), cur_salt->salt, 16, ITERATIONS, master[0], 32, 0);\n  for (i = 0; i < 1; ++i)\n  {\n    size = page_sz - reserve_sz;\n    iv_in = (cur_salt->data + size) + 16;\n    memcpy(iv_out, iv_in, 16);\n    AES_set_decrypt_key(master[i], 256, &akey);\n    AES_cbc_encrypt(cur_salt->data + 16, output + 16, 8, &akey, iv_out, AES_DECRYPT);\n    if (strip_verify_page(output) == 0)\n    {\n      cracked[index + i] = 1;\n    }\n    else\n      cracked[index + i] = 0;\n\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "openwall/john/src/zipmonster_fmt_plug/0": {
        "code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char buffer[16];\n  MD5_CTX ctx;\n  int n = 49999;\n  unsigned char hex_buffer[16 * 2];\n  MD5_Init(&ctx);\n  MD5_Update(&ctx, saved_key[index], strlen(saved_key[index]));\n  MD5_Final(buffer, &ctx);\n  hex_encode_uppercase(buffer, hex_buffer);\n  do\n  {\n    MD5_Init(&ctx);\n    MD5_Update(&ctx, hex_buffer, 16 * 2);\n    MD5_Final(buffer, &ctx);\n    hex_encode_uppercase(buffer, hex_buffer);\n    --n;\n  }\n  while (n);\n  memcpy((unsigned char *) crypt_out[index], buffer, 16);\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "oriolmartinezac/cap-openmp/nn-vo-db/2": {
        "code": "for (int k = 0; k < NUMOUT; k++)\n{\n  double SumO = 0.0;\n  for (int j = 0; j < NUMHID; j++)\n    SumO += Hidden[p][j] * WeightHO[k][j];\n\n  Output[p][k] = 1.0 / (1.0 + exp(-SumO));\n  BError += (0.5 * (Target[p][k] - Output[p][k])) * (Target[p][k] - Output[p][k]);\n  DeltaO[k] = ((Target[p][k] - Output[p][k]) * Output[p][k]) * (1.0 - Output[p][k]);\n}\n",
        "pragma": "#pragma omp for reduction(+:BError)"
    },
    "otavio-r-filho/openmp_training/array/par_array/1": {
        "code": "for (i = 1; i < 16000000; i++)\n{\n  data[i] = data[i] + (i * 1.0);\n}\n",
        "pragma": "#pragma omp for"
    },
    "passlab/homp/benchmarks/matmul/bkp/old/matrixmultiply-ompacc/4": {
        "code": "for (i = 0; i < 1024; i++)\n  for (j = 0; j < 1024; j++)\n  for (k = 0; k < 1024; k++)\n  c2[i][j] = c2[i][j] + (a[i][k] * b[k][j]);\n\n\n",
        "pragma": ""
    },
    "passlab/homp/runtime/homp_dev/21": {
        "code": "for (i = 0; i < num_of_platforms; ++i)\n{\n  size_t platform_name_length = 0;\n  err = clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, 0, 0, &platform_name_length);\n  {\n    devcall_opencl_errchk(err, \"/tmp/tmpvicf2e7m.c\", 266, 1);\n  }\n  ;\n  char platform_name[platform_name_length];\n  err = clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, platform_name_length, platform_name, 0);\n  {\n    devcall_opencl_errchk(err, \"/tmp/tmpvicf2e7m.c\", 271, 1);\n  }\n  ;\n  if (strstr(platform_name, required_platform_subname) && (selected_platform_index == num_of_platforms))\n  {\n    selected_platform_index = i;\n    break;\n  }\n\n}\n",
        "pragma": ""
    },
    "passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/3mm-parallel-no/22": {
        "code": "for (c1 = (ni > nj) ? (ni) : (nj); c1 <= (((nk + (-1)) < (nm + (-1))) ? (nk + (-1)) : (nm + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (nj + (-1)); c2++)\n  {\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for private(c2)"
    },
    "passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/indirectaccess1-orig-yes/1": {
        "code": "for (i = 521; i <= 2025; ++i)\n{\n  base[i] = 0.5 * i;\n}\n",
        "pragma": ""
    },
    "passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/matrixmultiply/1": {
        "code": "for (i = 0; i < 512; i++)\n  for (j = 0; j < 512; j++)\n  a[i][j] = (((3.0 * i) * j) / 512) / 512;\n\n",
        "pragma": ""
    },
    "passlab/rexompiler/tutorial/bt_onefile/4": {
        "code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    for (k = 0; k < grid_points[2]; k++)\n    {\n      tmp1 = 1.0 / u[i][j][k][0];\n      tmp2 = tmp1 * tmp1;\n      tmp3 = tmp1 * tmp2;\n      fjac[i][j][k][0][0] = 0.0;\n      fjac[i][j][k][0][1] = 0.0;\n      fjac[i][j][k][0][2] = 0.0;\n      fjac[i][j][k][0][3] = 1.0;\n      fjac[i][j][k][0][4] = 0.0;\n      fjac[i][j][k][1][0] = (-(u[i][j][k][1] * u[i][j][k][3])) * tmp2;\n      fjac[i][j][k][1][1] = u[i][j][k][3] * tmp1;\n      fjac[i][j][k][1][2] = 0.0;\n      fjac[i][j][k][1][3] = u[i][j][k][1] * tmp1;\n      fjac[i][j][k][1][4] = 0.0;\n      fjac[i][j][k][2][0] = (-(u[i][j][k][2] * u[i][j][k][3])) * tmp2;\n      fjac[i][j][k][2][1] = 0.0;\n      fjac[i][j][k][2][2] = u[i][j][k][3] * tmp1;\n      fjac[i][j][k][2][3] = u[i][j][k][2] * tmp1;\n      fjac[i][j][k][2][4] = 0.0;\n      fjac[i][j][k][3][0] = (-((u[i][j][k][3] * u[i][j][k][3]) * tmp2)) + ((0.50 * c2) * ((((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3])) * tmp2));\n      fjac[i][j][k][3][1] = ((-c2) * u[i][j][k][1]) * tmp1;\n      fjac[i][j][k][3][2] = ((-c2) * u[i][j][k][2]) * tmp1;\n      fjac[i][j][k][3][3] = ((2.0 - c2) * u[i][j][k][3]) * tmp1;\n      fjac[i][j][k][3][4] = c2;\n      fjac[i][j][k][4][0] = (((c2 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) * tmp2) - (c1 * (u[i][j][k][4] * tmp1))) * (u[i][j][k][3] * tmp1);\n      fjac[i][j][k][4][1] = ((-c2) * (u[i][j][k][1] * u[i][j][k][3])) * tmp2;\n      fjac[i][j][k][4][2] = ((-c2) * (u[i][j][k][2] * u[i][j][k][3])) * tmp2;\n      fjac[i][j][k][4][3] = (c1 * (u[i][j][k][4] * tmp1)) - ((0.50 * c2) * ((((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + ((3.0 * u[i][j][k][3]) * u[i][j][k][3])) * tmp2));\n      fjac[i][j][k][4][4] = (c1 * u[i][j][k][3]) * tmp1;\n      njac[i][j][k][0][0] = 0.0;\n      njac[i][j][k][0][1] = 0.0;\n      njac[i][j][k][0][2] = 0.0;\n      njac[i][j][k][0][3] = 0.0;\n      njac[i][j][k][0][4] = 0.0;\n      njac[i][j][k][1][0] = ((-c3c4) * tmp2) * u[i][j][k][1];\n      njac[i][j][k][1][1] = c3c4 * tmp1;\n      njac[i][j][k][1][2] = 0.0;\n      njac[i][j][k][1][3] = 0.0;\n      njac[i][j][k][1][4] = 0.0;\n      njac[i][j][k][2][0] = ((-c3c4) * tmp2) * u[i][j][k][2];\n      njac[i][j][k][2][1] = 0.0;\n      njac[i][j][k][2][2] = c3c4 * tmp1;\n      njac[i][j][k][2][3] = 0.0;\n      njac[i][j][k][2][4] = 0.0;\n      njac[i][j][k][3][0] = (((-con43) * c3c4) * tmp2) * u[i][j][k][3];\n      njac[i][j][k][3][1] = 0.0;\n      njac[i][j][k][3][2] = 0.0;\n      njac[i][j][k][3][3] = ((con43 * c3) * c4) * tmp1;\n      njac[i][j][k][3][4] = 0.0;\n      njac[i][j][k][4][0] = (((((-(c3c4 - c1345)) * tmp3) * (u[i][j][k][1] * u[i][j][k][1])) - (((c3c4 - c1345) * tmp3) * (u[i][j][k][2] * u[i][j][k][2]))) - ((((con43 * c3c4) - c1345) * tmp3) * (u[i][j][k][3] * u[i][j][k][3]))) - ((c1345 * tmp2) * u[i][j][k][4]);\n      njac[i][j][k][4][1] = ((c3c4 - c1345) * tmp2) * u[i][j][k][1];\n      njac[i][j][k][4][2] = ((c3c4 - c1345) * tmp2) * u[i][j][k][2];\n      njac[i][j][k][4][3] = (((con43 * c3c4) - c1345) * tmp2) * u[i][j][k][3];\n      njac[i][j][k][4][4] = c1345 * tmp1;\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp for private(j,k,tmp1,tmp2,tmp3)"
    },
    "pedrodaniel10/CPD/src/openmp/simpar-omp/4": {
        "code": "for (int i = 0; i < num_max_threads; i++)\n{\n  cells_threads[i] = &cells_rows[i * grid_size];\n  for (int j = 0; j < grid_size; j++)\n  {\n    cells_threads[i][j] = &cells_chunk[((i * grid_size) * grid_size) + (j * grid_size)];\n  }\n\n}\n",
        "pragma": ""
    },
    "phramos07/taskminer/tests/Polybench/base/acc/FDTD-2D/fdtd2d/4": {
        "code": "for (i = 0; i < tmax; i++)\n{\n  _fict_[i] = (DATA_TYPE) i;\n}\n",
        "pragma": ""
    },
    "phramos07/taskminer/tests/Polybench/base/omp/2DCONV/2DConvolution/2": {
        "code": "for (i = 1; i < (NI - 1); i++)\n{\n  for (j = 1; j < (NJ - 1); j++)\n  {\n    if (percentDiff(B[(i * NJ) + j], B_GPU[(i * NJ) + j]) > 0.05)\n    {\n      fail++;\n    }\n\n  }\n\n}\n",
        "pragma": ""
    },
    "phramos07/taskminer/tests/Polybench/base/omp/2MM/2mm/34": {
        "code": "for (i = 0; i < 32; i++)\n{\n  for (j = 0; j < 32; j++)\n  {\n    E[(i * 32) + j] = 0.0;\n    for (k = 0; k < 32; ++k)\n    {\n      E[(i * 32) + j] += C[(i * 32) + k] * D[(k * 32) + j];\n    }\n\n  }\n\n}\n",
        "pragma": ""
    },
    "phramos07/taskminer/tests/Polybench/base/omp/ATAX/atax/8": {
        "code": "for (j = 0; j < 4096; j++)\n  for (i = 0; i < 4096; i++)\n{\n  {\n    y[j] = y[j] + (A[(i * 4096) + j] * tmp[i]);\n  }\n}\n\n",
        "pragma": "#pragma omp parallel for collapse(1)"
    },
    "phramos07/taskminer/tests/Polybench/base/omp/BICG/bicg/23": {
        "code": "for (i = 0; i < 1024; i++)\n{\n  p[i] = i * 3.14159;\n}\n",
        "pragma": ""
    },
    "phramos07/taskminer/tests/Polybench/base/omp/CORR/correlation/23": {
        "code": "for (j = 1; j < (256 + 1); j++)\n{\n  stddev[j] = 0.0;\n  for (i = 1; i < (256 + 1); i++)\n  {\n    stddev[j] += (data[(i * (256 + 1)) + j] - mean[j]) * (data[(i * (256 + 1)) + j] - mean[j]);\n  }\n\n  stddev[j] /= 3214212.01f;\n  stddev[j] = sqrt(stddev[j]);\n  if (stddev[j] <= 0.005f)\n  {\n    stddev[j] = 1.0;\n  }\n\n}\n",
        "pragma": ""
    },
    "phramos07/taskminer/tests/Polybench/base/omp/GESUMMV/gesummv/0": {
        "code": "for (i = 0; i < N; i++)\n{\n  tmp[i] = 0;\n  y[i] = 0;\n  for (j = 0; j < N; j++)\n  {\n    tmp[i] = (A[(i * N) + j] * x[j]) + tmp[i];\n    y[i] = (B[(i * N) + j] * x[j]) + y[i];\n  }\n\n  y[i] = (43532.0f * tmp[i]) + (12313.0f * y[i]);\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "phramos07/taskminer/tests/Polybench/base/omp/MVT/mvt/7": {
        "code": "for (i = 0; i < 2048; i++)\n{\n  int j;\n  for (j = 0; j < 2048; j++)\n  {\n    x2[i] = x2[i] + (a[(j * 2048) + i] * y2[j]);\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for collapse(1)"
    },
    "phramos07/taskminer/tests/Polybench/base/omp/SYR2K/syr2k/27": {
        "code": "for (i = 0; i < 64; i++)\n{\n  for (j = 0; j < 64; j++)\n  {\n    for (k = 0; k < 64; k++)\n    {\n      C[(i * 64) + j] += (12435 * A[(i * 64) + k]) * B[(j * 64) + k];\n      C[(i * 64) + j] += (12435 * B[(i * 64) + k]) * A[(j * 64) + k];\n    }\n\n  }\n\n}\n",
        "pragma": ""
    },
    "phramos07/taskminer/tests/UniBenchBack/benchmarks/Rodinia/bfs/src/bfs-AI-AI/7": {
        "code": "for (int tid = 0; tid < no_of_nodes; tid++)\n{\n  if (h_updating_graph_mask[tid] == 1)\n  {\n    h_graph_mask[tid] = 1;\n    h_graph_visited[tid] = 1;\n    stop = 1;\n    h_updating_graph_mask[tid] = 0;\n  }\n\n}\n",
        "pragma": ""
    },
    "pnookala/MIC_OpenMP_GeMTC/src/Apps/MatrixMul/1": {
        "code": "for (; r < rows; r++)\n{\n  int c = 0;\n  for (; c < cols; c++)\n  {\n    mat[(r * cols) + c] = rand() % 10;\n  }\n\n}\n",
        "pragma": ""
    },
    "polizois/parallel_pageRank/pagerank_gs_omp/7": {
        "code": "for (i = 0; i < rows; i++)\n{\n  if (!fread(&dest[i][0], sizeof(double), cols, file))\n  {\n    printf(\"Unable to read Matrix from file!\");\n    return 1;\n  }\n\n}\n",
        "pragma": ""
    },
    "poodarchu/parallel-computing/OpenMP+MPI/hybrid_matrix_multiply/1": {
        "code": "for (irow = 0; irow < num_rows; irow++)\n{\n  Matrix[irow] = (float *) malloc(num_cols * (sizeof(float)));\n  for (icol = 0; icol < num_cols; icol++)\n  {\n    fscanf(fp, \"%f\", &Matrix[irow][icol]);\n  }\n\n}\n",
        "pragma": ""
    },
    "prateek18597/OpenMP-Programs/3_MatrixMul/2": {
        "code": "for (i = 0; i < 1024; i++)\n{\n  for (j = 0; j < 124; j++)\n  {\n    A[i][j] = 11 + j;\n  }\n\n}\n",
        "pragma": ""
    },
    "praveenChauhan686/Strassen-Algorithm-Java-And-OpenMp/Assignment 2_21261912/Source Code/OpenMp C/strassens_algorithm/7": {
        "code": "for (i = 0; i < newsize; i++)\n{\n  memOne[i] = (double *) malloc((sizeof(double)) * newsize);\n  memTwo[i] = (double *) malloc((sizeof(double)) * newsize);\n}\n",
        "pragma": ""
    },
    "puneetar/Parallel-LU-Factorization-with-OpenMP-MPI/OpenMP/OpenMP/2": {
        "code": "for (i = 0; i < n; i++)\n{\n  if (A[i][i] != 1)\n  {\n    return 0;\n  }\n\n  for (j = 0; j < n; j++)\n  {\n    if ((i != j) && (A[i][j] != 2))\n    {\n      return 0;\n    }\n\n  }\n\n}\n",
        "pragma": ""
    },
    "purvilmehta06/High-Performance-Computing/Lab_2/Calculate Pi/Approach 2/parallel/0": {
        "code": "for (i = 1; i < n; i++)\n  area = area + sqrt(4 - ((a + (i * h)) * (a + (i * h))));\n",
        "pragma": "#pragma omp parallel for reduction(+:area)"
    },
    "qazwse/RedBlueOpenMP/orbs/10": {
        "code": "for (int i = 0; i < 5; i++)\n{\n  if (argCheck[i] == 0)\n  {\n    printf(\"Missing required argument.\\n\");\n    printf(\"Usage: rbs p[1..] b[2..] t[1..] c[1..100] m[1..] [s] [i]\\n\");\n    exit(1);\n  }\n\n}\n",
        "pragma": ""
    },
    "qiongsiwu/PolybenchOMP/OmpCPU/3DCONV/3DConvolution/2": {
        "code": "for (i = 1; i < (256 - 1); ++i)\n{\n  for (j = 1; j < (256 - 1); ++j)\n  {\n    for (k = 1; k < (256 - 1); ++k)\n    {\n      if (percentDiff(B[((i * (256 * 256)) + (j * 256)) + k], B_outputFromOMP[((i * (256 * 256)) + (j * 256)) + k]) > 0.5)\n      {\n        fail++;\n      }\n\n    }\n\n  }\n\n}\n",
        "pragma": ""
    },
    "qiongsiwu/PolybenchOMP/OmpGPU/COVAR/covariance/0": {
        "code": "for (j1 = 1; j1 < (2048 + 1); j1++)\n{\n  for (j2 = 1; j2 < (2048 + 1); j2++)\n  {\n    symmat[(j1 * (2048 + 1)) + j2] = 0.0;\n    for (i = 1; i < (2048 + 1); i++)\n    {\n      symmat[(j1 * (2048 + 1)) + j2] += data[(i * (2048 + 1)) + j1] * data[(i * (2048 + 1)) + j2];\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp distribute parallel for collapse(2) private(j1, j2, i)"
    },
    "quangphan2405/parallel_computing/openMP/parallel/4": {
        "code": "for (int i = 0; i < (1024 * 1024); ++i)\n{\n  floatvector pixel = {.x = i % 1024, .y = i / 1024};\n  color renderColor = {.red = 0.f, .green = 0.f, .blue = 0.f};\n  float shortestDistance = INFINITY;\n  float weights = 0.f;\n  int hitsSatellite = 0;\n  for (int j = 0; j < 64; ++j)\n  {\n    floatvector difference = {.x = pixel.x - satelites[j].position.x, .y = pixel.y - satelites[j].position.y};\n    float distance = sqrt((difference.x * difference.x) + (difference.y * difference.y));\n    if (distance < 3.16f)\n    {\n      renderColor.red = 1.0f;\n      renderColor.green = 1.0f;\n      renderColor.blue = 1.0f;\n      hitsSatellite = 1;\n      break;\n    }\n    else\n    {\n      float weight = 1.0f / (((distance * distance) * distance) * distance);\n      weights += weight;\n      if (distance < shortestDistance)\n      {\n        shortestDistance = distance;\n        renderColor = satelites[j].identifier;\n      }\n\n    }\n\n  }\n\n  if (!hitsSatellite)\n  {\n    for (int j = 0; j < 64; ++j)\n    {\n      floatvector difference = {.x = pixel.x - satelites[j].position.x, .y = pixel.y - satelites[j].position.y};\n      float dist2 = (difference.x * difference.x) + (difference.y * difference.y);\n      float weight = 1.0f / (dist2 * dist2);\n      renderColor.red += ((satelites[j].identifier.red * weight) / weights) * 3.0f;\n      renderColor.green += ((satelites[j].identifier.green * weight) / weights) * 3.0f;\n      renderColor.blue += ((satelites[j].identifier.blue * weight) / weights) * 3.0f;\n    }\n\n  }\n\n  correctPixels[i] = renderColor;\n}\n",
        "pragma": ""
    },
    "rachnasidana28/ParallelProcessing/Floyd Warshall/OpenMp/2": {
        "code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n    if (i == j)\n    mat[i][j] = 0;\n  else\n  {\n    if ((((i == (j + 1)) || (j == (i + 1))) || ((i == 0) && (j == (n - 1)))) || ((i == (n - 1)) && (j == 0)))\n      mat[i][j] = 1;\n    else\n      mat[i][j] = n;\n\n  }\n\n\n}\n",
        "pragma": ""
    },
    "rainaby/quakeSimulatorOpenMP/superQuakeV2/16": {
        "code": "for (i = 0; i < 12; i++)\n  for (j = 0; j <= i; j++)\n  Ke[j][i] = Ke[i][j];\n\n",
        "pragma": ""
    },
    "rajatkhanna1999/OpenMpCodes/MatrixMultiplictaion/2": {
        "code": "for (i = 0; i < 512; i++)\n{\n  for (j = 0; j < 512; j++)\n  {\n    printf(\"%d \", c[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n",
        "pragma": ""
    },
    "rajshrestha86/kmeans-clusterize/openmp/kmeans_omp/2": {
        "code": "for (int i = 0; i < model->no_clusters; i++)\n{\n  cluster_count[i] = 0;\n  for (int c = 0; c < model->columns; c++)\n  {\n    sum_cluster_columns[(i * model->columns) + c] = 0;\n  }\n\n}\n",
        "pragma": ""
    },
    "raul4247/openmpSortings/OddEvenSort/oddEvenSort/0": {
        "code": "for (j = 0; j < (size - 1); j += 2)\n{\n  if (arr[j] > arr[j + 1])\n  {\n    tmp = arr[j];\n    arr[j] = arr[j + 1];\n    arr[j + 1] = tmp;\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for private(tmp, j) shared(arr)"
    },
    "reedv/Tircis/tircis_process_cmd_v4/svbksb_d/1": {
        "code": "for (i = 1; i <= m; i++)\n  s += u[i][j] * b[i];\n",
        "pragma": "#pragma omp parallel for if(m > 100)"
    },
    "reinaldoasf/libgomp/testsuite/libgomp.c-c++-common/for-16/17": {
        "code": "for (j = 0; j < k; j++)\n  b[j + 128] = j + 128;\n",
        "pragma": "#pragma omp for schedule (nonmonotonic: dynamic)"
    },
    "rektplorer64/ITCS443-A1_OpenMP_Bucket_Sort/main/13": {
        "code": "for (int k = 0; k < BUCKET_AMOUNT; k++)\n{\n  bucketDataCount[k] = 0;\n}\n",
        "pragma": ""
    },
    "renanrdgsrodrigues/Progamacao-Paralela/gauss_sequencial/0": {
        "code": "for (i = 0; i < 3; i++)\n  for (j = 0; j < 4; j++)\n  printf(\"%d \", matrix[i][j]);\n\n",
        "pragma": ""
    },
    "rhuamachuco/OpenMP/exercise5-5/5": {
        "code": "for (int x = 0; x < N; x++)\n{\n  printf(\"| \");\n  for (int y = 0; y < N; y++)\n    printf(\"%7.2f \", A[x][y]);\n\n  printf(\"| | %7.2f |\\n\", b[x]);\n}\n",
        "pragma": ""
    },
    "rinriko/OpenMPI_SSCA2.2/utils/4": {
        "code": "for (i = 1; i < (n + 1); i++)\n{\n  result[i] = result[i - 1] + input[i - 1];\n}\n",
        "pragma": ""
    },
    "ritika-07/PDC/OpenMP/search/2": {
        "code": "for (i = 1; i <= (k - 1); i++)\n{\n  s[i] = (left + (interval * i)) - 1;\n  tid = omp_get_thread_num();\n  printf(\"Thread number %d allocated s[%d]=%d\\n\", tid, i, s[i]);\n}\n",
        "pragma": "#pragma omp parallel for num_threads(k-1)"
    },
    "rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/CG/cg/19": {
        "code": "for (i = 0; i < n; i++)\n{\n  for (nza = 0; nza < arow[i]; nza++)\n  {\n    j = acol[i][nza];\n    if ((j >= ilow) && (j < ihigh))\n    {\n      j = j + 1;\n      rowstr[j] = rowstr[j] + arow[i];\n    }\n\n  }\n\n}\n",
        "pragma": ""
    },
    "rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/IS/is/17": {
        "code": "for (i = 0; i < (1 << 10); i++)\n{\n  k1 = i * num_bucket_keys;\n  k2 = k1 + num_bucket_keys;\n  for (k = k1; k < k2; k++)\n    key_buff_ptr[k] = 0;\n\n  m = (i > 0) ? (bucket_ptrs[i - 1]) : (0);\n  for (k = m; k < bucket_ptrs[i]; k++)\n    key_buff_ptr[key_buff_ptr2[k]]++;\n\n  key_buff_ptr[k1] += m;\n  for (k = k1 + 1; k < k2; k++)\n    key_buff_ptr[k] += key_buff_ptr[k - 1];\n\n}\n",
        "pragma": "#pragma omp for schedule(dynamic)"
    },
    "rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/LU/pintgr/0": {
        "code": "for (j = jbeg; j < jfin; j++)\n{\n  for (i = ibeg; i < ifin; i++)\n  {\n    k = ki1;\n    phi1[j][i] = C2 * (u[k][j][i][4] - ((0.50 * (((u[k][j][i][1] * u[k][j][i][1]) + (u[k][j][i][2] * u[k][j][i][2])) + (u[k][j][i][3] * u[k][j][i][3]))) / u[k][j][i][0]));\n    k = ki2 - 1;\n    phi2[j][i] = C2 * (u[k][j][i][4] - ((0.50 * (((u[k][j][i][1] * u[k][j][i][1]) + (u[k][j][i][2] * u[k][j][i][2])) + (u[k][j][i][3] * u[k][j][i][3]))) / u[k][j][i][0]));\n  }\n\n}\n",
        "pragma": "#pragma omp for nowait"
    },
    "rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/SP/pinvr/0": {
        "code": "for (k = 1; k <= nz2; k++)\n{\n  for (j = 1; j <= ny2; j++)\n  {\n    for (i = 1; i <= nx2; i++)\n    {\n      r1 = rhs[k][j][i][0];\n      r2 = rhs[k][j][i][1];\n      r3 = rhs[k][j][i][2];\n      r4 = rhs[k][j][i][3];\n      r5 = rhs[k][j][i][4];\n      t1 = bt * r1;\n      t2 = 0.5 * (r4 + r5);\n      rhs[k][j][i][0] = bt * (r4 - r5);\n      rhs[k][j][i][1] = -r3;\n      rhs[k][j][i][2] = r2;\n      rhs[k][j][i][3] = (-t1) + t2;\n      rhs[k][j][i][4] = t1 + t2;\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for default(shared) private(i,j,k,r1,r2,r3,r4,r5,t1,t2)"
    },
    "rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/diffuse/9": {
        "code": "for (iz = 0; iz < LX1; iz++)\n{\n  for (k = 0; k < LX1; k++)\n  {\n    for (j = 0; j < LX1; j++)\n    {\n      for (i = 0; i < LX1; i++)\n      {\n        tm1[iz][j][i] = tm1[iz][j][i] + (wdtdr[k][i] * u[iz][j][k]);\n      }\n\n    }\n\n  }\n\n}\n",
        "pragma": ""
    },
    "rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/precond/4": {
        "code": "for (iel = 0; iel < nelt; iel++)\n{\n  for (iside = 0; iside < NSIDES; iside++)\n  {\n    for (i = 0; i < 4; i++)\n    {\n      edgevis[iel][iside][i] = 0;\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp for"
    },
    "rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/transfer_au/0": {
        "code": "for (i = 0; i < (8 * LELT); i++)\n{\n  omp_init_lock(&tlock[i]);\n}\n",
        "pragma": "#pragma omp parallel for default(shared) private(i)"
    },
    "rmoleary/Gadget-2-openmp/density/0": {
        "code": "for (i = oldI; i < N_gas; i++)\n{\n  if (P[i].Ti_endstep == All.Ti_Current)\n  {\n    ndone++;\n    for (j = 0; j < NTask; j++)\n    {\n      Exportflag2[(i * NTask) + j] = 0;\n    }\n\n    density_evaluate(i, 0);\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for reduction(+:ndone)"
    },
    "rodrigoborgesdeoliveira/Matrix-Multiplication-and-Sum-with-OpenMP-and-PThreads/Matrizes OpenMP/matriz2d/7": {
        "code": "for (i = 0; i < lin; i++)\n{\n  for (j = 0; j < col; j++)\n    fprintf(arquivo, \"%d\\n\", matriz[i][j]);\n\n}\n",
        "pragma": ""
    },
    "rodrigoecheverria/openmp-lab/masterOMP/4": {
        "code": "for (j = 0; j < N; j++)\n  M[j] = 0.5 + (((double) rand()) / 32767);\n",
        "pragma": ""
    },
    "rodrigovimieiro/OpenCodes/Programming/Parallel programming/OpenMP/Jacobi/jacobipar/4": {
        "code": "for (int i = 0; i < rank; i++)\n  x_k[i] = x[i];\n",
        "pragma": "#pragma omp parallel for schedule(static) num_threads(nTreads)"
    },
    "rogerioag/openmp-hook/tests/mm/omp_mm/0": {
        "code": "for (i = 0; i < 512; i++)\n  for (j = 0; j < 512; j++)\n  a[i][j] = i + j;\n\n",
        "pragma": "#pragma omp for schedule (dynamic, chunk)"
    },
    "rogerioag/openmp-hook/tests/vectoradd/vectoradd-omp-parallel-for-combined-schedule-dynamic-chunk-value/2": {
        "code": "for (i = 0; i < 1048576; i++)\n{\n  fprintf(stdout, \"Thread [%02d]: h_c[%07d]: %f\\n\", omp_get_thread_num(), i, h_c[i]);\n}\n",
        "pragma": ""
    },
    "rogerioag/openmp.info/src/check-libgomp/python/gcc_5_1_0_release/testsuite/libgomp.c/examples-4/e.54.6/0": {
        "code": "for (i = 0; i < n; i++)\n  p[i] = v1[i] * v2[i];\n",
        "pragma": "#pragma omp distribute parallel for simd"
    },
    "rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/pr66714/0": {
        "code": "for (i = 0; i < x; i++)\n  b[i] += 1;\n",
        "pragma": "#pragma omp parallel for"
    },
    "rose-compiler/rose/projects/CodeThorn/src/tests/polyopt/jacobi-2d-imper_orig_tileonly_size16_tile_8_2_1/2": {
        "code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n{\n  fprintf(stderr, \"%0.2lf \", A[i][j]);\n  if ((((i * n) + j) % 20) == 0)\n  {\n    fprintf(stderr, \"\\n\");\n  }\n\n}\n\n",
        "pragma": ""
    },
    "rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/FT/ft_single/38": {
        "code": "for (i = 0; i < 3; i++)\n{\n  dims[i][0] = 64;\n  dims[i][1] = 64;\n  dims[i][2] = 64;\n}\n",
        "pragma": ""
    },
    "rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/SP/sp_single/8": {
        "code": "for (i = 0; i <= (PROBLEM_SIZE - 1); i++)\n{\n  for (j = 0; j <= (PROBLEM_SIZE - 1); j++)\n  {\n    for (k = 0; k <= (PROBLEM_SIZE - 1); k++)\n    {\n      u[0][i][j][k] = 1.0;\n      u[1][i][j][k] = 0.0;\n      u[2][i][j][k] = 0.0;\n      u[3][i][j][k] = 0.0;\n      u[4][i][j][k] = 1.0;\n    }\n\n  }\n\n}\n",
        "pragma": ""
    },
    "rose-compiler/rose/projects/autoParallelization/tests/references/rose_pointers/0": {
        "code": "for (int i = begin; i <= (end - 1); i += 1)\n{\n  x1[i] += rh1;\n  x2[i] -= rh1;\n}\n",
        "pragma": "#pragma omp parallel for firstprivate (end,rh1)"
    },
    "royess/SimplifiedNeutronScattering/neutron_openmp/1": {
        "code": "for (int i = 1; i <= n; ++i)\n{\n  x = 0;\n  costhe = 1;\n  while ((x >= 0) & (x <= a))\n  {\n    x -= (b * costhe) * log(r2());\n    if (r2() < p)\n    {\n      count++;\n      break;\n    }\n    else\n    {\n      costhel = (2 * r2()) - 1;\n      costhe = (costhe * costhel) + ((sqrt(1 - (costhe * costhe)) * sqrt(1 - (costhel * costhel))) * cos((2 * M_PI) * r2()));\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for private(x, costhe, costhel) reduction(+:count) schedule(guided,1)"
    },
    "rtahmasbi/Parallel_Computing/OpenMP/ex4/2": {
        "code": "for (unsigned long int i = 0; i < MAX; i++)\n  A[i] = i + 1;\n",
        "pragma": ""
    },
    "ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/3MM/3mm/2": {
        "code": "for (i = 0; i < 1500; i++)\n{\n  for (j = 0; j < 1500; j++)\n  {\n    G[(i * 1500) + j] = 0;\n    for (k = 0; k < 1500; ++k)\n    {\n      G[(i * 1500) + j] += E[(i * 1500) + k] * F[(k * 1500) + j];\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for collapse(2)"
    },
    "ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/CORR/correlation_cpu/7": {
        "code": "for (i = 1; i < (4096 + 1); i++)\n{\n  for (j = 1; j < (4096 + 1); j++)\n  {\n    data[(i * (4096 + 1)) + j] -= mean[j];\n    data[(i * (4096 + 1)) + j] /= sqrt(3214212.01f) * stddev[j];\n  }\n\n}\n",
        "pragma": ""
    },
    "ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/GEMM/gemm_cpu/5": {
        "code": "for (i = 0; i < 3072; i++)\n{\n  for (j = 0; j < 3072; j++)\n  {\n    A[(i * 3072) + j] = (((DATA_TYPE) i) * j) / 3072;\n  }\n\n}\n",
        "pragma": ""
    },
    "ruixueqingyang/OAO-Translator/benchmarks/Rodina/openmp/lavaMD/OneFile/1": {
        "code": "for (; (*str) != '\\0'; str++)\n{\n  if (((*str) < 48) || ((*str) > 57))\n  {\n    return 0;\n  }\n\n}\n",
        "pragma": ""
    },
    "ryszard-put/PR-openmp-cuda/matrix-parallel/0": {
        "code": "for (i = 0; i < size; i++)\n{\n  for (j = 0; j < size; j++)\n  {\n    int sum = 0;\n    for (k = 0; k < size; k++)\n    {\n      sum += matrix[i][k] * matrix[k][j];\n    }\n\n    result[i][j] = sum;\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for shared(matrix, result, size) private(i,j,k)"
    },
    "s27y/openmp_matrixmultip/openmp_matrixmultip/5": {
        "code": "for (i = 4; i < 11; i++)\n{\n  matrix_size = pow(2, i);\n  A = malloc_matrix(matrix_size);\n  B = malloc_matrix(matrix_size);\n  C = malloc_matrix(matrix_size);\n  init_matrix(A, B, matrix_size);\n  for (j = 0; j < numreps; j++)\n  {\n    gettimeofday(&tv1, &tz);\n    multiply_matrix_omp_static(A, B, C, matrix_size);\n    one_norm_omp_static = matrix_one_norm_omp(C, matrix_size);\n    gettimeofday(&tv2, &tz);\n    elapsed = ((double) (tv2.tv_sec - tv1.tv_sec)) + (((double) (tv2.tv_usec - tv1.tv_usec)) * 1.e-6);\n    average += elapsed;\n    printf(\"matrix size %d, matrix_one_norm_omp takes %lf sec \\n\", matrix_size, elapsed);\n  }\n\n  average = average / 3;\n  WriteData(\"out_omp_static.csv\", matrix_size, average);\n}\n",
        "pragma": ""
    },
    "satyamramawat/Large_Multiplication_Matrix_OPENMP/19210520_CA670_Assignment_2/Code/5": {
        "code": "for (int i = 0; i < iterations; i++)\n{\n  TYPE **matrixResult = zeroSquareMatrix(dimension);\n  opmLatency[i] = ikj_algorithm(matrixA, matrixB, matrixResult, dimension);\n  free(matrixResult);\n  printf(\"%d.\\t%f\\n\", i + 1, opmLatency[i]);\n  fprintf(fp, \"%d.\\t%f\\n\", i + 1, opmLatency[i]);\n}\n",
        "pragma": ""
    },
    "savvpais/omp-pagerank/pageRankGSOMP/8": {
        "code": "for (i = 0; i < N; i++)\n  k = fscanf(file, \"%lf\", &testVec[i]);\n",
        "pragma": ""
    },
    "sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi/bfs_replicated/0": {
        "code": "for (i = 0; i < nlocalverts; ++i)\n  pred[i] = -1;\n",
        "pragma": "#pragma omp parallel for schedule(static)"
    },
    "sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/isx/isx_omp/2": {
        "code": "for (uint64_t i = 0; i < (NUM_ITERATIONS + BURN_IN); ++i)\n{\n  if (i == BURN_IN)\n  {\n    init_timers(NUM_ITERATIONS);\n  }\n\n  {\n    timer_start(&timers[TIMER_BARRIER_START]);\n    shmem_barrier_all();\n    timer_stop(&timers[TIMER_BARRIER_START]);\n  }\n  ;\n  timer_start(&timers[TIMER_TOTAL]);\n  KEY_TYPE *my_keys = make_input();\n  int **bucket_counts_per_chunk;\n  int *local_bucket_sizes = count_local_bucket_sizes(my_keys, &bucket_counts_per_chunk);\n  int *send_offsets;\n  int *local_bucket_offsets = compute_local_bucket_offsets(local_bucket_sizes, &send_offsets);\n  KEY_TYPE *my_local_bucketed_keys = bucketize_local_keys(my_keys, local_bucket_offsets, bucket_counts_per_chunk);\n  KEY_TYPE *my_bucket_keys = exchange_keys(send_offsets, local_bucket_sizes, my_local_bucketed_keys);\n  my_bucket_size = receive_offset;\n  int *my_local_key_counts = count_local_keys(my_bucket_keys);\n  {\n    timer_start(&timers[TIMER_BARRIER_END]);\n    shmem_barrier_all();\n    timer_stop(&timers[TIMER_BARRIER_END]);\n  }\n  ;\n  timer_stop(&timers[TIMER_TOTAL]);\n  if (i == NUM_ITERATIONS)\n  {\n    err = verify_results(my_local_key_counts, my_bucket_keys);\n  }\n\n  receive_offset = 0;\n  free(my_local_bucketed_keys);\n  free(my_keys);\n  free(local_bucket_sizes);\n  free(local_bucket_offsets);\n  free(send_offsets);\n  free(my_local_key_counts);\n  for (int i = 0; i < num_threads; i++)\n  {\n    free(bucket_counts_per_chunk[i]);\n  }\n\n  free(bucket_counts_per_chunk);\n  shmem_barrier_all();\n}\n",
        "pragma": ""
    },
    "sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/einspline/time_multi_new/11": {
        "code": "for (int i = 0; i < num_vals; i++)\n{\n  double rx = drand48();\n  double x = (rx * x_grid.start) + ((1.0 - rx) * x_grid.end);\n  double ry = drand48();\n  double y = (ry * y_grid.start) + ((1.0 - ry) * y_grid.end);\n  double rz = drand48();\n  double z = (rz * z_grid.start) + ((1.0 - rz) * z_grid.end);\n  for (int j = 0; j < num_splines; j++)\n    eval_UBspline_3d_d_vgh(norm_splines[j], x, y, z, &norm_vals[j], &norm_grads[3 * j], &norm_hess[9 * j]);\n\n}\n",
        "pragma": ""
    },
    "sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/rodinia/particlefilter/ex_particle_OPENMP_seq.balance/7": {
        "code": "for (x = 0; x < Nparticles; x++)\n{\n  ____num_tasks[omp_get_thread_num()]++;\n  {\n    xe += arrayX[x] * weights[x];\n    ye += arrayY[x] * weights[x];\n  }\n  ;\n}\n",
        "pragma": "#pragma omp parallel for private(x) reduction(+:xe, ye)"
    },
    "sc3260s16/openmp/parallel-for/for-loop/0": {
        "code": "for (i = 0; i < 1000; i++)\n{\n  printf(\"thread id: %d, i: %d\\n\", tid, i);\n  c[i] = a[i] + b[i];\n}\n",
        "pragma": "#pragma omp for schedule(dynamic,chunk) nowait"
    },
    "scimas/traffic-ca/traffic_parallel/3": {
        "code": "for (int i = 0; i < sim->LANES; i++)\n{\n  for (int j = 0; j < sim->L; j++)\n  {\n    new_grid[(sim->L * i) + j] = -1;\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "sdasgup3/parallel-programming/OpenMP/Add_Mult_Transpose_Tile/MatrixMultipy/multiply_parallel_inner_for/0": {
        "code": "for (k = 0; k < 1000; k++)\n{\n  sum += A[i][k] * B[k][j];\n}\n",
        "pragma": "#pragma omp for"
    },
    "sebmancipe/openmp-c-ppf/als-movie-recommender/main/10": {
        "code": "for (int i = 0; i < rows; i++)\n{\n  matrix[i][nCol] = newCol[i];\n}\n",
        "pragma": ""
    },
    "seiji19761225/c-ray/c-ray/1": {
        "code": "for (i = 1; i < argc; i++)\n{\n  if ((argv[i][0] == '-') && (argv[i][2] == 0))\n  {\n    char *sep;\n    switch (argv[i][1])\n    {\n      case 's':\n        if (((!isdigit(argv[++i][0])) || (!(sep = strchr(argv[i], 'x')))) || (!isdigit(*(sep + 1))))\n      {\n        fputs(\"-s must be followed by something like \\\"640x480\\\"\\n\", stderr);\n        return 1;\n      }\n\n        xres = atoi(argv[i]);\n        yres = atoi(sep + 1);\n        aspect = ((double) xres) / ((double) yres);\n        break;\n\n      case 'i':\n        if (!(infile = fopen(argv[++i], \"r\")))\n      {\n        fprintf(stderr, \"failed to open input file %s: %s\\n\", argv[i], strerror(errno));\n        return 1;\n      }\n\n        break;\n\n      case 'o':\n        if (!(outfile = fopen(argv[++i], \"w\")))\n      {\n        fprintf(stderr, \"failed to open output file %s: %s\\n\", argv[i], strerror(errno));\n        return 1;\n      }\n\n        break;\n\n      case 'r':\n        if (!isdigit(argv[++i][0]))\n      {\n        fputs(\"-r must be followed by a number (rays per pixel)\\n\", stderr);\n        return 1;\n      }\n\n        rays_per_pixel = atoi(argv[i]);\n        break;\n\n      case 'h':\n        fputs(usage, stdout);\n        return 0;\n\n      default:\n        fprintf(stderr, \"unrecognized argument: %s\\n\", argv[i]);\n        fputs(usage, stderr);\n        return 1;\n\n    }\n\n  }\n  else\n  {\n    fprintf(stderr, \"unrecognized argument: %s\\n\", argv[i]);\n    fputs(usage, stderr);\n    return 1;\n  }\n\n}\n",
        "pragma": ""
    },
    "shanky1947/Parallel-Job-Scheduling-Algorithms-using-OpenMP/LJF_Parallel/0": {
        "code": "for (i = 0; i < limit; i++)\n{\n  if ((burst_time[i] >= max_val) && (arrival_time[i] <= time))\n  {\n    smallest = i;\n    max_val = burst_time[smallest];\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for shared(i) reduction(max : max_val)"
    },
    "sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/appendix-a/a.8.1/0": {
        "code": "for (i = 0; i < m; i++)\n  y[i] = sqrt(z[i]);\n",
        "pragma": "#pragma omp for nowait"
    },
    "sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/collapse-1/2": {
        "code": "for (i = 0; i < 5; i++)\n{\n  int k = foo();\n  {\n    {\n      for (j = 0; j < 5; j++)\n      {\n      }\n\n    }\n  }\n}\n",
        "pragma": "#pragma omp for collapse (2)"
    },
    "sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/16": {
        "code": "for (i = 5; i < 16; i = baz(&i) + i)\n  ;\n",
        "pragma": "#pragma omp for"
    },
    "sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/66": {
        "code": "for (int i = 0; i < 16; i++)\n  for (int j = 0; j < 16; j = j + i)\n  ;\n\n",
        "pragma": "#pragma omp for collapse(2)"
    },
    "sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/pr39495-1/13": {
        "code": "for (i = ((-0x7fffffff) - 1) + 6; i >= (((-0x7fffffff) - 1) + 1); i -= 2)\n  ;\n",
        "pragma": "#pragma omp for"
    },
    "sheetal804/Parallel-Processing-Repo/omp/chunk/0": {
        "code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    s = 0;\n    for (k = 0; k < n; k++)\n    {\n      c[i][j] += a[j][k] * b[k][j];\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for schedule(static,chunk)"
    },
    "shivgarg/sudoku/sudoku/17": {
        "code": "for (k = 0; k < SIZE; k++)\n{\n  int x = (k % MINIGRIDSIZE) * MINIGRIDSIZE;\n  int y = (k / MINIGRIDSIZE) * MINIGRIDSIZE;\n  for (i = 0; i < SIZE; i++)\n  {\n    for (j = i + 1; j < SIZE; j++)\n    {\n      int l1;\n      int l2;\n      int cnt = 0;\n      int first = 0;\n      int second = 0;\n      int positionx[2];\n      int positiony[2];\n      for (l1 = x; l1 < (x + MINIGRIDSIZE); l1++)\n        for (l2 = y; l2 < (y + MINIGRIDSIZE); l2++)\n      {\n        if (forward_map[l1][l2][i] == 0)\n        {\n          first |= 1 << ((l1 * MINIGRIDSIZE) + l2);\n          if (cnt <= 1)\n          {\n            positionx[cnt] = l1;\n            positiony[cnt] = l2;\n          }\n          else\n          {\n            cnt = 0;\n            break;\n          }\n\n          cnt++;\n        }\n\n        if (forward_map[l1][l2][j] == 0)\n          second |= 1 << ((l1 * MINIGRIDSIZE) + l2);\n\n      }\n\n\n      if ((cnt == 2) && (second == first))\n      {\n        for (l1 = 0; l1 < SIZE; l1++)\n        {\n          forward_map[positionx[0]][positiony[0]][l1] = 1;\n          forward_map[positionx[1]][positiony[1]][l1] = 1;\n        }\n\n        forward_map[positionx[0]][positiony[0]][j] = 0;\n        forward_map[positionx[0]][positiony[0]][i] = 0;\n        forward_map[positionx[1]][positiony[1]][j] = 0;\n        forward_map[positionx[1]][positiony[1]][i] = 0;\n      }\n\n    }\n\n  }\n\n}\n",
        "pragma": ""
    },
    "shubham-gaur/OpenMP/Matrix/Vector/main/4": {
        "code": "for (i = 0; i < n; ++i)\n{\n  for (j = 0; j < n; ++j)\n  {\n    a[i][j] = 10;\n    printf(\"%d \", a[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n",
        "pragma": ""
    },
    "skalogerakis/TUC_Parallel_Computer_Architecture/Smith-Waterman/OpenMP_FineGrained/main/1": {
        "code": "for (uint8_t i = 0; i < argc; i++)\n{\n  if (strcmp(argv[i], inVariable[0]) == 0)\n  {\n    REPORT = argv[++i];\n    nameBool = 1;\n  }\n\n  if (strcmp(argv[i], inVariable[1]) == 0)\n  {\n    INPUT = argv[++i];\n    if (strcmp(&INPUT[strlen(INPUT) - 4], \".txt\") != 0)\n    {\n      printf(\"Your input path does not end in .txt . Exiting.\\n\");\n      exit(-9);\n    }\n\n    inputBool = 1;\n  }\n\n  if (strcmp(argv[i], inVariable[2]) == 0)\n  {\n    MATCH = atoi(argv[++i]);\n    matchBool = 1;\n  }\n\n  if (strcmp(argv[i], inVariable[3]) == 0)\n  {\n    MISMATCH = atoi(argv[++i]);\n    misBool = 1;\n  }\n\n  if (strcmp(argv[i], inVariable[4]) == 0)\n  {\n    GAP = atoi(argv[++i]);\n    gapBool = 1;\n  }\n\n  if (strcmp(argv[i], inVariable[5]) == 0)\n  {\n    THREADS = atoi(argv[++i]);\n    threadBool = 1;\n  }\n\n}\n",
        "pragma": ""
    },
    "skitiz/Histograms/OMP Histogram/omphistogram/0": {
        "code": "for (unsigned long int i = 0; i < size; i++)\n{\n  size_t index = determine_index(buffer[i], endpoints, intervals);\n  occurences[index]++;\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "smallsimple/MatrixMultiplicationParallelization/PA2/PA2-BoboShi 2/PP2/PA2-Prob2-unr-2i/0": {
        "code": "for (k = 0; k < 128; k++)\n  for (l = k + 1; l < 128; l++)\n  for (i = 0; i < 128; i += 2)\n  for (j = 0; j < 128; j++)\n{\n  C[k][l] += 0.5 * ((A[l][i][j] * B[k][i][j]) + (A[k][i][j] * B[l][i][j]));\n  C[k][l] += 0.5 * ((A[l][i + 1][j] * B[k][i + 1][j]) + (A[k][i + 1][j] * B[l][i + 1][j]));\n}\n\n\n\n",
        "pragma": "#pragma omp for"
    },
    "soumasandesu/comp3046_proj2_ec/src/matrix/1": {
        "code": "for (i = 0; i < size; i++)\n{\n  X[i] = (double) ((rand() % 10) + 1);\n}\n",
        "pragma": ""
    },
    "soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/2-D Burgers Equation/2-D_Burgers_Equation/main/2": {
        "code": "for (int i = 1; i < (y_points - 1); i++)\n{\n  for (int j = 1; j < (x_points - 1); j++)\n  {\n    u_new[i][j] = (((u[i][j] + (((nu * del_t) / (del_x * del_x)) * ((u[i][j + 1] + u[i][j - 1]) - (2 * u[i][j])))) + (((nu * del_t) / (del_y * del_y)) * ((u[i + 1][j] + u[i - 1][j]) - (2 * u[i][j])))) - (((del_t / del_x) * u[i][j]) * (u[i][j] - u[i][j - 1]))) - (((del_t / del_y) * v[i][j]) * (u[i][j] - u[i - 1][j]));\n    v_new[i][j] = (((v[i][j] + (((nu * del_t) / (del_x * del_x)) * ((v[i][j + 1] + v[i][j - 1]) - (2 * v[i][j])))) + (((nu * del_t) / (del_y * del_y)) * ((v[i + 1][j] + v[i - 1][j]) - (2 * v[i][j])))) - (((del_t / del_x) * u[i][j]) * (v[i][j] - v[i][j - 1]))) - (((del_t / del_y) * v[i][j]) * (v[i][j] - v[i - 1][j]));\n  }\n\n}\n",
        "pragma": "#pragma omp for nowait"
    },
    "soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/Dynamic_Memory_Allocation/2-D_NonLinear_Convection/2-D_Nonlinear_Convection_Dynamic/main/3": {
        "code": "for (int i = 0; i < x_points; i++)\n{\n  *((u_new + (0 * x_points)) + i) = 1.0;\n  *((v_new + (0 * x_points)) + i) = 1.0;\n  *((u_new + ((y_points - 1) * x_points)) + i) = 1.0;\n  *((v_new + ((y_points - 1) * x_points)) + i) = 1.0;\n}\n",
        "pragma": "#pragma omp for nowait"
    },
    "spirosdelviniotis/parallel_programming/OpenMP/Pure_OpenMP_main/0": {
        "code": "for (ix = start; ix <= end; ix++)\n{\n  for (iy = 1; iy <= (ny - 2); iy++)\n  {\n    *((u2 + (ix * ny)) + iy) = ((*((u1 + (ix * ny)) + iy)) + (parms.cx * (((*((u1 + ((ix + 1) * ny)) + iy)) + (*((u1 + ((ix - 1) * ny)) + iy))) - (2.0 * (*((u1 + (ix * ny)) + iy)))))) + (parms.cy * (((*(((u1 + (ix * ny)) + iy) + 1)) + (*(((u1 + (ix * ny)) + iy) - 1))) - (2.0 * (*((u1 + (ix * ny)) + iy)))));\n  }\n\n}\n",
        "pragma": "#pragma omp for"
    },
    "srahul00/Connected-Components-OpenMP/OSAssignmentOpenMP/1": {
        "code": "for (int j = i - 1; j >= 0; j--)\n{\n  if (vertices[j] == x)\n    flagx = 0;\n\n  if (vertices[j] == y)\n    flagy = 0;\n\n}\n",
        "pragma": ""
    },
    "srrcboy/dijkstra-CUDA/dijkstra_serial/5": {
        "code": "for (i = 0; i < num_vertices; i++)\n{\n  if ((node_dist[i] < dist) && (visited_node[i] == 0))\n  {\n    node = i;\n    dist = node_dist[i];\n  }\n\n}\n",
        "pragma": ""
    },
    "stathismast/parallel-matrix-convolution/Versions/Openmp/color/6": {
        "code": "for (i = 0; i < (3 * (colsNumber / sqrt_comm_sz)); i = i + 3)\n{\n  for (int c = 0; c <= 2; c++)\n  {\n    topRow[i + c] = myArray[0][i + c];\n  }\n\n}\n",
        "pragma": ""
    },
    "stefanomoriconi/mpT3libs_master/mpT3libs/mpT3_eig/0": {
        "code": "for (i = 0; i < numel[0]; ++i)\n{\n  T3_eig(&H11_in[idx[i]], &H12_in[idx[i]], &H13_in[idx[i]], &H22_in[idx[i]], &H23_in[idx[i]], &H33_in[idx[i]], &El1[idx[i]], &El2[idx[i]], &El3[idx[i]], &Ev11[idx[i]], &Ev12[idx[i]], &Ev13[idx[i]], &Ev21[idx[i]], &Ev22[idx[i]], &Ev23[idx[i]], &Ev31[idx[i]], &Ev32[idx[i]], &Ev33[idx[i]]);\n  regOrthog(&Ev11[idx[i]], &Ev12[idx[i]], &Ev13[idx[i]], &Ev21[idx[i]], &Ev22[idx[i]], &Ev23[idx[i]], &Ev31[idx[i]], &Ev32[idx[i]], &Ev33[idx[i]]);\n  if ((((((((((((!((!rtIsInfF(El1[idx[i]])) && (!rtIsNaNF(El1[idx[i]])))) || (!((!rtIsInfF(El2[idx[i]])) && (!rtIsNaNF(El2[idx[i]]))))) || (!((!rtIsInfF(El3[idx[i]])) && (!rtIsNaNF(El3[idx[i]]))))) || (!((!rtIsInfF(Ev11[idx[i]])) && (!rtIsNaNF(Ev11[idx[i]]))))) || (!((!rtIsInfF(Ev12[idx[i]])) && (!rtIsNaNF(Ev12[idx[i]]))))) || (!((!rtIsInfF(Ev13[idx[i]])) && (!rtIsNaNF(Ev13[idx[i]]))))) || (!((!rtIsInfF(Ev21[idx[i]])) && (!rtIsNaNF(Ev21[idx[i]]))))) || (!((!rtIsInfF(Ev22[idx[i]])) && (!rtIsNaNF(Ev22[idx[i]]))))) || (!((!rtIsInfF(Ev23[idx[i]])) && (!rtIsNaNF(Ev23[idx[i]]))))) || (!((!rtIsInfF(Ev31[idx[i]])) && (!rtIsNaNF(Ev31[idx[i]]))))) || (!((!rtIsInfF(Ev32[idx[i]])) && (!rtIsNaNF(Ev32[idx[i]]))))) || (!((!rtIsInfF(Ev33[idx[i]])) && (!rtIsNaNF(Ev33[idx[i]])))))\n  {\n    El1[idx[i]] = 1.0F;\n    El2[idx[i]] = 1.0F;\n    El3[idx[i]] = 1.0F;\n    Ev11[idx[i]] = 1.0F;\n    Ev12[idx[i]] = 0.0F;\n    Ev13[idx[i]] = 0.0F;\n    Ev21[idx[i]] = 0.0F;\n    Ev22[idx[i]] = 1.0F;\n    Ev23[idx[i]] = 0.0F;\n    Ev31[idx[i]] = 0.0F;\n    Ev32[idx[i]] = 0.0F;\n    Ev33[idx[i]] = 1.0F;\n    mskValid[idx[i]] = 0;\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "stefanusgusega/mst-openmp-openmpi/src/MST_OpenMP/2": {
        "code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    scanf(\"%d\", &adj[i][j]);\n    if (adj[i][j] == (-1))\n      adj[i][j] = 100005;\n\n  }\n\n  visited[i] = 0;\n  min_edge[i][0] = 100005;\n  min_edge[i][1] = -1;\n}\n",
        "pragma": ""
    },
    "suicide-squad/heat-equation/modules/Kirill/src/multMV/1": {
        "code": "for (int i = 0; i < N; i++)\n{\n  result[i] = U[i] + (h * (((k1[i] + (2.0 * k2[i])) + (2.0 * k3[i])) + k4[i]));\n}\n",
        "pragma": "#pragma omp parallel for if (ENABLE_PARALLEL)"
    },
    "swag2198/Parallel-Programming/OpenMP/Rotation about arbitrary axis/16EE10056_16EE10063/10": {
        "code": "for (int j = 0; j < cols; ++j)\n{\n  for (int i = 0; i < 3; ++i)\n  {\n    fprintf(out_file, \"%lf\\t\", r7[i][j]);\n  }\n\n  fprintf(out_file, \"\\n\");\n}\n",
        "pragma": ""
    },
    "swapnilushinde/OpenMP_MPI_Sample_sort_algorithm/Source code/SSHINDE2/sampleSortOpenMP/15": {
        "code": "for (int i = 1; i < p; i++)\n{\n  {\n    sdispls[i] = sdispls[i - 1] + scounts[i - 1];\n  }\n}\n",
        "pragma": ""
    },
    "takashift/experimentB_OpenMP/reduction/1": {
        "code": "for (i = 0; i < 100000000; i++)\n  array[i] = i + 1;\n",
        "pragma": ""
    },
    "taniya-kapoor/OpenMP/jacobi_omp/10": {
        "code": "for (int i = 0; i < nx; i++)\n  for (int j = 0; j < ny; j++)\n  u[(i * nx) + j] = 0;\n\n",
        "pragma": ""
    },
    "tavorestrepo98/openMP/m9/mult_openmp9/0": {
        "code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    for (int k = 0; k < n; k++)\n    {\n      c[i][j] += a[i][k] * b[k][j];\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp distribute parallel for simd"
    },
    "tcreech/ppi/ppi/0": {
        "code": "for (i = 0; i < niter; i++)\n{\n  double x = ((double) rand_r(&seed)) / 32767;\n  double y = ((double) rand_r(&seed)) / 32767;\n  double z = (x * x) + (y * y);\n  if (z <= 1)\n    count++;\n\n}\n",
        "pragma": "#pragma omp for private(i) reduction(+:count) schedule(static)"
    },
    "terbos/HPC-OPENMP/forloop1/0": {
        "code": "for (i = 0; i < 1000; i++)\n{\n  c[i] = a[i] + b[i];\n  n = i / chunk;\n  t = omp_get_thread_num();\n  if ((i % chunk) == 0)\n    printf(\"Thread %d is doing chunk %d\\n\", t, n);\n\n}\n",
        "pragma": "#pragma omp for schedule(static,chunk)"
    },
    "terkelbo/OpenMP-Poisson-Problem/src/inittools_ccnuma/6": {
        "code": "for (i = 1; i < m; i++)\n  A[i] = A[0] + (i * n);\n",
        "pragma": ""
    },
    "tfurelaud/PAP/easypap-se/easypap-se/kernel/c/sable/36": {
        "code": "for (unsigned it = 1; it <= nb_iter; it++)\n{\n  changement = 0;\n  for (int i = 1; i < (GRAIN + 1); i += 1)\n    for (int j = 1; j < (GRAIN + 1); j += 1)\n  {\n    ;\n    if (!tab_unstable[(i * (GRAIN + 2)) + j])\n    {\n      if (((tab_unstable[((i - 1) * (GRAIN + 2)) + j] || tab_unstable[((i + 1) * (GRAIN + 2)) + j]) || tab_unstable[(i * (GRAIN + 2)) + (j - 1)]) || tab_unstable[(i * (GRAIN + 2)) + (j + 1)])\n        tab_unstable[(i * (GRAIN + 2)) + j] = do_tile_stable(((j - 1) * TILE_SIZE) + ((j - 1) == 0), ((i - 1) * TILE_SIZE) + ((i - 1) == 0), TILE_SIZE - (((((j - 1) * TILE_SIZE) + TILE_SIZE) == DIM) + ((j - 1) == 0)), TILE_SIZE - (((((i - 1) * TILE_SIZE) + TILE_SIZE) == DIM) + ((i - 1) == 0)), omp_get_thread_num());\n\n    }\n    else\n    {\n      tab_unstable[(i * (GRAIN + 2)) + j] = do_tile_unstable(((j - 1) * TILE_SIZE) + ((j - 1) == 0), ((i - 1) * TILE_SIZE) + ((i - 1) == 0), TILE_SIZE - (((((j - 1) * TILE_SIZE) + TILE_SIZE) == DIM) + ((j - 1) == 0)), TILE_SIZE - (((((i - 1) * TILE_SIZE) + TILE_SIZE) == DIM) + ((i - 1) == 0)), omp_get_thread_num());\n      changement += tab_unstable[(i * (GRAIN + 2)) + j];\n    }\n\n  }\n\n\n  if (changement == 0)\n    return it;\n\n}\n",
        "pragma": ""
    },
    "tgmattso/ATPESC/OMP_Exercises/Solutions/hist_par/4": {
        "code": "for (int i = 0; i < 50; i++)\n{\n  sumh += (double) hist[i];\n  sumhsq += ((double) hist[i]) * hist[i];\n}\n",
        "pragma": ""
    },
    "tgmattso/ParResKernels/OPENMP/Stencil/stencil/10": {
        "code": "for (j = 2; j < (n - 2); j++)\n  for (i = 2; i < (n - 2); i++)\n{\n  norm += (double) ABS(out[i + (j * n)]);\n}\n\n",
        "pragma": "#pragma omp for reduction(+:norm)"
    },
    "theompek/Parallel_Programming_Projects/GameOfLife_game/src/src/play/0": {
        "code": "for (i = 1; i < (numOfRows - 1); i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    a = adjacent_to(board, i, j, numOfRows, N);\n    if (a == 2)\n      NewBoard(i, j) = Board(i, j);\n\n    if (a == 3)\n      NewBoard(i, j) = 1;\n\n    if (a < 2)\n      NewBoard(i, j) = 0;\n\n    if (a > 3)\n      NewBoard(i, j) = 0;\n\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for schedule(static) private(i,j,a) shared(newboard,board,N)"
    },
    "thomcz/openmp-tries/src/vectors/1": {
        "code": "for (long i = 0; i < N; i++)\n{\n  printf(\"thread num: %d\\n\", 0);\n  sum += a[i] * b[i];\n}\n",
        "pragma": "#pragma omp parallel for reduction(+:sum)"
    },
    "tianyi93/hpxMP_mirror/examples/omp/benchmarks/LU/old/lu-dep-timed/1": {
        "code": "for (i = 0; i < N; i++)\n  for (j = 0; j < N; j++)\n  for (k = 0; k < N; k++)\n  A[(i * N) + j] += L[(i * N) + k] * U[(k * N) + j];\n\n\n",
        "pragma": "#pragma omp parallel for private(i,j,k)"
    },
    "timac11/openMP/parprog_matrix/3": {
        "code": "for (k = 0; k < size; k++)\n  for (l = 0; l < size; l++)\n{\n  matrix_A[k][l] = 2;\n  matrix_B[k][l] = 1;\n}\n\n",
        "pragma": ""
    },
    "timmitommi/DD2356-assignment-2/exercise-3/parallel_not_critical/1": {
        "code": "for (int i = 0; i < 32; i++)\n{\n  if (maxvals[i] > maxval)\n  {\n    maxval = maxvals[i];\n    maxloc = maxlocs[i];\n  }\n\n}\n",
        "pragma": ""
    },
    "tonibofarull/mini-openmp/miniomp/test/tfinal/1": {
        "code": "for (int i = 0; i < 100000; ++i)\n  total += (3 * i) * i;\n",
        "pragma": "#pragma omp for schedule(dynamic) reduction(+:total)"
    },
    "tozenda/mn-openmp/src/dot/10": {
        "code": "for (i; i < (2 * N); i += 1)\n{\n  if (((i * (incX + incY)) % 2) == 1)\n  {\n    dot[0] = dot[0] + (x[i * incX] * y[i * incY]);\n  }\n  else\n  {\n    if (((i * incX) % 2) == 0)\n      dot[1] = dot[1] + (x[i * incX] * y[i * incY]);\n    else\n      dot[1] = dot[1] - (x[i * incX] * y[i * incY]);\n\n  }\n\n}\n",
        "pragma": ""
    },
    "tr0j4n034/HPC-2019/Examples/MPI/checkpoint_openmp/1": {
        "code": "for (i = 0; i < size; i++)\n{\n  array1[i] = 1. * i;\n  array2[i] = 2. * i;\n}\n",
        "pragma": ""
    },
    "tseignette/lejeudelavie/src/vie/26": {
        "code": "for (unsigned it = 1; it <= nb_iter; it++)\n{\n  for (int x = 0; x < GRAIN; x++)\n  {\n    for (int y = 0; y < GRAIN; y++)\n    {\n      if (current_array[(x * GRAIN) + y] == 1)\n      {\n        current_array[(x * GRAIN) + y] = 0;\n        for (int i = TILEX * x; i < (TILEX * (x + 1)); i++)\n        {\n          for (int j = TILEY * y; j < (TILEY * (y + 1)); j++)\n          {\n            compute_new_state(i, j);\n            if ((cur_img(i, j) != next_img(i, j)) && ((cur_img(i, j) == 0xFFFF00FF) || (next_img(i, j) == 0xFFFF00FF)))\n            {\n              for (int k = max(0, x - 1); k <= min(GRAIN - 1, x + 1); k++)\n                for (int l = max(0, y - 1); l <= min(GRAIN - 1, y + 1); l++)\n                next_array[(k * GRAIN) + l] = 1;\n\n\n            }\n\n            if (next_img(i, j) != 0xFFFF00FF)\n            {\n              next_img(i, j) = 0xFF0000FF;\n            }\n\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n  swap_images();\n  int *tmp = current_array;\n  current_array = next_array;\n  next_array = tmp;\n}\n",
        "pragma": ""
    },
    "tudasc/CommPart/demo-codes/stencil-alike/0": {
        "code": "for (int i = 0; i < (1024 * 5); ++i)\n{\n  buffer[i] = i * rank;\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "uasys/openmp-split/tests/splitTesting/2MM/2mm/3": {
        "code": "for (i = 0; i < SIZE; i++)\n{\n  for (j = 0; j < SIZE; j++)\n  {\n    D[(i * SIZE) + j] = (((DATA_TYPE) i) * (j + 2)) / SIZE;\n  }\n\n}\n",
        "pragma": ""
    },
    "utpalbora/LLOV/test/3.race2/0": {
        "code": "for (int i = 1; i < 20; i++)\n  for (int j = 1; j < 20; j++)\n  for (int k = 1; k < 20; k++)\n  A[i][j][k] = A[i - 1][j][k];\n\n\n",
        "pragma": "#pragma omp parallel for"
    },
    "vanecaradonna/openMP/Ejercicio6/ejercicio6/0": {
        "code": "for (indice_columnas = 0; indice_columnas < columnas_a; indice_columnas++)\n{\n  a[indice_filas][indice_columnas] = ((indice_filas + 1) * columnas_a) - (columnas_a - (indice_columnas + 1));\n}\n",
        "pragma": "#pragma omp for"
    },
    "vazexqi/OpenMPMicroBenchmarks/ParallelFor_vs_ParallelTask/ART2/scanner_for/35": {
        "code": "for (i = 0; i < cimgheight; i++)\n{\n  cimage[i] = (unsigned char *) malloc(cimgwidth * (sizeof(unsigned char)));\n  if (cimage[i] == 0)\n  {\n    fprintf(stderr, \"Problems with malloc in loadimage()\\n\");\n    exit(1);\n  }\n\n}\n",
        "pragma": ""
    },
    "vhcandido/hpc-erad-2015/src/main/1": {
        "code": "for (i = k + 1; i < n; ++i)\n{\n  double m = A[i][k] / A[k][k];\n  if (m == 0)\n    continue;\n\n  for (j = k + 1; j <= n; ++j)\n  {\n    A[i][j] -= m * A[k][j];\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for schedule(guided) private(j)"
    },
    "vishwassathish/Parallel-computing-to-multiply-large-matrices/withmp/2": {
        "code": "for (i = 0; i < a_r; i++)\n{\n  for (j = 0; j < b_c; j++)\n  {\n    c[i][j] = 0;\n  }\n\n}\n",
        "pragma": "#pragma omp for schedule (static, chunk)"
    },
    "vlkale/lw-sched/share/ukernels/sgefa/9": {
        "code": "for (i = 0; i < n; i++)\n{\n  y[iy] = y[iy] + (a * x[ix]);\n  ix = ix + incx;\n  iy = iy + incy;\n}\n",
        "pragma": ""
    },
    "vmykh/parallel_computing_PDE/explicit/4": {
        "code": "for (int j = 0; j < ((int) ((0.5 - 0.1) / ((((0.05 * (0.7 - 0.1)) / ((double) 30)) * (0.7 - 0.1)) / ((double) 30)))); ++j)\n{\n  for (int i = 0; i < 30; ++i)\n  {\n    fprintf(debug, \"[x: %lf t: %lf u: %lf]\\n\", 0.1 + (((0.7 - 0.1) / ((double) 30)) * i), 0.1 + (((((0.05 * (0.7 - 0.1)) / ((double) 30)) * (0.7 - 0.1)) / ((double) 30)) * j), matrix[j][i]);\n    fprintf(f, \"%lf \", matrix[j][i]);\n  }\n\n  fprintf(f, \"\\n\");\n  fprintf(debug, \"\\n\");\n}\n",
        "pragma": ""
    },
    "vuvko/nmf_mpi/common/matrix/9": {
        "code": "for (j = 0; j < matrix->rows; ++j)\n{\n  for (i = 0; i < matrix->cols; ++i)\n  {\n    fprintf(fout, \"%.2lf \", matrix->data[(i * matrix->rows) + j]);\n  }\n\n  fprintf(fout, \"\\n\");\n}\n",
        "pragma": ""
    },
    "vvndn/openmp-lab/6.8/BoldompDeblur/2": {
        "code": "for (y = 0; y < OMP_yMax; y++)\n{\n  for (x = 0; x < OMP_xMax; x += 16)\n  {\n    int ind = OMP_Index(x, y, 0);\n    u[ind] *= boundryScale;\n    u[ind + 1] *= boundryScale;\n    u[ind + 2] *= boundryScale;\n    u[ind + 3] *= boundryScale;\n    u[ind + 4] *= boundryScale;\n    u[ind + 5] *= boundryScale;\n    u[ind + 6] *= boundryScale;\n    u[ind + 7] *= boundryScale;\n    u[ind + 8] *= boundryScale;\n    u[ind + 9] *= boundryScale;\n    u[ind + 10] *= boundryScale;\n    u[ind + 11] *= boundryScale;\n    u[ind + 12] *= boundryScale;\n    u[ind + 13] *= boundryScale;\n    u[ind + 14] *= boundryScale;\n    u[ind + 15] *= boundryScale;\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for num_threads(16) private (x)"
    },
    "wahmingchen/parallel-computing/matrix_multiplication_with_MPI/mpi_mm/0": {
        "code": "for (k = 0; k < 200; k++)\n{\n  for (i = 0; i < rows; i++)\n  {\n    c[i][k] = 0.0;\n    for (j = 0; j < 250; j++)\n    {\n      c[i][k] = c[i][k] + (a[i][j] * b[j][k]);\n    }\n\n  }\n\n}\n",
        "pragma": "#pragma omp for schedule(dynamic)"
    },
    "walayd/matrix_computation_openmp/larabi/2": {
        "code": "for (int i = 1; i <= bigMatrix->nb_rows; i++)\n{\n  for (int j = 1; j <= bigMatrix->nb_cols; j++)\n  {\n    int value = getElemFromMatrix(i, j, bigMatrix);\n    setElemToMatrix(i + offset, j, finalMatrix, value);\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "wennys-camilo/OpenMP/bubble_sortV2/1": {
        "code": "for (i = 0; i < ((*tam) - 1); i = i + 2)\n{\n  if (vet[i] > vet[i + 1])\n  {\n    swap(&vet[i], &vet[i + 1]);\n    ++troca;\n  }\n\n}\n",
        "pragma": "#pragma omp for reduction(+ : troca)"
    },
    "wilcoln/be-enseeiht-openmp/stacks/main/0": {
        "code": "for (i = 0; i < n; i++)\n  omp_init_lock(locks + i);\n",
        "pragma": "#pragma omp for"
    },
    "wipping/openMP_demo/chapter9/sibr/0": {
        "code": "for (int i = 0; i < 45; i++)\n{\n  a[i] = fib(b[i]);\n}\n",
        "pragma": "#pragma omp for simd"
    },
    "wusspsj/dacc/pass2omp/8": {
        "code": "for (i = 0; i < vp->dim; i++)\n{\n  if ((rip != 0) && (i == rip->id))\n  {\n    if (rip->spl != 0)\n    {\n      if (count == 0)\n      {\n        if (rip->spl->id == 0)\n        {\n          fprintf(fpkernel, \"(dac_tn == dac_nts-1)?\");\n          fprintf(fpkernel, \"(%s.range[%d]-%s.range[%d]/dac_nts*dac_tn):\", vars->dname, i, vars->dname, i);\n          fprintf(fpkernel, \"(%s.range[%d]/dac_nts)\", vars->dname, i);\n        }\n        else\n        {\n          fprintf(fpkernel, \"%s.range[%d]\", vars->dname, i);\n        }\n\n        break;\n      }\n      else\n        count--;\n\n    }\n\n    rip = rip->next;\n  }\n  else\n  {\n    if (count == 0)\n    {\n      fprintf(fpkernel, \"%s.range[%d]\", vars->dname, i);\n      break;\n    }\n    else\n      count--;\n\n  }\n\n}\n",
        "pragma": ""
    },
    "wwJinkla/Parallel-Computing/hwk3/hw03/2": {
        "code": "for (int i = 0; i < (N + 2); ++i)\n{\n  for (int j = 0; j < (N + 2); ++j)\n  {\n    const double x = (-1.0) + (i * h);\n    const double y = (-1.0) + (j * h);\n    f[i + (j * (N + 2))] = ((sin(3.14159265359 * x) * sin(3.14159265359 * y)) * h) * h;\n  }\n\n}\n",
        "pragma": ""
    },
    "wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/graph/5": {
        "code": "for (v = 0; v < nvtxs; v++)\n{\n  u = iperm[v];\n  for (j = xadj[u]; j < xadj[u + 1]; j++, jj++)\n  {\n    ngraph->adjncy[jj] = perm[adjncy[j]];\n    if (graph->iadjwgt)\n      ngraph->iadjwgt[jj] = graph->iadjwgt[j];\n\n    if (graph->fadjwgt)\n      ngraph->fadjwgt[jj] = graph->fadjwgt[j];\n\n  }\n\n  if (graph->ivwgts)\n    ngraph->ivwgts[v] = graph->ivwgts[u];\n\n  if (graph->fvwgts)\n    ngraph->fvwgts[v] = graph->fvwgts[u];\n\n  if (graph->ivsizes)\n    ngraph->ivsizes[v] = graph->ivsizes[u];\n\n  if (graph->fvsizes)\n    ngraph->fvsizes[v] = graph->fvsizes[u];\n\n  if (graph->vlabels)\n    ngraph->vlabels[v] = graph->vlabels[u];\n\n  ngraph->xadj[v + 1] = jj;\n}\n",
        "pragma": ""
    },
    "xingyousong/Multithreaded-Matrix-Multiply-CS267-HW1-Part2/dgemm-blocked/11": {
        "code": "for (int i = 0; i < lda; i++)\n{\n  int i_pos = ((((i / STRIDE) * STRIDE) * lda) + (0 * STRIDE)) + (i % STRIDE);\n  for (int j = 0; j < lda; j++)\n  {\n    dest[i_pos + (j * STRIDE)] = src[(j * lda) + i];\n  }\n\n}\n",
        "pragma": "#pragma omp for"
    },
    "xyderos/matrix-sum-openmp/ms1/0": {
        "code": "for (i = 0; i < sz; i++)\n  for (j = 0; j < sz; j++)\n  matrix[i][j] = rand() % 99;\n\n",
        "pragma": "#pragma omp parallel for reduction (+:total) private(j)"
    },
    "yadneshk/Parallel-Programming-OpenMP-/exp3/lastprivate/0": {
        "code": "for (i = 0; i < 4; i++)\n{\n  value = value + 1;\n  printf(\"value=%d increased by thread=%d\\n\", value, omp_get_thread_num());\n}\n",
        "pragma": "#pragma omp for firstprivate(value) lastprivate(value)"
    },
    "yangyang14641/Parallel-Matrix-Multiplication-FOX-Algorithm/Code Tests/Dell XPS8900/Testing on Intel Core i7 CPU/Source Codes/fox_floats_timer_caching_omp_fileIO_benchmark/0": {
        "code": "for (i = 0; i < local_A->n_bar; i++)\n{\n  for (j = 0; j < local_A->n_bar; j++)\n    for (k = 0; k < local_B->n_bar; k++)\n    *((local_C->entries + (local_C->n_bar * i)) + j) = (*((local_C->entries + (local_C->n_bar * i)) + j)) + ((*((local_A->entries + (local_A->n_bar * i)) + k)) * (*((local_B->entries + (local_B->n_bar * j)) + k)));\n\n\n}\n",
        "pragma": "#pragma omp parallel for private(i, j, k) shared(local_A, local_B, local_C) num_threads(NUM_THREADS)"
    },
    "ygutgutia/TSP-Genetic-Algorithm-OpenMP/GA_TSP_Parallel/11": {
        "code": "for (int i = 0; i < chromo_length; i++)\n{\n  int nbRand = getRandomNumber() % (chromo_length - i);\n  int tmp = array[nbRand];\n  array[nbRand] = array[(chromo_length - i) - 1];\n  array[(chromo_length - i) - 1] = tmp;\n  chrom->genes[i] = tmp;\n}\n",
        "pragma": ""
    },
    "yoyz/openmp/mcalpin_stream/stream/10": {
        "code": "for (j = 0; j < 40000000; j++)\n{\n  if (((((a[j] / aj) - 1.0) >= 0) ? ((a[j] / aj) - 1.0) : (-((a[j] / aj) - 1.0))) > epsilon)\n  {\n    ierr++;\n  }\n\n}\n",
        "pragma": ""
    },
    "yq314/k-means/k-means-openmp/kmeans/2": {
        "code": "for (i = 0; i < k; i++)\n{\n  tempX = (counts[i]) ? (tempC[i].x / counts[i]) : (0);\n  tempY = (counts[i]) ? (tempC[i].y / counts[i]) : (0);\n  if ((centroids[i].x != tempX) || (centroids[i].y != tempY))\n  {\n    check += 1;\n    centroids[i].x = tempX;\n    centroids[i].y = tempY;\n  }\n\n}\n",
        "pragma": "#pragma omp parallel for private(tempX, tempY) reduction(+:check) num_threads(p)"
    },
    "yuzhouhe2000/Dilated-Winograd-Convolution/cpu/conv2d_cpu/2": {
        "code": "for (n = 0; n < input.N; n++)\n{\n  float *A_n = slice(input.data, ((n * input.H) * input.W) * input.C, (((n + 1) * input.H) * input.W) * input.C);\n  for (int hin = 0; hin < (input.H - 7); hin = hin + 4)\n  {\n    for (int win = 0; win < (input.W - 7); win = win + 4)\n    {\n      float *tile_group = (float *) malloc((((sizeof(float)) * input.C) * 8) * 8);\n      for (int cin = 0; cin < input.C; cin++)\n      {\n        for (int yy = 0; yy < 8; yy++)\n        {\n          for (int xx = 0; xx < 8; xx++)\n          {\n            int posH = hin + yy;\n            int posW = win + xx;\n            int A_n_idx = (((cin * input.H) * input.W) + (posH * input.W)) + posW;\n            tile_group[((cin * 64) + (yy * 8)) + xx] = A_n[A_n_idx];\n          }\n\n        }\n\n      }\n\n      float *tile_output = tile_wino23s1d2_cpu(tile_group, dilated_kernel, Hout, Wout, U);\n      free_(tile_group);\n      for (int cout = 0; cout < kernel.Cout; cout++)\n      {\n        for (int yy = 0; yy < 4; yy++)\n        {\n          for (int xx = 0; xx < 4; xx++)\n          {\n            int posH = hin + yy;\n            int posW = win + xx;\n            int tile_idx = ((cout * 16) + (yy * 4)) + xx;\n            int C_idx = find_NCHW_idx(n, cout, posH, posW, input.N, kernel.Cout, Hout, Wout);\n            C[C_idx] = tile_output[tile_idx];\n          }\n\n        }\n\n      }\n\n      free_(tile_output);\n    }\n\n  }\n\n  free_(A_n);\n}\n",
        "pragma": "#pragma omp parallel for"
    },
    "ziqidong/openmp-openmpi_test/openmp_calculate_substr/Dong_ziqi/9": {
        "code": "for (int i = (a->size / 2) - 1; i < (a->size - 1); i++)\n{\n  if (b->tab[i] < a->tab[i])\n    b->tab[i - ((a->size / 2) - 1)] = a->tab[i];\n  else\n    b->tab[i - ((a->size / 2) - 1)] = b->tab[i];\n\n}\n",
        "pragma": ""
    },
    "zjin-lcf/HeCBench/heat2d-cuda/lapl_ss/3": {
        "code": "for (int y = 0; y < Ly; y++)\n  for (int x = 0; x < (Lx / 4); x++)\n{\n  int vv = x + ((Lx / 4) * y);\n  int v = x + (Lx * y);\n  ssarr[vv].site4[0] = arr[v + ((0 * Lx) / 4)];\n  ssarr[vv].site4[1] = arr[v + ((1 * Lx) / 4)];\n  ssarr[vv].site4[2] = arr[v + ((2 * Lx) / 4)];\n  ssarr[vv].site4[3] = arr[v + ((3 * Lx) / 4)];\n}\n\n",
        "pragma": ""
    },
    "zwhe99/String-Group-By-Parallel-Algorithm/omp_group_by/4": {
        "code": "for (i = 0; i < SIZE_OF_CNT; ++i)\n{\n  curr_sum = sum;\n  sum = cnt[i];\n  cnt[i] = curr_sum;\n  sum += curr_sum;\n}\n",
        "pragma": "#pragma omp for schedule(static)"
    }
}